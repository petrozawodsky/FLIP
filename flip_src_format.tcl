proc auto_reset {} {
    global auto_execs auto_index auto_oldpath
    foreach p [info procs] {
	if {[info exists auto_index($p)] && ![string match auto_* $p] &&([lsearch -exact {unknown pkg_mkIndex tclPkgSetup
tcl_findLibrary pkg_compareExtension
tclMacPkgSearch tclPkgUnknown} $p] < 0)} then {
	    rename $p {}
	}
    }
    catch {unset auto_execs}
    catch {unset auto_index}
    catch {unset auto_oldpath}
}
proc tcl_findLibrary {basename version patch initScript enVarName varName} {
    upvar #0 $varName the_library
    global env errorInfo
    set dirs {}
    set errors {}
    if {[info exist the_library] && [string compare $the_library {}]} then {
	lappend dirs $the_library
    } else {
	if {[info exists env($enVarName)]} then {
	    lappend dirs $env($enVarName)
	}
	lappend dirs [file join [file dirname [info library]] $basename$version]
	set parentDir [file dirname [file dirname [info nameofexecutable]]]
	set grandParentDir [file dirname $parentDir]
	lappend dirs [file join $parentDir lib $basename$version]
	lappend dirs [file join $grandParentDir lib $basename$version]
	lappend dirs [file join $parentDir library]
	lappend dirs [file join $grandParentDir library]
	if {![regexp {.*[ab][0-9]*} $patch ver]} then {
	    set ver $version
	}
	lappend dirs [file join $grandParentDir $basename$ver library]
	lappend dirs [file join [file dirname $grandParentDir] $basename$ver library]
    }
    foreach i $dirs {
	set the_library $i
	set file [file join $i $initScript]
	if {[interp issafe] || [file exists $file]} then {
	    if {![catch {uplevel #0 [list source $file]} msg]} then {
		return
	    } else {
		append errors "$file: $msg\n$errorInfo\n"
	    }
	}
    }
    set msg "Can't find a usable $initScript in the following directories: \n"
    append msg "    $dirs\n\n"
    append msg "$errors\n\n"
    append msg "This probably means that $basename wasn't installed properly.\n"
    error $msg
}
if {[interp issafe]} then {
    return ;# Stop sourcing the file here
}
proc auto_mkindex {dir args} {
    global errorCode errorInfo
    if {[interp issafe]} then {
	error "can't generate index within safe interpreter"
    }
    set oldDir [pwd]
    cd $dir
    set dir [pwd]
    append index "# Tcl autoload index file, version 2.0\n"
    append index "# This file is generated by the \"auto_mkindex\" command\n"
    append index "# and sourced to set up indexing information for one or\n"
    append index "# more commands.  Typically each line is a command that\n"
    append index "# sets an element in the auto_index array, where the\n"
    append index "# element name is the name of a command and the value is\n"
    append index "# a script that loads the command.\n\n"
    if {$args == ""} then {
	set args *.tcl
    }
    auto_mkindex_parser::init
    foreach file [eval glob $args] {
	if {[catch {auto_mkindex_parser::mkindex $file} msg] == 0} then {
	    append index $msg
	} else {
	    set code $errorCode
	    set info $errorInfo
	    cd $oldDir
	    error $msg $info $code
	}
    }
    auto_mkindex_parser::cleanup
    set fid [open "tclIndex" w]
    puts -nonewline $fid $index
    close $fid
    cd $oldDir
}
proc auto_mkindex_old {dir args} {
    global errorCode errorInfo
    set oldDir [pwd]
    cd $dir
    set dir [pwd]
    append index "# Tcl autoload index file, version 2.0\n"
    append index "# This file is generated by the \"auto_mkindex\" command\n"
    append index "# and sourced to set up indexing information for one or\n"
    append index "# more commands.  Typically each line is a command that\n"
    append index "# sets an element in the auto_index array, where the\n"
    append index "# element name is the name of a command and the value is\n"
    append index "# a script that loads the command.\n\n"
    if {[string equal $args ""]} then {
	set args *.tcl
    }
    foreach file [eval glob $args] {
	set f ""
	set error [catch {
	    set f [open $file]
	    while {[gets $f line] >= 0} {
		if {[regexp {^proc[ 	]+([^ 	]*)} $line match procName]} then {
		    set procName [lindex [auto_qualify $procName "::"] 0]
		    append index "set [list auto_index($procName)]"
		    append index " \[list source \[file join \$dir [list $file]\]\]\n"
		}
	    }
	    close $f
	} msg]
	if {$error} then {
	    set code $errorCode
	    set info $errorInfo
	    catch {close $f}
	    cd $oldDir
	    error $msg $info $code
	}
    }
    set f ""
    set error [catch {
	set f [open tclIndex w]
	puts -nonewline $f $index
	close $f
	cd $oldDir
    } msg]
    if {$error} then {
	set code $errorCode
	set info $errorInfo
	catch {close $f}
	cd $oldDir
	error $msg $info $code
    }
}
namespace eval auto_mkindex_parser {
    variable parser "" ;# parser used to build index
    variable index "" ;# maintains index as it is built
    variable scriptFile "" ;# name of file being processed
    variable contextStack "" ;# stack of namespace scopes
    variable imports "" ;# keeps track of all imported cmds
    variable initCommands "" ;# list of commands that create aliases
    proc init {} {
	variable parser
	variable initCommands
	if {![interp issafe]} then {
	    set parser [interp create -safe]
	    $parser hide info
	    $parser hide rename
	    $parser hide proc
	    $parser hide namespace
	    $parser hide eval
	    $parser hide puts
	    $parser invokehidden namespace delete ::
	    $parser invokehidden proc unknown {args} {}
	    $parser expose namespace
	    $parser invokehidden rename namespace _%@namespace
	    $parser expose eval
	    $parser invokehidden rename eval _%@eval
	    foreach cmd $initCommands {
		eval $cmd
	    }
	}
    }
    proc cleanup {} {
	variable parser
	interp delete $parser
	unset parser
    }
}
proc auto_mkindex_parser::mkindex {file} {
    variable parser
    variable index
    variable scriptFile
    variable contextStack
    variable imports
    set scriptFile $file
    set fid [open $file]
    set contents [read $fid]
    close $fid
    regsub -all {\$} $contents "\0" contents
    set index ""
    set contextStack ""
    set imports ""
    $parser eval $contents
    foreach name $imports {
	catch {$parser eval [list _%@namespace forget $name]}
    }
    return $index
}
proc auto_mkindex_parser::hook {cmd} {
    variable initCommands
    lappend initCommands $cmd
}
proc auto_mkindex_parser::slavehook {cmd} {
    variable initCommands
    lappend initCommands "\$parser eval [list $cmd]"
}
proc auto_mkindex_parser::command {name arglist body} {
    hook [list auto_mkindex_parser::commandInit $name $arglist $body]
}
proc auto_mkindex_parser::commandInit {name arglist body} {
    variable parser
    set ns [namespace qualifiers $name]
    set tail [namespace tail $name]
    if {[string equal $ns ""]} then {
	set fakeName "[namespace current]::_%@fake_$tail"
    } else {
	set fakeName "_%@fake_$name"
	regsub -all {::} $fakeName "_" fakeName
	set fakeName "[namespace current]::$fakeName"
    }
    proc $fakeName $arglist $body
    if {[regexp {::} $name]} then {
	set exportCmd [list _%@namespace export [namespace tail $name]]
	$parser eval [list _%@namespace eval $ns $exportCmd]
	set alias [namespace tail $fakeName]
	$parser invokehidden proc $name {args} "_%@eval {$alias} \$args"
	$parser alias $alias $fakeName
    } else {
	$parser alias $name $fakeName
    }
    return
}
proc auto_mkindex_parser::fullname {name} {
    variable contextStack
    if {![string match ::* $name]} then {
	foreach ns $contextStack {
	    set name "${ns}::$name"
	    if {[string match ::* $name]} then {
		break
	    }
	}
    }
    if {[string equal [namespace qualifiers $name] ""]} then {
	set name [namespace tail $name]
    } elseif {![string match ::* $name]} {
	set name "::$name"
    }
    regsub -all "\0" $name "\$" name
    return $name
}
auto_mkindex_parser::command proc {name args} {
variable index
variable scriptFile
append index [list set auto_index([fullname $name])] \
	    [format { [list source [file join $dir %s]]} \
	    [file split $scriptFile]] "\n"
}
auto_mkindex_parser::hook {
if {![catch {package require tbcload}]} {
if {[llength [info commands tbcload::bcproc]] == 0} {
auto_load tbcload::bcproc
}
load {} tbcload $auto_mkindex_parser::parser
auto_mkindex_parser::commandInit tbcload::bcproc {name args} {
variable index
variable scriptFile
append index [list set auto_index([fullname $name])] \
		    [format { [list source [file join $dir %s]]} \
		    [file split $scriptFile]] "\n"
}
}
}
auto_mkindex_parser::command namespace {op args} {
switch -- $op {
eval {
variable parser
variable contextStack
set name [lindex $args 0]
set args [lrange $args 1 end]
set contextStack [linsert $contextStack 0 $name]
$parser eval [list _%@namespace eval $name] $args
set contextStack [lrange $contextStack 1 end]
}
import {
variable parser
variable imports
foreach pattern $args {
if {[string compare $pattern "-force"]} {
lappend imports $pattern
}
}
catch {$parser eval "_%@namespace import $args"}
}
}
}
return
namespace eval tcl {
    variable history
    if {![info exists history]} then {
	array set history {
nextid	0
keep	20
oldest	-20
}
    }
}
proc history {args} {
    set len [llength $args]
    if {$len == 0} then {
	return [tcl::HistInfo]
    }
    set key [lindex $args 0]
    set options "add, change, clear, event, info, keep, nextid, or redo"
    switch -glob -- $key {
    a* {
	    # history add
	    if {$len > 3} then {
		return -code error "wrong # args: should be \"history add event ?exec?\""
	    }
	    if {![string match $key* add]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    if {$len == 3} then {
		set arg [lindex $args 2]
		if {!([string match e* $arg] && [string match $arg* exec])} then {
		    return -code error "bad argument \"$arg\": should be \"exec\""
		}
	    }
	    return [tcl::HistAdd [lindex $args 1] [lindex $args 2]]
	}
    ch* {
	    # history change
	    if {($len > 3) ||($len < 2)} then {
		return -code error "wrong # args: should be \"history change newValue ?event?\""
	    }
	    if {![string match $key* change]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    if {$len == 2} then {
		set event 0
	    } else {
		set event [lindex $args 2]
	    }
	    return [tcl::HistChange [lindex $args 1] $event]
	}
    cl* {
	    # history clear
	    if {($len > 1)} then {
		return -code error "wrong # args: should be \"history clear\""
	    }
	    if {![string match $key* clear]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    return [tcl::HistClear]
	}
    e* {
	    # history event
	    if {$len > 2} then {
		return -code error "wrong # args: should be \"history event ?event?\""
	    }
	    if {![string match $key* event]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    if {$len == 1} then {
		set event -1
	    } else {
		set event [lindex $args 1]
	    }
	    return [tcl::HistEvent $event]
	}
    i* {
	    # history info
	    if {$len > 2} then {
		return -code error "wrong # args: should be \"history info ?count?\""
	    }
	    if {![string match $key* info]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    return [tcl::HistInfo [lindex $args 1]]
	}
    k* {
	    # history keep
	    if {$len > 2} then {
		return -code error "wrong # args: should be \"history keep ?count?\""
	    }
	    if {$len == 1} then {
		return [tcl::HistKeep]
	    } else {
		set limit [lindex $args 1]
		if {[catch {expr {~$limit}}] ||($limit < 0)} then {
		    return -code error "illegal keep count \"$limit\""
		}
		return [tcl::HistKeep $limit]
	    }
	}
    n* {
	    # history nextid
	    if {$len > 1} then {
		return -code error "wrong # args: should be \"history nextid\""
	    }
	    if {![string match $key* nextid]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    return [expr {$tcl::history(nextid) + 1}]
	}
    r* {
	    # history redo
	    if {$len > 2} then {
		return -code error "wrong # args: should be \"history redo ?event?\""
	    }
	    if {![string match $key* redo]} then {
		return -code error "bad option \"$key\": must be $options"
	    }
	    return [tcl::HistRedo [lindex $args 1]]
	}
    default {
	    return -code error "bad option \"$key\": must be $options"
	}
    }
}
proc tcl::HistAdd {command {exec {}}} {
    variable history
    set i [incr history(nextid)]
    set history($i) $command
    set j [incr history(oldest)]
    if {[info exists history($j)]} then {
	unset history($j)
    }
    if {[string match e* $exec]} then {
	return [uplevel #0 $command]
    } else {
	return {}
    }
}
proc tcl::HistKeep {{limit {}}} {
    variable history
    if {[string length $limit] == 0} then {
	return $history(keep)
    } else {
	set oldold $history(oldest)
	set history(oldest) [expr {$history(nextid) - $limit}]
	for {} {$oldold <= $history(oldest)} {incr oldold} {
	    if {[info exists history($oldold)]} then {
		unset history($oldold)
	    }
	}
	set history(keep) $limit
    }
}
proc tcl::HistClear {} {
    variable history
    set keep $history(keep)
    unset history
    array set history [list nextid 0 keep $keep oldest -$keep]
}
proc tcl::HistInfo {{num {}}} {
    variable history
    if {$num == {}} then {
	set num [expr {$history(keep) + 1}]
    }
    set result {}
    set newline ""
    for {set i [expr {$history(nextid) - $num + 1}]} {$i <= $history(nextid)} {incr i} {
	if {![info exists history($i)]} then {
	    continue
	}
	set cmd [string trimright $history($i) \ \n]
	regsub -all \n $cmd "\n\t" cmd
	append result $newline[format "%6d  %s" $i $cmd]
	set newline \n
    }
    return $result
}
proc tcl::HistRedo {{event -1}} {
    variable history
    if {[string length $event] == 0} then {
	set event -1
    }
    set i [HistIndex $event]
    if {$i == $history(nextid)} then {
	return -code error "cannot redo the current event"
    }
    set cmd $history($i)
    HistChange $cmd 0
    uplevel #0 $cmd
}
proc tcl::HistIndex {event} {
    variable history
    if {[catch {expr {~$event}}]} then {
	for {set i $history(nextid)} {[info exists history($i)]} {incr i -1} {
	    if {[string match $event* $history($i)]} then {
		return $i

	    }
	    if {[string match $event $history($i)]} then {
		return $i

	    }
	}
	return -code error "no event matches \"$event\""
    } elseif {$event <= 0} {
	set i [expr {$history(nextid) + $event}]
    } else {
	set i $event
    }
    if {$i <= $history(oldest)} then {
	return -code error "event \"$event\" is too far in the past"
    }
    if {$i > $history(nextid)} then {
	return -code error "event \"$event\" hasn't occured yet"
    }
    return $i
}
proc tcl::HistEvent {event} {
    variable history
    set i [HistIndex $event]
    if {[info exists history($i)]} then {
	return [string trimright $history($i) \ \n]
    } else {
	return ""

    }
}
proc tcl::HistChange {cmd {event 0}} {
    variable history
    set i [HistIndex $event]
    set history($i) $cmd
}
if {[info commands package] == ""} then {
    error "version mismatch: library\nscripts expect Tcl version 7.5b1 or later but the loaded version is\nonly [info patchlevel]"
}
package require -exact Tcl 8.3
if {![info exists auto_path]} then {
    if {[info exist env(TCLLIBPATH)]} then {
	set auto_path $env(TCLLIBPATH)
    } else {
	set auto_path ""
    }
}
if {[string compare [info library] {}]} then {
    foreach __dir [list [info library] [file dirname [info library]]] {
	if {[lsearch -exact $auto_path $__dir] < 0} then {
	    lappend auto_path $__dir
	}
    }
}
set __dir [file join [file dirname [file dirname [info nameofexecutable]]] lib]
if {[lsearch -exact $auto_path $__dir] < 0} then {
    lappend auto_path $__dir
}
if {[info exist tcl_pkgPath]} then {
    foreach __dir $tcl_pkgPath {
	if {[lsearch -exact $auto_path $__dir] < 0} then {
	    lappend auto_path $__dir
	}
    }
}
if {[info exists __dir]} then {
    unset __dir
}
if {(![interp issafe]) && [string equal $tcl_platform(platform) "windows"]} then {
    namespace eval tcl {
	proc envTraceProc {lo n1 n2 op} {
	    set x $::env($n2)
	    set ::env($lo) $x
	    set ::env([string toupper $lo]) $x
	}
    }
    foreach p [array names env] {
	set u [string toupper $p]
	if {[string compare $u $p]} then {
	    switch -- $u {
	    COMSPEC -
	    PATH {
		    if {![info exists env($u)]} then {
			set env($u) $env($p)
		    }
		    trace variable env($p) w [list tcl::envTraceProc $p]
		    trace variable env($u) w [list tcl::envTraceProc $p]
		}
	    }
	}
    }
    if {[info exists p]} then {
	unset p
    }
    if {[info exists u]} then {
	unset u
    }
    if {![info exists env(COMSPEC)]} then {
	if {[string equal $tcl_platform(os) "Windows NT"]} then {
	    set env(COMSPEC) cmd.exe
	} else {
	    set env(COMSPEC) command.com
	}
    }
}
package unknown tclPkgUnknown
if {[llength [info commands exec]] == 0} then {
    set auto_noexec 1
}
set errorCode ""
set errorInfo ""
if {[llength [info commands tclLog]] == 0} then {
    proc tclLog {string} {
	catch {puts stderr $string}
    }
}
proc unknown args {
    global auto_noexec auto_noload env unknown_pending tcl_interactive
    global errorCode errorInfo
    set cmd [lindex $args 0]
    if {[regexp "^namespace\[ \t\n\]+inscope" $cmd] && [llength $cmd] == 4} then {
	set arglist [lrange $args 1 end]
	set ret [catch {uplevel $cmd $arglist} result]
	if {$ret == 0} then {
	    return $result
	} else {
	    return -code $ret -errorcode $errorCode $result
	}
    }
    set savedErrorCode $errorCode
    set savedErrorInfo $errorInfo
    set name [lindex $args 0]
    if {![info exists auto_noload]} then {
	if {[info exists unknown_pending($name)]} then {
	    return -code error "self-referential recursion in \"unknown\" for command \"$name\""

	}
	set unknown_pending($name) pending

	set ret [catch {auto_load $name [uplevel 1 {namespace current}]} msg]
	unset unknown_pending($name)

	if {$ret != 0} then {
	    append errorInfo "\n    (autoloading \"$name\")"
	    return -code $ret -errorcode $errorCode -errorinfo $errorInfo $msg
	}
	if {![array size unknown_pending]} then {
	    unset unknown_pending
	}
	if {$msg} then {
	    set errorCode $savedErrorCode
	    set errorInfo $savedErrorInfo
	    set code [catch {uplevel 1 $args} msg]
	    if {$code == 1} then {
		set new [split $errorInfo \n]
		set new [join [lrange $new 0 [expr {[llength $new] - 6}]] \n]
		return -code error -errorcode $errorCode -errorinfo $new $msg
	    } else {
		return -code $code $msg
	    }
	}
    }
    if {([info level] == 1) && [string equal [info script] ""] && [info exists tcl_interactive] && $tcl_interactive} then {
	if {![info exists auto_noexec]} then {
	    set new [auto_execok $name]
	    if {[string compare {} $new]} then {
		set errorCode $savedErrorCode
		set errorInfo $savedErrorInfo
		set redir ""
		if {[string equal [info commands console] ""]} then {
		    set redir ">&@stdout <@stdin"
		}
		return [uplevel exec $redir $new [lrange $args 1 end]]
	    }
	}
	set errorCode $savedErrorCode
	set errorInfo $savedErrorInfo
	if {[string equal $name "!!"]} then {
	    set newcmd [history event]
	} elseif {[regexp {^!(.+)$} $name dummy event]} {
	    set newcmd [history event $event]
	} elseif {[regexp {^\^([^^]*)\^([^^]*)\^?$} $name dummy old new]} {
	    set newcmd [history event -1]
	    catch {regsub -all -- $old $newcmd $new newcmd}
	}
	if {[info exists newcmd]} then {
	    tclLog $newcmd
	    history change $newcmd 0
	    return [uplevel $newcmd]
	}
	set ret [catch {set cmds [info commands $name*]} msg]
	if {[string equal $name "::"]} then {
	    set name ""
	}
	if {$ret != 0} then {
	    return -code $ret -errorcode $errorCode "error in unknown while checking if \"$name\" is a unique command abbreviation: $msg"
	}
	if {[llength $cmds] == 1} then {
	    return [uplevel [lreplace $args 0 0 $cmds]]
	}
	if {[llength $cmds]} then {
	    if {[string equal $name ""]} then {
		return -code error "empty command name \"\""
	    } else {
		return -code error "ambiguous command name \"$name\": [lsort $cmds]"
	    }
	}
    }
    return -code error "invalid command name \"$name\""
}
proc auto_load {cmd {namespace {}}} {
    global auto_index auto_oldpath auto_path
    if {[string length $namespace] == 0} then {
	set namespace [uplevel {namespace current}]
    }
    set nameList [auto_qualify $cmd $namespace]
    lappend nameList $cmd
    foreach name $nameList {
	if {[info exists auto_index($name)]} then {
	    uplevel #0 $auto_index($name)
	    return [expr {[info commands $name] != ""}]
	}
    }
    if {![info exists auto_path]} then {
	return 0
    }
    if {![auto_load_index]} then {
	return 0
    }
    foreach name $nameList {
	if {[info exists auto_index($name)]} then {
	    uplevel #0 $auto_index($name)
	    if {![string equal [namespace which -command $name] ""]} then {
		return 1
	    }
	}
    }
    return 0
}
proc auto_load_index {} {
    global auto_index auto_oldpath auto_path errorInfo errorCode
    if {[info exists auto_oldpath] && [string equal $auto_oldpath $auto_path]} then {
	return 0
    }
    set auto_oldpath $auto_path
    set issafe [interp issafe]
    for {set i [expr {[llength $auto_path] - 1}]} {$i >= 0} {incr i -1} {
	set dir [lindex $auto_path $i]
	set f ""
	if {$issafe} then {
	    catch {source [file join $dir tclIndex]}
	} elseif {[catch {set f [open [file join $dir tclIndex]]}]} {
	    continue
	} else {
	    set error [catch {
		set id [gets $f]
		if {[string equal $id "# Tcl autoload index file, version 2.0"]} then {
		    eval [read $f]
		} elseif {[string equal $id "# Tcl autoload index file: each line identifies a Tcl"]} {
		    while {[gets $f line] >= 0} {
			if {[string equal [string index $line 0] "#"] ||([llength $line] != 2)} then {
			    continue
			}
			set name [lindex $line 0]
			set auto_index($name) "source [file join $dir [lindex $line 1]]"
		    }
		} else {
		    error "[file join $dir tclIndex] isn't a proper Tcl index file"
		}
	    } msg]
	    if {[string compare $f ""]} then {
		close $f
	    }
	    if {$error} then {
		error $msg $errorInfo $errorCode
	    }
	}
    }
    return 1
}
proc auto_qualify {cmd namespace} {
    set n [regsub -all {::+} $cmd :: cmd]
    if {[regexp {^::(.*)$} $cmd x tail]} then {
	if {$n > 1} then {
	    return [list $cmd]
	} else {
	    return [list $tail]
	}
    }
    if {$n == 0} then {
	if {[string equal $namespace ::]} then {
	    return [list $cmd]
	} else {
	    return [list ${namespace}::$cmd $cmd]
	}
    } elseif {[string equal $namespace ::]} {
	return [list ::$cmd]
    } else {
	return [list ${namespace}::$cmd ::$cmd]
    }
}
proc auto_import {pattern} {
    global auto_index
    set ns [uplevel namespace current]
    set patternList [auto_qualify $pattern $ns]
    auto_load_index
    foreach pattern $patternList {
	foreach name [array names auto_index] {
	    if {[string match $pattern $name] && [string equal "" [info commands $name]]} then {
		uplevel #0 $auto_index($name)
	    }
	}
    }
}
if {[string equal windows $tcl_platform(platform)]} then {
    proc auto_execok name {
	global auto_execs env tcl_platform
	if {[info exists auto_execs($name)]} then {
	    return $auto_execs($name)
	}
	set auto_execs($name) ""
	set shellBuiltins [list cls copy date del erase dir echo mkdir md rename ren rmdir rd time type ver vol]
	if {[string equal $tcl_platform(os) "Windows NT"]} then {
	    lappend shellBuiltins "start"
	}
	if {[lsearch -exact $shellBuiltins $name] != -1} then {
	    return [set auto_execs($name) [list $env(COMSPEC) /c $name]]
	}
	if {[llength [file split $name]] != 1} then {
	    foreach ext {{} .com .exe .bat} {
		set file ${name}${ext}
		if {[file exists $file] && ![file isdirectory $file]} then {
		    return [set auto_execs($name) [list $file]]
		}
	    }
	    return ""
	}
	set path "[file dirname [info nameof]];.;"
	if {[info exists env(WINDIR)]} then {
	    set windir $env(WINDIR)
	}
	if {[info exists windir]} then {
	    if {[string equal $tcl_platform(os) "Windows NT"]} then {
		append path "$windir/system32;"
	    }
	    append path "$windir/system;$windir;"
	}
	foreach var {PATH Path path} {
	    if {[info exists env($var)]} then {
		append path ";$env($var)"
	    }
	}
	foreach dir [split $path {;}] {
	    if {[info exists checked($dir)] || [string equal {} $dir]} then {
		continue
	    }
	    set checked($dir) {}
	    foreach ext {{} .com .exe .bat} {
		set file [file join $dir ${name}${ext}]
		if {[file exists $file] && ![file isdirectory $file]} then {
		    return [set auto_execs($name) [list $file]]
		}
	    }
	}
	return ""
    }
} else {
    proc auto_execok name {
	global auto_execs env
	if {[info exists auto_execs($name)]} then {
	    return $auto_execs($name)
	}
	set auto_execs($name) ""
	if {[llength [file split $name]] != 1} then {
	    if {[file executable $name] && ![file isdirectory $name]} then {
		set auto_execs($name) [list $name]
	    }
	    return $auto_execs($name)
	}
	foreach dir [split $env(PATH) :] {
	    if {[string equal $dir ""]} then {
		set dir .
	    }
	    set file [file join $dir $name]
	    if {[file executable $file] && ![file isdirectory $file]} then {
		set auto_execs($name) [list $file]
		return $auto_execs($name)
	    }
	}
	return ""
    }
}
namespace eval ::pkg {
}
proc pkg_compareExtension {fileName {ext {}}} {
    global tcl_platform
    if {[string length $ext] == 0} then {
	set ext [info sharedlibextension]
    }
    if {[string equal $tcl_platform(platform) "windows"]} then {
	return [string equal -nocase [file extension $fileName] $ext]
    } else {
	return [string equal [file extension $fileName] $ext]
    }
}
proc pkg_mkIndex {args} {
    global errorCode errorInfo
    set usage {"pkg_mkIndex ?-direct? ?-verbose? ?-load pattern? ?--? dir ?pattern ...?"}

    set argCount [llength $args]
    if {$argCount < 1} then {
	return -code error "wrong # args: should be\n$usage"
    }
    set more ""
    set direct 1
    set doVerbose 0
    set loadPat ""
    for {set idx 0} {$idx < $argCount} {incr idx} {
	set flag [lindex $args $idx]
	switch -glob -- $flag {
	-- {
		incr idx
		break
	    }
	-verbose {
		set doVerbose 1
	    }
	-lazy {
		set direct 0
		append more " -lazy"
	    }
	-direct {
		append more " -direct"
	    }
	-load {
		incr idx
		set loadPat [lindex $args $idx]
		append more " -load $loadPat"
	    }
	-* {
		return -code error "unknown flag $flag: should be\n$usage"
	    }
	default {
		break
	    }
	}
    }
    set dir [lindex $args $idx]
    set patternList [lrange $args [expr {$idx + 1}] end]
    if {[llength $patternList] == 0} then {
	set patternList [list "*.tcl" "*[info sharedlibextension]"]
    }
    set oldDir [pwd]
    cd $dir
    if {[catch {eval glob $patternList} fileList]} then {
	global errorCode errorInfo
	cd $oldDir
	return -code error -errorcode $errorCode -errorinfo $errorInfo $fileList
    }
    foreach file $fileList {
	if {[string equal $file "pkgIndex.tcl"]} then {
	    continue
	}
	cd $oldDir
	set c [interp create]
	foreach pkg [info loaded] {
	    if {! [string match $loadPat [lindex $pkg 1]]} then {
		continue
	    }
	    if {[catch {
		load [lindex $pkg 0] [lindex $pkg 1] $c
	    } err]} then {
		if {$doVerbose} then {
		    tclLog "warning: load [lindex $pkg 0] [lindex $pkg 1]\nfailed with: $err"
		}
	    } elseif {$doVerbose} {
		tclLog "loaded [lindex $pkg 0] [lindex $pkg 1]"
	    }
	    if {[string equal [lindex $pkg 1] "Tk"]} then {
		$c eval [list wm withdraw .]
	    }
	}
	cd $dir
	$c eval {
rename package __package_orig
proc package {what args} {
switch -- $what {
require { return ; # ignore transitive requires }
default { eval __package_orig {$what} $args }
}
}
proc tclPkgUnknown args {}
package unknown tclPkgUnknown
proc unknown {args} {}
proc auto_import {args} {}
namespace eval ::tcl {
variable file		;# Current file being processed
variable direct		;# -direct flag value
variable x		;# Loop variable
variable debug		;# For debugging
variable type		;# "load" or "source", for -direct
variable namespaces	;# Existing namespaces (e.g., ::tcl)
variable packages	;# Existing packages (e.g., Tcl)
variable origCmds	;# Existing commands
variable newCmds	;# Newly created commands
variable newPkgs {}	;# Newly created packages
}
}
	$c eval [list set ::tcl::file $file]
	$c eval [list set ::tcl::direct $direct]
	foreach p {pkg_compareExtension} {
	    $c eval [list proc $p [info args $p] [info body $p]]
	}
	if {[catch {
	    $c eval {
set ::tcl::debug "loading or sourcing"
proc ::tcl::GetAllNamespaces {{root ::}} {
set list $root
foreach ns [namespace children $root] {
eval lappend list [::tcl::GetAllNamespaces $ns]
}
return $list
}
foreach ::tcl::x [::tcl::GetAllNamespaces] {
set ::tcl::namespaces($::tcl::x) 1
}
foreach ::tcl::x [package names] {
set ::tcl::packages($::tcl::x) 1
}
set ::tcl::origCmds [info commands]
if {[pkg_compareExtension $::tcl::file [info sharedlibextension]]} {
set ::tcl::debug loading
load [file join . $::tcl::file]
set ::tcl::type load
} else {
set ::tcl::debug sourcing
source $::tcl::file
set ::tcl::type source
}
if { !$::tcl::direct } {
foreach ::tcl::x [::tcl::GetAllNamespaces] {
if {! [info exists ::tcl::namespaces($::tcl::x)]} {
namespace import -force ${::tcl::x}::*
}
foreach ::tcl::x [info commands] {
set ::tcl::newCmds($::tcl::x) 1
}
foreach ::tcl::x $::tcl::origCmds {
catch {unset ::tcl::newCmds($::tcl::x)}
}
foreach ::tcl::x [array names ::tcl::newCmds] {
set ::tcl::abs [namespace origin $::tcl::x]
set ::tcl::abs \
				    [lindex [auto_qualify $::tcl::abs ::] 0]
if {[string compare $::tcl::x $::tcl::abs]} {
set ::tcl::newCmds($::tcl::abs) 1
unset ::tcl::newCmds($::tcl::x)
}
}
}
}
foreach ::tcl::x [package names] {
if {[string compare [package provide $::tcl::x] ""] \
			    && ![info exists ::tcl::packages($::tcl::x)]} {
lappend ::tcl::newPkgs \
			    [list $::tcl::x [package provide $::tcl::x]]
}
}
}
	} msg] == 1} then {
	    set what [$c eval set ::tcl::debug]
	    if {$doVerbose} then {
		tclLog "warning: error while $what $file: $msg"
	    }
	} else {
	    set type [$c eval set ::tcl::type]
	    set cmds [lsort [$c eval array names ::tcl::newCmds]]
	    set pkgs [$c eval set ::tcl::newPkgs]
	    if {[llength $pkgs] > 1} then {
		tclLog "warning: \"$file\" provides more than one package ($pkgs)"
	    }
	    foreach pkg $pkgs {
		lappend files($pkg) [list $file $type $cmds]
	    }
	    if {$doVerbose} then {
		tclLog "processed $file"
	    }
	    interp delete $c
	}
    }
    append index "# Tcl package index file, version 1.1\n"
    append index "# This file is generated by the \"pkg_mkIndex$more\" command\n"
    append index "# and sourced either when an application starts up or\n"
    append index "# by a \"package unknown\" script.  It invokes the\n"
    append index "# \"package ifneeded\" command to set up package-related\n"
    append index "# information so that packages will be loaded automatically\n"
    append index "# in response to \"package require\" commands.  When this\n"
    append index "# script is sourced, the variable \$dir must contain the\n"
    append index "# full path name of this file's directory.\n"
    foreach pkg [lsort [array names files]] {
	set cmd {}
	foreach {name version} $pkg {
	    break
	}
	lappend cmd ::pkg::create -name $name -version $version
	foreach spec $files($pkg) {
	    foreach {file type procs} $spec {
		if {$direct} then {
		    set procs {}
		}
		lappend cmd "-$type" [list $file $procs]
	    }
	}
	append index "\n[eval $cmd]"
    }
    set f [open pkgIndex.tcl w]
    puts $f $index
    close $f
    cd $oldDir
}
proc tclPkgSetup {dir pkg version files} {
    global auto_index
    package provide $pkg $version
    foreach fileInfo $files {
	set f [lindex $fileInfo 0]
	set type [lindex $fileInfo 1]
	foreach cmd [lindex $fileInfo 2] {
	    if {[string equal $type "load"]} then {
		set auto_index($cmd) [list load [file join $dir $f] $pkg]
	    } else {
		set auto_index($cmd) [list source [file join $dir $f]]
	    }
	}
    }
}
proc tclMacPkgSearch {dir} {
    foreach x [glob -nocomplain [file join $dir *.shlb]] {
	if {[file isfile $x]} then {
	    set res [resource open $x]
	    foreach y [resource list TEXT $res] {
		if {[string equal $y "pkgIndex"]} then {
		    source -rsrc pkgIndex
		}
	    }
	    catch {resource close $res}
	}
    }
}
proc tclPkgUnknown {name version {exact {}}} {
    global auto_path tcl_platform env
    if {![info exists auto_path]} then {
	return
    }
    set old_path [set use_path $auto_path]
    while {[llength $use_path]} {
	set dir [lindex $use_path end]
	catch {
	    foreach file [glob -nocomplain [file join $dir * pkgIndex.tcl]] {
		set dir [file dirname $file]
		if {[file readable $file] && ![info exists procdDirs($dir)]} then {
		    if {[catch {source $file} msg]} then {
			tclLog "error reading package index file $file: $msg"
		    } else {
			set procdDirs($dir) 1
		    }
		}
	    }
	}
	set dir [lindex $use_path end]
	set file [file join $dir pkgIndex.tcl]
	if {([interp issafe] || [file readable $file]) && ![info exists procdDirs($dir)]} then {
	    if {[catch {source $file} msg] && ![interp issafe]} then {
		tclLog "error reading package index file $file: $msg"
	    } else {
		set procdDirs($dir) 1
	    }
	}
	if {(![interp issafe]) && [string equal $tcl_platform(platform) "macintosh"]} then {
	    set dir [lindex $use_path end]
	    if {![info exists procdDirs($dir)]} then {
		tclMacPkgSearch $dir
		set procdDirs($dir) 1
	    }
	    foreach x [glob -nocomplain [file join $dir *]] {
		if {[file isdirectory $x] && ![info exists procdDirs($x)]} then {
		    set dir $x
		    tclMacPkgSearch $dir
		    set procdDirs($dir) 1
		}
	    }
	}
	set use_path [lrange $use_path 0 end-1]
	if {[string compare $old_path $auto_path]} then {
	    foreach dir $auto_path {
		lappend use_path $dir
	    }
	    set old_path $auto_path
	}
    }
}
proc ::pkg::create {args} {
    append err(usage) "[lindex [info level 0] 0] "
    append err(usage) "-name packageName -version packageVersion"
    append err(usage) "?-load {filename ?{procs}?}? ... "
    append err(usage) "?-source {filename ?{procs}?}? ..."
    set err(wrongNumArgs) "wrong # args: should be \"$err(usage)\""
    set err(valueMissing) "value for \"%s\" missing: should be \"$err(usage)\""
    set err(unknownOpt) "unknown option \"%s\": should be \"$err(usage)\""
    set err(noLoadOrSource) "at least one of -load and -source must be given"
    set len [llength $args]
    if {$len < 6} then {
	error $err(wrongNumArgs)
    }
    set opts(-name) {}
    set opts(-version) {}
    set opts(-source) {}
    set opts(-load) {}
    for {set i 0} {$i < $len} {incr i} {
	set flag [lindex $args $i]
	incr i
	switch -glob -- $flag {
	"-name" -
	"-version" {
		if {$i >= $len} then {
		    error [format $err(valueMissing) $flag]
		}
		set opts($flag) [lindex $args $i]
	    }
	"-source" -
	"-load" {
		if {$i >= $len} then {
		    error [format $err(valueMissing) $flag]
		}
		lappend opts($flag) [lindex $args $i]
	    }
	default {
		error [format $err(unknownOpt) [lindex $args $i]]
	    }
	}
    }
    if {[llength $opts(-name)] == 0} then {
	error [format $err(valueMissing) "-name"]
    }
    if {[llength $opts(-version)] == 0} then {
	error [format $err(valueMissing) "-version"]
    }
    if {[llength $opts(-source)] == 0 && [llength $opts(-load)] == 0} then {
	error $err(noLoadOrSource)
    }
    set cmdline "package ifneeded $opts(-name) $opts(-version) "
    set cmdList {}
    set lazyFileList {}
    foreach key {load source} {
	foreach filespec $opts(-$key) {
	    foreach {filename proclist} {{} {}} {
		break
	    }
	    foreach {filename proclist} $filespec {
		break
	    }
	    if {[llength $proclist] == 0} then {
		set cmd "\[list $key \[file join \$dir [list $filename]\]\]"
		lappend cmdList $cmd
	    } else {
		lappend lazyFileList [list $filename $key $proclist]
	    }
	}
    }
    if {[llength $lazyFileList] > 0} then {
	lappend cmdList "\[list tclPkgSetup \$dir $opts(-name) $opts(-version) [list $lazyFileList]\]"
    }
    append cmdline [join $cmdList "\\n"]
    return $cmdline
}
proc parray {a {pattern *}} {
    upvar 1 $a array
    if {![array exists array]} then {
	error "\"$a\" isn't an array"
    }
    set maxl 0
    foreach name [lsort [array names array $pattern]] {
	if {[string length $name] > $maxl} then {
	    set maxl [string length $name]
	}
    }
    set maxl [expr {$maxl + [string length $a] + 2}]
    foreach name [lsort [array names array $pattern]] {
	set nameString [format %s(%s) $a $name]
	puts stdout [format "%-*s = %s" $maxl $nameString $array($name)]
    }
}
package require opt 0.4.1

namespace eval ::safe {
    namespace export interpCreate interpInit interpConfigure interpDelete interpAddToAccessPath interpFindInAccessPath setLogCmd
    set temp [::tcl::OptKeyRegister {
{-accessPath -list {} "access path for the slave"}
{-noStatics "prevent loading of statically linked pkgs"}
{-statics true "loading of statically linked pkgs"}
{-nestedLoadOk "allow nested loading"}
{-nested false "nested loading"}
{-deleteHook -script {} "delete hook"}
}]
    ::tcl::OptKeyRegister {
{?slave? -name {} "name of the slave (optional)"}
} ::safe::interpCreate
    lappend ::tcl::OptDesc(::safe::interpCreate) $::tcl::OptDesc($temp)
    ::tcl::OptKeyRegister {
{slave -name {} "name of the slave"}
} ::safe::interpIC
    lappend ::tcl::OptDesc(::safe::interpIC) $::tcl::OptDesc($temp)
    ::tcl::OptKeyDelete $temp
    proc InterpStatics {} {
	foreach v {Args statics noStatics} {
	    upvar $v $v
	}
	set flag [::tcl::OptProcArgGiven -noStatics]

	if {$flag &&($noStatics == $statics) &&([::tcl::OptProcArgGiven -statics])} then {
	    return -code error "conflicting values given for -statics and -noStatics"
	}
	if {$flag} then {
	    return [expr {!$noStatics}]
	} else {
	    return $statics
	}
    }
    proc InterpNested {} {
	foreach v {Args nested nestedLoadOk} {
	    upvar $v $v
	}
	set flag [::tcl::OptProcArgGiven -nestedLoadOk]

	if {$flag &&($nestedLoadOk != $nested) &&([::tcl::OptProcArgGiven -nested])} then {
	    return -code error "conflicting values given for -nested and -nestedLoadOk"
	}
	if {$flag} then {
	    return $nestedLoadOk
	} else {
	    return $nested
	}
    }
    proc interpCreate {args} {
	set Args [::tcl::OptKeyParse ::safe::interpCreate $args]
	InterpCreate $slave $accessPath [InterpStatics] [InterpNested] $deleteHook
    }
    proc interpInit {args} {
	set Args [::tcl::OptKeyParse ::safe::interpIC $args]
	if {![::interp exists $slave]} then {
	    return -code error "\"$slave\" is not an interpreter"
	}
	InterpInit $slave $accessPath [InterpStatics] [InterpNested] $deleteHook

    }
    proc CheckInterp {slave} {
	if {![IsInterp $slave]} then {
	    return -code error "\"$slave\" is not an interpreter managed by ::safe::"
	}
    }
    proc interpConfigure {args} {
	switch [llength $args] {
	1 {
		set Args [::tcl::OptKeyParse ::safe::interpIC $args]
		CheckInterp $slave
		set res {}
		lappend res [list -accessPath [Set [PathListName $slave]]]
		lappend res [list -statics [Set [StaticsOkName $slave]]]
		lappend res [list -nested [Set [NestedOkName $slave]]]
		lappend res [list -deleteHook [Set [DeleteHookName $slave]]]
		join $res
	    }
	2 {
		::tcl::Lassign $args slave arg
		set desc [lindex [::tcl::OptKeyGetDesc ::safe::interpIC] 2]
		set hits [::tcl::OptHits desc $arg]
		if {$hits > 1} then {
		    return -code error [::tcl::OptAmbigous $desc $arg]
		} elseif {$hits == 0} {
		    return -code error [::tcl::OptFlagUsage $desc $arg]
		}
		CheckInterp $slave
		set item [::tcl::OptCurDesc $desc]
		set name [::tcl::OptName $item]
		switch -exact -- $name {
		-accessPath {
			return [list -accessPath [Set [PathListName $slave]]]
		    }
		-statics {
			return [list -statics [Set [StaticsOkName $slave]]]
		    }
		-nested {
			return [list -nested [Set [NestedOkName $slave]]]
		    }
		-deleteHook {
			return [list -deleteHook [Set [DeleteHookName $slave]]]
		    }
		-noStatics {
			return -code error "ambigous query (get or set -noStatics ?) use -statics instead"
		    }
		-nestedLoadOk {
			return -code error "ambigous query (get or set -nestedLoadOk ?) use -nested instead"
		    }
		default {
			return -code error "unknown flag $name (bug)"
		    }
		}
	    }
	default {
		set Args [::tcl::OptKeyParse ::safe::interpIC $args]
		CheckInterp $slave
		if {![::tcl::OptProcArgGiven -accessPath]} then {
		    set doreset 1
		    set accessPath [Set [PathListName $slave]]
		} else {
		    set doreset 0
		}
		if {(![::tcl::OptProcArgGiven -statics]) &&(![::tcl::OptProcArgGiven -noStatics])} then {
		    set statics [Set [StaticsOkName $slave]]
		} else {
		    set statics [InterpStatics]
		}
		if {([::tcl::OptProcArgGiven -nested]) ||([::tcl::OptProcArgGiven -nestedLoadOk])} then {
		    set nested [InterpNested]
		} else {
		    set nested [Set [NestedOkName $slave]]
		}
		if {![::tcl::OptProcArgGiven -deleteHook]} then {
		    set deleteHook [Set [DeleteHookName $slave]]
		}
		InterpSetConfig $slave $accessPath $statics $nested $deleteHook
		if {$doreset} then {
		    if {[catch {::interp eval $slave {auto_reset}} msg]} then {
			Log $slave "auto_reset failed: $msg"
		    } else {
			Log $slave "successful auto_reset" NOTICE
		    }
		}
	    }
	}
    }
    proc ::safe::InterpCreate {slave access_path staticsok nestedok deletehook} {
	if {[string compare "" $slave]} then {
	    ::interp create -safe $slave
	} else {
	    set slave [::interp create -safe]
	}
	Log $slave "Created" NOTICE
	InterpInit $slave $access_path $staticsok $nestedok $deletehook
    }
    proc ::safe::InterpSetConfig {slave access_path staticsok nestedok deletehook} {
	if {[string equal "" $access_path]} then {
	    set access_path [uplevel #0 set auto_path]
	    set where [lsearch -exact $access_path [info library]]
	    if {$where == -1} then {
		set access_path [concat [list [info library]] $access_path]
		Log $slave "tcl_library was not in auto_path, added it to slave's access_path" NOTICE
	    } elseif {$where != 0} {
		set access_path [concat [list [info library]] [lreplace $access_path $where $where]]
		Log $slave "tcl_libray was not in first in auto_path, moved it to front of slave's access_path" NOTICE
	    }
	    set access_path [AddSubDirs $access_path]
	}
	Log $slave "Setting accessPath=($access_path) staticsok=$staticsok nestedok=$nestedok deletehook=($deletehook)" NOTICE
	set nname [PathNumberName $slave]
	if {[Exists $nname]} then {
	    set n [Set $nname]
	    for {set i 0} {$i<$n} {incr i} {
		Unset [PathToken $i $slave]
	    }
	}
	set slave_auto_path {}
	set i 0
	foreach dir $access_path {
	    Set [PathToken $i $slave] $dir
	    lappend slave_auto_path "\$[PathToken $i]"
	    incr i
	}
	Set $nname $i
	Set [PathListName $slave] $access_path
	Set [VirtualPathListName $slave] $slave_auto_path
	Set [StaticsOkName $slave] $staticsok
	Set [NestedOkName $slave] $nestedok
	Set [DeleteHookName $slave] $deletehook
	SyncAccessPath $slave
    }
    proc ::safe::interpFindInAccessPath {slave path} {
	set access_path [GetAccessPath $slave]
	set where [lsearch -exact $access_path $path]
	if {$where == -1} then {
	    return -code error "$path not found in access path $access_path"
	}
	return "\$[PathToken $where]"
    }
    proc ::safe::interpAddToAccessPath {slave path} {
	if {![catch {interpFindInAccessPath $slave $path} res]} then {
	    return $res
	}
	set nname [PathNumberName $slave]
	set n [Set $nname]
	Set [PathToken $n $slave] $path
	set token "\$[PathToken $n]"
	Lappend [VirtualPathListName $slave] $token
	Lappend [PathListName $slave] $path
	Set $nname [expr {$n+1}]
	SyncAccessPath $slave
	return $token
    }
    proc ::safe::InterpInit {slave access_path staticsok nestedok deletehook} {
	InterpSetConfig $slave $access_path $staticsok $nestedok $deletehook
	::interp alias $slave source {} [namespace current]::AliasSource $slave
	::interp alias $slave load {} [namespace current]::AliasLoad $slave
	::interp alias $slave encoding {} [namespace current]::AliasEncoding $slave
	AliasSubset $slave file file dir.* join root.* ext.* tail path.* split
	::interp alias $slave exit {} [namespace current]::interpDelete $slave
	if {[catch {::interp eval $slave {source [file join $tcl_library init.tcl]}} msg]} then {
	    Log $slave "can't source init.tcl ($msg)"
	    error "can't source init.tcl into slave $slave ($msg)"
	}
	return $slave
    }
    proc AddSubDirs {pathList} {
	set res {}
	foreach dir $pathList {
	    if {[file isdirectory $dir]} then {
		if {[lsearch -exact $res $dir]<0} then {
		    lappend res $dir
		}
		foreach sub [glob -nocomplain -- [file join $dir *]] {
		    if {([file isdirectory $sub]) &&([lsearch -exact $res $sub]<0)} then {
			lappend res $sub
		    }
		}
	    }
	}
	return $res
    }
    proc ::safe::interpDelete {slave} {
	Log $slave "About to delete" NOTICE
	set hookname [DeleteHookName $slave]
	if {[Exists $hookname]} then {
	    set hook [Set $hookname]
	    if {![::tcl::Lempty $hook]} then {
		Unset $hookname
		if {[catch {eval $hook [list $slave]} err]} then {
		    Log $slave "Delete hook error ($err)"
		}
	    }
	}
	set statename [InterpStateName $slave]
	if {[Exists $statename]} then {
	    Unset $statename
	}
	if {[::interp exists $slave]} then {
	    ::interp delete $slave
	    Log $slave "Deleted" NOTICE
	}
	return
    }
    proc ::safe::setLogCmd {args} {
	variable Log
	if {[llength $args] == 0} then {
	    return $Log
	} else {
	    if {[llength $args] == 1} then {
		set Log [lindex $args 0]
	    } else {
		set Log $args
	    }
	}
    }
    variable Log {}
    proc SyncAccessPath {slave} {
	set slave_auto_path [Set [VirtualPathListName $slave]]
	::interp eval $slave [list set auto_path $slave_auto_path]
	Log $slave "auto_path in $slave has been set to $slave_auto_path" NOTICE
	::interp eval $slave [list set tcl_library [lindex $slave_auto_path 0]]
    }
    proc InterpStateName {slave} {
	return "S$slave"
    }
    proc IsInterp {slave} {
	expr {[Exists [InterpStateName $slave]] && [::interp exists $slave]}
    }
    proc PathToken {n {slave ""}} {
	if {[string compare "" $slave]} then {
	    return "[InterpStateName $slave](access_path,$n)"
	} else {
	    return "p(:$n:)"
	}
    }
    proc PathListName {slave} {
	return "[InterpStateName $slave](access_path)"
    }
    proc VirtualPathListName {slave} {
	return "[InterpStateName $slave](access_path_slave)"
    }
    proc PathNumberName {slave} {
	return "[InterpStateName $slave](access_path,n)"
    }
    proc StaticsOkName {slave} {
	return "[InterpStateName $slave](staticsok)"
    }
    proc NestedOkName {slave} {
	return "[InterpStateName $slave](nestedok)"
    }
    proc Toplevel {args} {
	namespace eval [namespace current] $args
    }
    proc Set {args} {
	eval Toplevel set $args
    }
    proc Lappend {args} {
	eval Toplevel lappend $args
    }
    proc Unset {args} {
	eval Toplevel unset $args
    }
    proc Exists {varname} {
	Toplevel info exists $varname
    }
    proc GetAccessPath {slave} {
	Set [PathListName $slave]
    }
    proc StaticsOk {slave} {
	Set [StaticsOkName $slave]
    }
    proc NestedOk {slave} {
	Set [NestedOkName $slave]
    }
    proc DeleteHookName {slave} {
	return [InterpStateName $slave](cleanupHook)
    }
    proc TranslatePath {slave path} {
	if {[regexp {(::)|(\.\.)} $path]} then {
	    error "invalid characters in path $path"
	}
	set n [expr {[Set [PathNumberName $slave]]-1}]
	for {} {$n>=0} {incr n -1} {
	    set [PathToken $n] [Set [PathToken $n $slave]]
	}
	subst -nobackslashes -nocommands $path
    }
    proc Log {slave msg {type ERROR}} {
	variable Log
	if {[info exists Log] && [llength $Log]} then {
	    eval $Log [list "$type for slave $slave : $msg"]
	}
    }
    proc CheckFileName {slave file} {
	set ftail [file tail $file]
	if {[string length $ftail]>14} then {
	    error "$ftail: filename too long"
	}
	if {[regexp {\..*\.} $ftail]} then {
	    error "$ftail: more than one dot is forbidden"
	}
	if {[string compare $ftail "tclIndex"] && [string compare -nocase [file extension $ftail] ".tcl"]} then {
	    error "$ftail: must be a *.tcl or tclIndex"
	}
	if {![file exists $file]} then {
	    error "no such file or directory"
	}
	if {![file readable $file]} then {
	    error "not readable"
	}
    }
    proc AliasSource {slave args} {
	set argc [llength $args]
	if {$argc != 1} then {
	    set msg "wrong # args: should be \"source fileName\""
	    Log $slave "$msg ($args)"
	    return -code error $msg
	}
	set file [lindex $args 0]
	if {[catch {set file [TranslatePath $slave $file]} msg]} then {
	    Log $slave $msg
	    return -code error "permission denied"
	}
	if {[catch {FileInAccessPath $slave $file} msg]} then {
	    Log $slave $msg
	    return -code error "permission denied"
	}
	if {[catch {CheckFileName $slave $file} msg]} then {
	    Log $slave "$file:$msg"
	    return -code error $msg
	}
	if {[catch {::interp invokehidden $slave source $file} msg]} then {
	    Log $slave $msg
	    return -code error "script error"
	}
	return $msg
    }
    proc AliasLoad {slave file args} {
	set argc [llength $args]
	if {$argc > 2} then {
	    set msg "load error: too many arguments"
	    Log $slave "$msg ($argc) {$file $args}"
	    return -code error $msg
	}
	set package [lindex $args 0]
	set target [lindex $args 1]
	if {[string length $target]} then {
	    if {![NestedOk $slave]} then {
		Log $slave "loading to a sub interp (nestedok) disabled (trying to load $package to $target)"
		return -code error "permission denied (nested load)"
	    }
	}
	if {[string length $file] == 0} then {
	    if {[string length $package] == 0} then {
		set msg "load error: empty filename and no package name"
		Log $slave $msg
		return -code error $msg
	    }
	    if {![StaticsOk $slave]} then {
		Log $slave "static packages loading disabled (trying to load $package to $target)"
		return -code error "permission denied (static package)"
	    }
	} else {
	    if {[catch {set file [TranslatePath $slave $file]} msg]} then {
		Log $slave $msg
		return -code error "permission denied"
	    }
	    if {[catch {FileInAccessPath $slave $file} msg]} then {
		Log $slave $msg
		return -code error "permission denied (path)"
	    }
	}
	if {[catch {::interp invokehidden $slave load $file $package $target} msg]} then {
	    Log $slave $msg
	    return -code error $msg
	}
	return $msg
    }
    proc FileInAccessPath {slave file} {
	set access_path [GetAccessPath $slave]
	if {[file isdirectory $file]} then {
	    error "\"$file\": is a directory"
	}
	set parent [file dirname $file]
	if {[lsearch -exact $access_path $parent] == -1} then {
	    error "\"$file\": not in access_path"
	}
    }
    proc Subset {slave command okpat args} {
	set subcommand [lindex $args 0]
	if {[regexp $okpat $subcommand]} then {
	    return [eval {$command $subcommand} [lrange $args 1 end]]
	}
	set msg "not allowed to invoke subcommand $subcommand of $command"
	Log $slave $msg
	error $msg
    }
    proc AliasSubset {slave alias target args} {
	set pat ^(
	set sep ""
	foreach sub $args {
	    append pat $sep$sub
	    set sep |
	}
	append pat )\$
	::interp alias $slave $alias {} [namespace current]::Subset $slave $target $pat
    }
    proc AliasEncoding {slave args} {
	set argc [llength $args]
	set okpat "^(name.*|convert.*)\$"
	set subcommand [lindex $args 0]
	if {[regexp $okpat $subcommand]} then {
	    return [eval ::interp invokehidden $slave encoding $subcommand [lrange $args 1 end]]
	}
	if {[string match $subcommand system]} then {
	    if {$argc == 1} then {
		if {[catch {::interp invokehidden $slave encoding system} msg]} then {
		    Log $slave $msg
		    return -code error "script error"
		}
	    } else {
		set msg "wrong # args: should be \"encoding system\""
		Log $slave $msg
		error $msg
	    }
	} else {
	    set msg "wrong # args: should be \"encoding option ?arg ...?\""
	    Log $slave $msg
	    error $msg
	}
	return $msg
    }
}
# Tcl autoload index file, version 2.0
# This file is generated by the "auto_mkindex" command
# and sourced to set up indexing information for one or
# more commands.  Typically each line is a command that
# sets an element in the auto_index array, where the
# element name is the name of a command and the value is
# a script that loads the command.

set auto_index(auto_reset) [list source [file join $dir auto.tcl]]
set auto_index(tcl_findLibrary) [list source [file join $dir auto.tcl]]
set auto_index(auto_mkindex) [list source [file join $dir auto.tcl]]
set auto_index(auto_mkindex_old) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::init) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::cleanup) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::mkindex) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::hook) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::slavehook) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::command) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::commandInit) [list source [file join $dir auto.tcl]]
set auto_index(::auto_mkindex_parser::fullname) [list source [file join $dir auto.tcl]]
set auto_index(history) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistAdd) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistKeep) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistClear) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistInfo) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistRedo) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistIndex) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistEvent) [list source [file join $dir history.tcl]]
set auto_index(::tcl::HistChange) [list source [file join $dir history.tcl]]
set auto_index(tclLdAout) [list source [file join $dir ldAout.tcl]]
set auto_index(pkg_compareExtension) [list source [file join $dir package.tcl]]
set auto_index(pkg_mkIndex) [list source [file join $dir package.tcl]]
set auto_index(tclPkgSetup) [list source [file join $dir package.tcl]]
set auto_index(tclMacPkgSearch) [list source [file join $dir package.tcl]]
set auto_index(tclPkgUnknown) [list source [file join $dir package.tcl]]
set auto_index(::pkg::create) [list source [file join $dir package.tcl]]
set auto_index(parray) [list source [file join $dir parray.tcl]]
set auto_index(::safe::InterpStatics) [list source [file join $dir safe.tcl]]
set auto_index(::safe::InterpNested) [list source [file join $dir safe.tcl]]
set auto_index(::safe::interpCreate) [list source [file join $dir safe.tcl]]
set auto_index(::safe::interpInit) [list source [file join $dir safe.tcl]]
set auto_index(::safe::CheckInterp) [list source [file join $dir safe.tcl]]
set auto_index(::safe::interpConfigure) [list source [file join $dir safe.tcl]]
set auto_index(::safe::InterpCreate) [list source [file join $dir safe.tcl]]
set auto_index(::safe::InterpSetConfig) [list source [file join $dir safe.tcl]]
set auto_index(::safe::interpFindInAccessPath) [list source [file join $dir safe.tcl]]
set auto_index(::safe::interpAddToAccessPath) [list source [file join $dir safe.tcl]]
set auto_index(::safe::InterpInit) [list source [file join $dir safe.tcl]]
set auto_index(::safe::AddSubDirs) [list source [file join $dir safe.tcl]]
set auto_index(::safe::interpDelete) [list source [file join $dir safe.tcl]]
set auto_index(::safe::setLogCmd) [list source [file join $dir safe.tcl]]
set auto_index(::safe::SyncAccessPath) [list source [file join $dir safe.tcl]]
set auto_index(::safe::InterpStateName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::IsInterp) [list source [file join $dir safe.tcl]]
set auto_index(::safe::PathToken) [list source [file join $dir safe.tcl]]
set auto_index(::safe::PathListName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::VirtualPathListName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::PathNumberName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::StaticsOkName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::NestedOkName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Toplevel) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Set) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Lappend) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Unset) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Exists) [list source [file join $dir safe.tcl]]
set auto_index(::safe::GetAccessPath) [list source [file join $dir safe.tcl]]
set auto_index(::safe::StaticsOk) [list source [file join $dir safe.tcl]]
set auto_index(::safe::NestedOk) [list source [file join $dir safe.tcl]]
set auto_index(::safe::DeleteHookName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::TranslatePath) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Log) [list source [file join $dir safe.tcl]]
set auto_index(::safe::CheckFileName) [list source [file join $dir safe.tcl]]
set auto_index(::safe::AliasSource) [list source [file join $dir safe.tcl]]
set auto_index(::safe::AliasLoad) [list source [file join $dir safe.tcl]]
set auto_index(::safe::FileInAccessPath) [list source [file join $dir safe.tcl]]
set auto_index(::safe::Subset) [list source [file join $dir safe.tcl]]
set auto_index(::safe::AliasSubset) [list source [file join $dir safe.tcl]]
set auto_index(tcl_wordBreakAfter) [list source [file join $dir word.tcl]]
set auto_index(tcl_wordBreakBefore) [list source [file join $dir word.tcl]]
set auto_index(tcl_endOfWord) [list source [file join $dir word.tcl]]
set auto_index(tcl_startOfNextWord) [list source [file join $dir word.tcl]]
set auto_index(tcl_startOfPreviousWord) [list source [file join $dir word.tcl]]
if {[string equal $tcl_platform(platform) "windows"]} then {
    set tcl_wordchars "\\S"
    set tcl_nonwordchars "\\s"
} else {
    set tcl_wordchars "\\w"
    set tcl_nonwordchars "\\W"
}
proc tcl_wordBreakAfter {str start} {
    global tcl_nonwordchars tcl_wordchars
    set str [string range $str $start end]
    if {[regexp -indices "$tcl_wordchars$tcl_nonwordchars|$tcl_nonwordchars$tcl_wordchars" $str result]} then {
	return [expr {[lindex $result 1] + $start}]
    }
    return -1
}
proc tcl_wordBreakBefore {str start} {
    global tcl_nonwordchars tcl_wordchars
    if {[string equal $start end]} then {
	set start [string length $str]
    }
    if {[regexp -indices "^.*($tcl_wordchars$tcl_nonwordchars|$tcl_nonwordchars$tcl_wordchars)" [string range $str 0 $start] result]} then {
	return [lindex $result 1]
    }
    return -1
}
proc tcl_endOfWord {str start} {
    global tcl_nonwordchars tcl_wordchars
    if {[regexp -indices "$tcl_nonwordchars*$tcl_wordchars+$tcl_nonwordchars" [string range $str $start end] result]} then {
	return [expr {[lindex $result 1] + $start}]
    }
    return -1
}
proc tcl_startOfNextWord {str start} {
    global tcl_nonwordchars tcl_wordchars
    if {[regexp -indices "$tcl_wordchars*$tcl_nonwordchars+$tcl_wordchars" [string range $str $start end] result]} then {
	return [expr {[lindex $result 1] + $start}]
    }
    return -1
}
proc tcl_startOfPreviousWord {str start} {
    global tcl_nonwordchars tcl_wordchars
    if {[string equal $start end]} then {
	set start [string length $str]
    }
    if {[regexp -indices "$tcl_nonwordchars*($tcl_wordchars+)$tcl_nonwordchars*\$" [string range $str 0 [expr {$start - 1}]] result word]} then {
	return [lindex $word 0]
    }
    return -1
}
proc bgerror err {
    global errorInfo tcl_platform
    set info $errorInfo

    set ret [catch {tkerror $err} msg]

    if {$ret != 1} then {
	return -code $ret $msg
    }
    if {$tcl_platform(platform) == "macintosh"} then {
	set ok Ok
    } else {
	set ok OK
    }
    set button [tk_dialog .bgerrorDialog "Error in Tcl Script" "Error: $err" error 0 $ok "Skip Messages" "Stack Trace"]
    if {$button == 0} then {
	return
    } elseif {$button == 1} {
	return -code break
    }
    set w .bgerrorTrace
    catch {destroy $w}
    toplevel $w -class ErrorTrace
    wm minsize $w 1 1
    wm title $w "Stack Trace for Error"
    wm iconname $w "Stack Trace"
    button $w.ok -text OK -command "destroy $w" -default active
    if {![string compare $tcl_platform(platform) "macintosh"]} then {
	text $w.text -relief flat -bd 2 -highlightthickness 0 -setgrid true -yscrollcommand "$w.scroll set" -width 60 -height 20
    } else {
	text $w.text -relief sunken -bd 2 -yscrollcommand "$w.scroll set" -setgrid true -width 60 -height 20
    }
    scrollbar $w.scroll -relief sunken -command "$w.text yview"
    pack $w.ok -side bottom -padx 3m -pady 2m
    pack $w.scroll -side right -fill y
    pack $w.text -side left -expand yes -fill both
    $w.text insert 0.0 $info
    $w.text mark set insert 0.0
    bind $w <Return> "destroy $w"
    bind $w.text <Return> "destroy $w; break"
    wm withdraw $w
    update idletasks
    set x [expr {[winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 - [winfo vrootx [winfo parent $w]]}]
    set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 - [winfo vrooty [winfo parent $w]]}]
    wm geom $w +$x+$y
    wm deiconify $w
    if {[string compare [grab current .] ""]} then {
	grab release [grab current .]
    }
}
if {[string match "macintosh" $tcl_platform(platform)]} then {
    bind Radiobutton <Enter> {
	tkButtonEnter %W
    }
    bind Radiobutton <1> {
	tkButtonDown %W
    }
    bind Radiobutton <ButtonRelease-1> {
	tkButtonUp %W
    }
    bind Checkbutton <Enter> {
	tkButtonEnter %W
    }
    bind Checkbutton <1> {
	tkButtonDown %W
    }
    bind Checkbutton <ButtonRelease-1> {
	tkButtonUp %W
    }
}
if {[string match "windows" $tcl_platform(platform)]} then {
    bind Checkbutton <equal> {
	tkCheckRadioInvoke %W select
    }
    bind Checkbutton <plus> {
	tkCheckRadioInvoke %W select
    }
    bind Checkbutton <minus> {
	tkCheckRadioInvoke %W deselect
    }
    bind Checkbutton <1> {
	tkCheckRadioDown %W
    }
    bind Checkbutton <ButtonRelease-1> {
	tkButtonUp %W
    }
    bind Checkbutton <Enter> {
	tkCheckRadioEnter %W
    }
    bind Radiobutton <1> {
	tkCheckRadioDown %W
    }
    bind Radiobutton <ButtonRelease-1> {
	tkButtonUp %W
    }
    bind Radiobutton <Enter> {
	tkCheckRadioEnter %W
    }
}
if {[string match "unix" $tcl_platform(platform)]} then {
    bind Checkbutton <Return> {
	if {!$tk_strictMotif} then {
	    tkCheckRadioInvoke %W
	}
    }
    bind Radiobutton <Return> {
	if {!$tk_strictMotif} then {
	    tkCheckRadioInvoke %W
	}
    }
    bind Checkbutton <1> {
	tkCheckRadioInvoke %W
    }
    bind Radiobutton <1> {
	tkCheckRadioInvoke %W
    }
    bind Checkbutton <Enter> {
	tkButtonEnter %W
    }
    bind Radiobutton <Enter> {
	tkButtonEnter %W
    }
}
bind Button <space> {
    tkButtonInvoke %W
}
bind Checkbutton <space> {
    tkCheckRadioInvoke %W
}
bind Radiobutton <space> {
    tkCheckRadioInvoke %W
}
bind Button <FocusIn> {}
bind Button <Enter> {
    tkButtonEnter %W
}
bind Button <Leave> {
    tkButtonLeave %W
}
bind Button <1> {
    tkButtonDown %W
}
bind Button <ButtonRelease-1> {
    tkButtonUp %W
}
bind Checkbutton <FocusIn> {}
bind Checkbutton <Leave> {
    tkButtonLeave %W
}
bind Radiobutton <FocusIn> {}
bind Radiobutton <Leave> {
    tkButtonLeave %W
}
if {[string match "windows" $tcl_platform(platform)]} then {
    proc tkButtonEnter w {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"] && [string equal $tkPriv(buttonWindow) $w]} then {
	    $w configure -state active -relief sunken
	}
	set tkPriv(window) $w
    }
    proc tkButtonLeave w {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"]} then {
	    $w configure -state normal
	}
	if {[string equal $tkPriv(buttonWindow) $w]} then {
	    $w configure -relief $tkPriv(relief)
	}
	set tkPriv(window) ""
    }
    proc tkCheckRadioEnter w {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"] && [string equal $tkPriv(buttonWindow) $w]} then {
	    $w configure -state active
	}
	set tkPriv(window) $w
    }
    proc tkButtonDown w {
	global tkPriv
	set tkPriv(relief) [$w cget -relief]
	if {[string compare [$w cget -state] "disabled"]} then {
	    set tkPriv(buttonWindow) $w
	    $w configure -relief sunken -state active
	}
    }
    proc tkCheckRadioDown w {
	global tkPriv
	set tkPriv(relief) [$w cget -relief]
	if {[string compare [$w cget -state] "disabled"]} then {
	    set tkPriv(buttonWindow) $w
	    $w configure -state active
	}
    }
    proc tkButtonUp w {
	global tkPriv
	if {[string equal $tkPriv(buttonWindow) $w]} then {
	    set tkPriv(buttonWindow) ""
	    $w configure -relief $tkPriv(relief)
	    if {[string equal $tkPriv(window) $w] && [string compare [$w cget -state] "disabled"]} then {
		$w configure -state normal
		uplevel #0 [list $w invoke]
	    }
	}
    }
}
if {[string match "unix" $tcl_platform(platform)]} then {
    proc tkButtonEnter {w} {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"]} then {
	    $w configure -state active
	    if {[string equal $tkPriv(buttonWindow) $w]} then {
		$w configure -state active -relief sunken
	    }
	}
	set tkPriv(window) $w
    }
    proc tkButtonLeave w {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"]} then {
	    $w configure -state normal
	}
	if {[string equal $tkPriv(buttonWindow) $w]} then {
	    $w configure -relief $tkPriv(relief)
	}
	set tkPriv(window) ""
    }
    proc tkButtonDown w {
	global tkPriv
	set tkPriv(relief) [$w cget -relief]
	if {[string compare [$w cget -state] "disabled"]} then {
	    set tkPriv(buttonWindow) $w
	    $w configure -relief sunken
	}
    }
    proc tkButtonUp w {
	global tkPriv
	if {[string equal $w $tkPriv(buttonWindow)]} then {
	    set tkPriv(buttonWindow) ""
	    $w configure -relief $tkPriv(relief)
	    if {[string equal $w $tkPriv(window)] && [string compare [$w cget -state] "disabled"]} then {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}
if {[string match "macintosh" $tcl_platform(platform)]} then {
    proc tkButtonEnter {w} {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"]} then {
	    if {[string equal $w $tkPriv(buttonWindow)]} then {
		$w configure -state active
	    }
	}
	set tkPriv(window) $w
    }
    proc tkButtonLeave w {
	global tkPriv
	if {[string equal $w $tkPriv(buttonWindow)]} then {
	    $w configure -state normal
	}
	set tkPriv(window) ""
    }
    proc tkButtonDown w {
	global tkPriv
	if {[string compare [$w cget -state] "disabled"]} then {
	    set tkPriv(buttonWindow) $w
	    $w configure -state active
	}
    }
    proc tkButtonUp w {
	global tkPriv
	if {[string equal $w $tkPriv(buttonWindow)]} then {
	    $w configure -state normal
	    set tkPriv(buttonWindow) ""
	    if {[string equal $w $tkPriv(window)] && [string compare [$w cget -state] "disabled"]} then {
		uplevel #0 [list $w invoke]
	    }
	}
    }
}
proc tkButtonInvoke w {
    if {[string compare [$w cget -state] "disabled"]} then {
	set oldRelief [$w cget -relief]
	set oldState [$w cget -state]
	$w configure -state active -relief sunken
	update idletasks
	after 100
	$w configure -state $oldState -relief $oldRelief
	uplevel #0 [list $w invoke]
    }
}
proc tkCheckRadioInvoke {w {cmd invoke}} {
    if {[string compare [$w cget -state] "disabled"]} then {
	uplevel #0 [list $w $cmd]
    }
}
proc tkColorDialog {args} {
    global tkPriv
    set w .__tk__color
    upvar #0 $w data
    set data(lines,red,start) 0
    set data(lines,red,last) -1
    set data(lines,green,start) 0
    set data(lines,green,last) -1
    set data(lines,blue,start) 0
    set data(lines,blue,last) -1
    set data(NUM_COLORBARS) 8
    set data(BARS_WIDTH) 128
    set data(PLGN_HEIGHT) 10
    set data(PLGN_WIDTH) 10
    tkColorDialog_Config $w $args
    tkColorDialog_InitValues $w
    set sc [winfo screen $data(-parent)]
    set winExists [winfo exists $w]
    if {!$winExists || [string compare $sc [winfo screen $w]]} then {
	if {$winExists} then {
	    destroy $w
	}
	toplevel $w -class tkColorDialog -screen $sc
	tkColorDialog_BuildDialog $w
    }
    wm transient $w $data(-parent)
    ::tk::PlaceWindow $w widget $data(-parent)
    wm title $w $data(-title)
    ::tk::SetFocusGrab $w $data(okBtn)
    vwait tkPriv(selectColor)
    ::tk::RestoreFocusGrab $w $data(okBtn)
    unset data
    return $tkPriv(selectColor)
}
proc tkColorDialog_InitValues {w} {
    upvar #0 $w data
    set data(intensityIncr) [expr {256 / $data(NUM_COLORBARS)}]
    set data(colorbarWidth) [expr {$data(BARS_WIDTH) / $data(NUM_COLORBARS)}]
    set data(indent) [expr {$data(PLGN_WIDTH) / 2}]
    set data(colorPad) 2
    set data(selPad) [expr {$data(PLGN_WIDTH) / 2}]
    set data(minX) $data(indent)
    set data(maxX) [expr {$data(BARS_WIDTH) + $data(indent)-1}]
    set data(canvasWidth) [expr {$data(BARS_WIDTH) + $data(PLGN_WIDTH)}]
    set data(selection) $data(-initialcolor)
    set data(finalColor) $data(-initialcolor)
    set rgb [winfo rgb . $data(selection)]
    set data(red,intensity) [expr {[lindex $rgb 0]/0x100}]
    set data(green,intensity) [expr {[lindex $rgb 1]/0x100}]
    set data(blue,intensity) [expr {[lindex $rgb 2]/0x100}]
}
proc tkColorDialog_Config {w argList} {
    global tkPriv
    upvar #0 $w data
    if {[info exists tkPriv(selectColor)] && [string compare $tkPriv(selectColor) ""]} then {
	set defaultColor $tkPriv(selectColor)
    } else {
	set defaultColor [. cget -background]
    }
    set specs [list [list -initialcolor "" "" $defaultColor] [list -parent "" "" "."] [list -title "" "" "Color"]]
    tclParseConfigSpec $w $specs "" $argList
    if {[string equal $data(-title) ""]} then {
	set data(-title) " "
    }
    if {[catch {winfo rgb . $data(-initialcolor)} err]} then {
	error $err
    }
    if {![winfo exists $data(-parent)]} then {
	error "bad window path name \"$data(-parent)\""
    }
}
proc tkColorDialog_BuildDialog {w} {
    upvar #0 $w data
    set topFrame [frame $w.top -relief raised -bd 1]
    set stripsFrame [frame $topFrame.colorStrip]
    foreach c {Red Green Blue} {
	set color [string tolower $c]
	set f [frame $stripsFrame.$color]
	set box [frame $f.box]
	label $box.label -text $c: -width 6 -under 0 -anchor ne
	entry $box.entry -textvariable [format %s $w]($color,intensity) -width 4
	pack $box.label -side left -fill y -padx 2 -pady 3
	pack $box.entry -side left -anchor n -pady 0
	pack $box -side left -fill both
	set height [expr {[winfo reqheight $box.entry] - 2*([$box.entry cget -highlightthickness] + [$box.entry cget -bd])}]
	canvas $f.color -height $height -width $data(BARS_WIDTH) -relief sunken -bd 2
	canvas $f.sel -height $data(PLGN_HEIGHT) -width $data(canvasWidth) -highlightthickness 0
	pack $f.color -expand yes -fill both
	pack $f.sel -expand yes -fill both
	pack $f -side top -fill x -padx 0 -pady 2
	set data($color,entry) $box.entry
	set data($color,col) $f.color
	set data($color,sel) $f.sel
	bind $data($color,col) <Configure> [list tkColorDialog_DrawColorScale $w $color 1]
	bind $data($color,col) <Enter> [list tkColorDialog_EnterColorBar $w $color]
	bind $data($color,col) <Leave> [list tkColorDialog_LeaveColorBar $w $color]
	bind $data($color,sel) <Enter> [list tkColorDialog_EnterColorBar $w $color]
	bind $data($color,sel) <Leave> [list tkColorDialog_LeaveColorBar $w $color]
	bind $box.entry <Return> [list tkColorDialog_HandleRGBEntry $w]
    }
    pack $stripsFrame -side left -fill both -padx 4 -pady 10
    set selFrame [frame $topFrame.sel]
    set lab [label $selFrame.lab -text "Selection:" -under 0 -anchor sw]
    set ent [entry $selFrame.ent -textvariable [format %s $w](selection) -width 16]
    set f1 [frame $selFrame.f1 -relief sunken -bd 2]
    set data(finalCanvas) [frame $f1.demo -bd 0 -width 100 -height 70]
    pack $lab $ent -side top -fill x -padx 4 -pady 2
    pack $f1 -expand yes -anchor nw -fill both -padx 6 -pady 10
    pack $data(finalCanvas) -expand yes -fill both
    bind $ent <Return> [list tkColorDialog_HandleSelEntry $w]
    pack $selFrame -side left -fill none -anchor nw
    pack $topFrame -side top -expand yes -fill both -anchor nw
    set botFrame [frame $w.bot -relief raised -bd 1]
    button $botFrame.ok -text OK -width 8 -under 0 -command [list tkColorDialog_OkCmd $w]
    button $botFrame.cancel -text Cancel -width 8 -under 0 -command [list tkColorDialog_CancelCmd $w]
    set data(okBtn) $botFrame.ok
    set data(cancelBtn) $botFrame.cancel
    pack $botFrame.ok $botFrame.cancel -padx 10 -pady 10 -expand yes -side left
    pack $botFrame -side bottom -fill x
    bind $w <Alt-r> [list focus $data(red,entry)]
    bind $w <Alt-g> [list focus $data(green,entry)]
    bind $w <Alt-b> [list focus $data(blue,entry)]
    bind $w <Alt-s> [list focus $ent]
    bind $w <KeyPress-Escape> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-c> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-o> [list tkButtonInvoke $data(okBtn)]
    wm protocol $w WM_DELETE_WINDOW [list tkColorDialog_CancelCmd $w]
}
proc tkColorDialog_SetRGBValue {w color} {
    upvar #0 $w data
    set data(red,intensity) [lindex $color 0]
    set data(green,intensity) [lindex $color 1]
    set data(blue,intensity) [lindex $color 2]
    tkColorDialog_RedrawColorBars $w all
    foreach color {red green blue} {
	set x [tkColorDialog_RgbToX $w $data($color,intensity)]
	tkColorDialog_MoveSelector $w $data($color,sel) $color $x 0
    }
}
proc tkColorDialog_XToRgb {w x} {
    upvar #0 $w data
    return [expr {($x * $data(intensityIncr)) / $data(colorbarWidth)}]
}
proc tkColorDialog_RgbToX {w color} {
    upvar #0 $w data
    return [expr {($color * $data(colorbarWidth)/ $data(intensityIncr))}]
}
proc tkColorDialog_DrawColorScale {w c {create 0}} {
    global lines
    upvar #0 $w data
    set col $data($c,col)
    set sel $data($c,sel)
    if {$create} then {
	if {$data(lines,$c,last) > $data(lines,$c,start)} then {
	    for {set i $data(lines,$c,start)} {$i <= $data(lines,$c,last)} {incr i} {
		$sel delete $i
	    }
	}
	if {[info exists data($c,index)]} then {
	    $sel delete $data($c,index)
	}
	tkColorDialog_CreateSelector $w $sel $c
	$sel bind $data($c,index) <ButtonPress-1> [list tkColorDialog_StartMove $w $sel $c %x $data(selPad) 1]
	$sel bind $data($c,index) <B1-Motion> [list tkColorDialog_MoveSelector $w $sel $c %x $data(selPad)]
	$sel bind $data($c,index) <ButtonRelease-1> [list tkColorDialog_ReleaseMouse $w $sel $c %x $data(selPad)]
	set height [winfo height $col]
	set data($c,clickRegion) [$sel create rectangle 0 0 $data(canvasWidth) $height -fill {} -outline {}]
	bind $col <ButtonPress-1> [list tkColorDialog_StartMove $w $sel $c %x $data(colorPad)]
	bind $col <B1-Motion> [list tkColorDialog_MoveSelector $w $sel $c %x $data(colorPad)]
	bind $col <ButtonRelease-1> [list tkColorDialog_ReleaseMouse $w $sel $c %x $data(colorPad)]
	$sel bind $data($c,clickRegion) <ButtonPress-1> [list tkColorDialog_StartMove $w $sel $c %x $data(selPad)]
	$sel bind $data($c,clickRegion) <B1-Motion> [list tkColorDialog_MoveSelector $w $sel $c %x $data(selPad)]
	$sel bind $data($c,clickRegion) <ButtonRelease-1> [list tkColorDialog_ReleaseMouse $w $sel $c %x $data(selPad)]
    } else {
	set l $data(lines,$c,start)
    }
    set highlightW [expr {[$col cget -highlightthickness] + [$col cget -bd]}]
    for {set i 0} {$i < $data(NUM_COLORBARS)} {incr i} {
	set intensity [expr {$i * $data(intensityIncr)}]
	set startx [expr {$i * $data(colorbarWidth) + $highlightW}]
	if {[string equal $c "red"]} then {
	    set color [format "#%02x%02x%02x" $intensity $data(green,intensity) $data(blue,intensity)]
	} elseif {[string equal $c "green"]} {
	    set color [format "#%02x%02x%02x" $data(red,intensity) $intensity $data(blue,intensity)]
	} else {
	    set color [format "#%02x%02x%02x" $data(red,intensity) $data(green,intensity) $intensity]
	}
	if {$create} then {
	    set index [$col create rect $startx $highlightW [expr {$startx +$data(colorbarWidth)}] [expr {[winfo height $col] + $highlightW}] -fill $color -outline $color]
	} else {
	    $col itemconfigure $l -fill $color -outline $color
	    incr l
	}
    }
    $sel raise $data($c,index)
    if {$create} then {
	set data(lines,$c,last) $index
	set data(lines,$c,start) [expr {$index - $data(NUM_COLORBARS) + 1}]
    }
    tkColorDialog_RedrawFinalColor $w
}
proc tkColorDialog_CreateSelector {w sel c} {
    upvar #0 $w data
    set data($c,index) [$sel create polygon 0 $data(PLGN_HEIGHT) $data(PLGN_WIDTH) $data(PLGN_HEIGHT) $data(indent) 0]
    set data($c,x) [tkColorDialog_RgbToX $w $data($c,intensity)]
    $sel move $data($c,index) $data($c,x) 0
}
proc tkColorDialog_RedrawFinalColor {w} {
    upvar #0 $w data
    set color [format "#%02x%02x%02x" $data(red,intensity) $data(green,intensity) $data(blue,intensity)]
    $data(finalCanvas) configure -bg $color
    set data(finalColor) $color
    set data(selection) $color
    set data(finalRGB) [list $data(red,intensity) $data(green,intensity) $data(blue,intensity)]
}
proc tkColorDialog_RedrawColorBars {w colorChanged} {
    upvar #0 $w data
    switch $colorChanged {
    red {
	    tkColorDialog_DrawColorScale $w green
	    tkColorDialog_DrawColorScale $w blue
	}
    green {
	    tkColorDialog_DrawColorScale $w red
	    tkColorDialog_DrawColorScale $w blue
	}
    blue {
	    tkColorDialog_DrawColorScale $w red
	    tkColorDialog_DrawColorScale $w green
	}
    default {
	    tkColorDialog_DrawColorScale $w red
	    tkColorDialog_DrawColorScale $w green
	    tkColorDialog_DrawColorScale $w blue
	}
    }
    tkColorDialog_RedrawFinalColor $w
}
proc tkColorDialog_StartMove {w sel color x delta {dontMove 0}} {
    upvar #0 $w data
    if {!$dontMove} then {
	tkColorDialog_MoveSelector $w $sel $color $x $delta
    }
}
proc tkColorDialog_MoveSelector {w sel color x delta} {
    upvar #0 $w data
    incr x -$delta
    if {$x < 0} then {
	set x 0
    } elseif {$x >= $data(BARS_WIDTH)} {
	set x [expr {$data(BARS_WIDTH) - 1}]
    }
    set diff [expr {$x - $data($color,x)}]
    $sel move $data($color,index) $diff 0
    set data($color,x) [expr {$data($color,x) + $diff}]
    return $x
}
proc tkColorDialog_ReleaseMouse {w sel color x delta} {
    upvar #0 $w data
    set x [tkColorDialog_MoveSelector $w $sel $color $x $delta]
    set data($color,intensity) [tkColorDialog_XToRgb $w $x]
    tkColorDialog_RedrawColorBars $w $color
}
proc tkColorDialog_ResizeColorBars {w} {
    upvar #0 $w data
    if {($data(BARS_WIDTH) < $data(NUM_COLORBARS)) ||(($data(BARS_WIDTH) % $data(NUM_COLORBARS)) != 0)} then {
	set data(BARS_WIDTH) $data(NUM_COLORBARS)
    }
    tkColorDialog_InitValues $w
    foreach color {red green blue} {
	$data($color,col) configure -width $data(canvasWidth)
	tkColorDialog_DrawColorScale $w $color 1
    }
}
proc tkColorDialog_HandleSelEntry {w} {
    upvar #0 $w data
    set text [string trim $data(selection)]
    if {[catch {set color [winfo rgb . $text]}]} then {
	set data(selection) $data(finalColor)
	return
    }
    set R [expr {[lindex $color 0]/0x100}]
    set G [expr {[lindex $color 1]/0x100}]
    set B [expr {[lindex $color 2]/0x100}]
    tkColorDialog_SetRGBValue $w "$R $G $B"
    set data(selection) $text
}
proc tkColorDialog_HandleRGBEntry {w} {
    upvar #0 $w data
    foreach c {red green blue} {
	if {[catch {
	    set data($c,intensity) [expr {int($data($c,intensity))}]
	}]} then {
	    set data($c,intensity) 0
	}
	if {$data($c,intensity) < 0} then {
	    set data($c,intensity) 0
	}
	if {$data($c,intensity) > 255} then {
	    set data($c,intensity) 255
	}
    }
    tkColorDialog_SetRGBValue $w "$data(red,intensity) $data(green,intensity)  $data(blue,intensity)"
}
proc tkColorDialog_EnterColorBar {w color} {
    upvar #0 $w data
    $data($color,sel) itemconfig $data($color,index) -fill red
}
proc tkColorDialog_LeaveColorBar {w color} {
    upvar #0 $w data
    $data($color,sel) itemconfig $data($color,index) -fill black
}
proc tkColorDialog_OkCmd {w} {
    global tkPriv
    upvar #0 $w data
    set tkPriv(selectColor) $data(finalColor)
}
proc tkColorDialog_CancelCmd {w} {
    global tkPriv
    set tkPriv(selectColor) ""
}
proc tclParseConfigSpec {w specs flags argList} {
    upvar #0 $w data
    foreach spec $specs {
	if {[llength $spec] < 4} then {
	    error "\"spec\" should contain 5 or 4 elements"
	}
	set cmdsw [lindex $spec 0]
	set cmd($cmdsw) ""
	set rname($cmdsw) [lindex $spec 1]
	set rclass($cmdsw) [lindex $spec 2]
	set def($cmdsw) [lindex $spec 3]
	set verproc($cmdsw) [lindex $spec 4]
    }
    if {[llength $argList] & 1} then {
	set cmdsw [lindex $argList end]
	if {![info exists cmd($cmdsw)]} then {
	    error "bad option \"$cmdsw\": must be [tclListValidFlags cmd]"
	}
	error "value for \"$cmdsw\" missing"
    }
    foreach cmdsw [array names cmd] {
	set data($cmdsw) $def($cmdsw)
    }
    foreach {cmdsw value} $argList {
	if {![info exists cmd($cmdsw)]} then {
	    error "bad option \"$cmdsw\": must be [tclListValidFlags cmd]"
	}
	set data($cmdsw) $value
    }
}
proc tclListValidFlags {v} {
    upvar $v cmd
    set len [llength [array names cmd]]
    set i 1
    set separator ""
    set errormsg ""
    foreach cmdsw [lsort [array names cmd]] {
	append errormsg "$separator$cmdsw"
	incr i
	if {$i == $len} then {
	    set separator ", or "
	} else {
	    set separator ", "
	}
    }
    return $errormsg
}
proc tkFocusGroup_Create {t} {
    global tkPriv
    if {[string compare [winfo toplevel $t] $t]} then {
	error "$t is not a toplevel window"
    }
    if {![info exists tkPriv(fg,$t)]} then {
	set tkPriv(fg,$t) 1
	set tkPriv(focus,$t) ""
	bind $t <FocusIn> [list tkFocusGroup_In $t %W %d]
	bind $t <FocusOut> [list tkFocusGroup_Out $t %W %d]
	bind $t <Destroy> [list tkFocusGroup_Destroy $t %W]
    }
}
proc tkFocusGroup_BindIn {t w cmd} {
    global tkFocusIn tkPriv
    if {![info exists tkPriv(fg,$t)]} then {
	error "focus group \"$t\" doesn't exist"
    }
    set tkFocusIn($t,$w) $cmd
}
proc tkFocusGroup_BindOut {t w cmd} {
    global tkFocusOut tkPriv
    if {![info exists tkPriv(fg,$t)]} then {
	error "focus group \"$t\" doesn't exist"
    }
    set tkFocusOut($t,$w) $cmd
}
proc tkFocusGroup_Destroy {t w} {
    global tkPriv tkFocusIn tkFocusOut
    if {[string equal $t $w]} then {
	unset tkPriv(fg,$t)
	unset tkPriv(focus,$t)
	foreach name [array names tkFocusIn $t,*] {
	    unset tkFocusIn($name)
	}
	foreach name [array names tkFocusOut $t,*] {
	    unset tkFocusOut($name)
	}
    } else {
	if {[info exists tkPriv(focus,$t)] && [string equal $tkPriv(focus,$t) $w]} then {
	    set tkPriv(focus,$t) ""
	}
	catch {
	    unset tkFocusIn($t,$w)
	}
	catch {
	    unset tkFocusOut($t,$w)
	}
    }
}
proc tkFocusGroup_In {t w detail} {
    global tkPriv tkFocusIn
    if {[string compare $detail NotifyNonlinear] && [string compare $detail NotifyNonlinearVirtual]} then {
	return
    }
    if {![info exists tkFocusIn($t,$w)]} then {
	set tkFocusIn($t,$w) ""
	return
    }
    if {![info exists tkPriv(focus,$t)]} then {
	return
    }
    if {[string equal $tkPriv(focus,$t) $w]} then {
	return
    } else {
	set tkPriv(focus,$t) $w
	eval $tkFocusIn($t,$w)
    }
}
proc tkFocusGroup_Out {t w detail} {
    global tkPriv tkFocusOut
    if {[string compare $detail NotifyNonlinear] && [string compare $detail NotifyNonlinearVirtual]} then {
	return
    }
    if {![info exists tkPriv(focus,$t)]} then {
	return
    }
    if {![info exists tkFocusOut($t,$w)]} then {
	return
    } else {
	eval $tkFocusOut($t,$w)
	set tkPriv(focus,$t) ""
    }
}
proc tkFDGetFileTypes {string} {
    foreach t $string {
	if {[llength $t] < 2 || [llength $t] > 3} then {
	    error "bad file type \"$t\", should be \"typeName {extension ?extensions ...?} ?{macType ?macTypes ...?}?\""
	}
	eval lappend [list fileTypes([lindex $t 0])] [lindex $t 1]
    }
    set types {}
    foreach t $string {
	set label [lindex $t 0]
	set exts {}
	if {[info exists hasDoneType($label)]} then {
	    continue
	}
	set name "$label ("
	set sep ""
	foreach ext $fileTypes($label) {
	    if {[string equal $ext ""]} then {
		continue
	    }
	    regsub {^[.]} $ext "*." ext
	    if {![info exists hasGotExt($label,$ext)]} then {
		append name $sep$ext
		lappend exts $ext
		set hasGotExt($label,$ext) 1
	    }
	    set sep ,
	}
	append name ")"
	lappend types [list $name $exts]
	set hasDoneType($label) 1
    }
    return $types
}
proc tkConsoleInit {} {
    global tcl_platform
    if {![consoleinterp eval {set tcl_interactive}]} then {
	wm withdraw .
    }
    if {[string compare $tcl_platform(platform) "macintosh"]} then {
	set mod "Ctrl"
    } else {
	set mod "Cmd"
    }
    menu .menubar
    .menubar add cascade -label File -menu .menubar.file -underline 0
    .menubar add cascade -label Edit -menu .menubar.edit -underline 0
    menu .menubar.file -tearoff 0
    .menubar.file add command -label "Source..." -underline 0 -command tkConsoleSource
    .menubar.file add command -label "Hide Console" -underline 0 -command {wm withdraw .}
    if {[string compare $tcl_platform(platform) "macintosh"]} then {
	.menubar.file add command -label "Exit" -underline 1 -command exit
    } else {
	.menubar.file add command -label "Quit" -command exit -accel Cmd-Q
    }
    menu .menubar.edit -tearoff 0
    .menubar.edit add command -label "Cut" -underline 2 -command {event generate .console <<Cut>>} -accel "$mod+X"
    .menubar.edit add command -label "Copy" -underline 0 -command {event generate .console <<Copy>>} -accel "$mod+C"
    .menubar.edit add command -label "Paste" -underline 1 -command {event generate .console <<Paste>>} -accel "$mod+V"
    if {[string compare $tcl_platform(platform) "windows"]} then {
	.menubar.edit add command -label "Clear" -underline 2 -command {event generate .console <<Clear>>}
    } else {
	.menubar.edit add command -label "Delete" -underline 0 -command {event generate .console <<Clear>>} -accel "Del"
	.menubar add cascade -label Help -menu .menubar.help -underline 0
	menu .menubar.help -tearoff 0
	.menubar.help add command -label "About..." -underline 0 -command tkConsoleAbout
    }
    . configure -menu .menubar
    text .console -yscrollcommand ".sb set" -setgrid true
    scrollbar .sb -command ".console yview"
    pack .sb -side right -fill both
    pack .console -fill both -expand 1 -side left
    switch -exact $tcl_platform(platform) {
    "macintosh" {
	    .console configure -font {Monaco 9 normal} -highlightthickness 0
	}
    "windows" {
	    .console configure -font systemfixed
	}
    }
    tkConsoleBind .console
    .console tag configure stderr -foreground red
    .console tag configure stdin -foreground blue
    focus .console
    wm protocol . WM_DELETE_WINDOW { wm withdraw . }
    wm title . "Console"
    flush stdout
    .console mark set output [.console index "end - 1 char"]
    tkTextSetCursor .console end
    .console mark set promptEnd insert
    .console mark gravity promptEnd left
}
proc tkConsoleSource {} {
    set filename [tk_getOpenFile -defaultextension .tcl -parent . -title "Select a file to source" -filetypes {{"Tcl Scripts" .tcl} {"All Files" *}}]
    if {[string compare $filename ""]} then {
	set cmd [list source $filename]
	if {[catch {consoleinterp eval $cmd} result]} then {
	    tkConsoleOutput stderr "$result\n"
	}
    }
}
proc tkConsoleInvoke {args} {
    set ranges [.console tag ranges input]
    set cmd ""
    if {[llength $ranges]} then {
	set pos 0
	while {[string compare [lindex $ranges $pos] ""]} {
	    set start [lindex $ranges $pos]
	    set end [lindex $ranges [incr pos]]
	    append cmd [.console get $start $end]
	    incr pos
	}
    }
    if {[string equal $cmd ""]} then {
	tkConsolePrompt
    } elseif {[info complete $cmd]} {
	.console mark set output end
	.console tag delete input
	set result [consoleinterp record $cmd]
	if {[string compare $result ""]} then {
	    puts $result
	}
	tkConsoleHistory reset
	tkConsolePrompt
    } else {
	tkConsolePrompt partial
    }
    .console yview -pickplace insert
}
set histNum 1
proc tkConsoleHistory {cmd} {
    global histNum
    switch $cmd {
    prev {
	    incr histNum -1
	    if {$histNum == 0} then {
		set cmd {history event [expr {[history nextid] -1}]}
	    } else {
		set cmd "history event $histNum"
	    }
	    if {[catch {consoleinterp eval $cmd} cmd]} then {
		incr histNum
		return
	    }
	    .console delete promptEnd end
	    .console insert promptEnd $cmd {input stdin}
	}
    next {
	    incr histNum
	    if {$histNum == 0} then {
		set cmd {history event [expr {[history nextid] -1}]}
	    } elseif {$histNum > 0} {
		set cmd ""
		set histNum 1
	    } else {
		set cmd "history event $histNum"
	    }
	    if {[string compare $cmd ""]} then {
		catch {consoleinterp eval $cmd} cmd
	    }
	    .console delete promptEnd end
	    .console insert promptEnd $cmd {input stdin}
	}
    reset {
	    set histNum 1
	}
    }
}
proc tkConsolePrompt {{partial normal}} {
    if {[string equal $partial "normal"]} then {
	set temp [.console index "end - 1 char"]
	.console mark set output end
	if {[consoleinterp eval "info exists tcl_prompt1"]} then {
	    consoleinterp eval "eval \[set tcl_prompt1\]"
	} else {
	    puts -nonewline "% "
	}
    } else {
	set temp [.console index output]
	.console mark set output end
	if {[consoleinterp eval "info exists tcl_prompt2"]} then {
	    consoleinterp eval "eval \[set tcl_prompt2\]"
	} else {
	    puts -nonewline "> "
	}
    }
    flush stdout
    .console mark set output $temp
    tkTextSetCursor .console end
    .console mark set promptEnd insert
    .console mark gravity promptEnd left
}
proc tkConsoleBind {win} {
    bindtags $win "$win Text . all"
    bind $win <Alt-KeyPress> {# nothing }
    bind $win <Meta-KeyPress> {# nothing}
    bind $win <Control-KeyPress> {# nothing}
    bind $win <Escape> {# nothing}
    bind $win <KP_Enter> {# nothing}
    bind $win <Tab> {
	tkConsoleInsert %W \t
	focus %W
	break
    }
    bind $win <Return> {
	%W mark set insert {end - 1c}
	tkConsoleInsert %W "\n"
	tkConsoleInvoke
	break
    }
    bind $win <Delete> {
	if {[string compare [%W tag nextrange sel 1.0 end] ""]} then {
	    %W tag remove sel sel.first promptEnd
	} elseif {[%W compare insert < promptEnd]} {
	    break
	}
    }
    bind $win <BackSpace> {
	if {[string compare [%W tag nextrange sel 1.0 end] ""]} then {
	    %W tag remove sel sel.first promptEnd
	} elseif {[%W compare insert <= promptEnd]} {
	    break
	}
    }
    foreach left {Control-a Home} {
	bind $win <$left> {
	    if {[%W compare insert < promptEnd]} then {
		tkTextSetCursor %W {insert linestart}
	    } else {
		tkTextSetCursor %W promptEnd
	    }
	    break
	}
    }
    foreach right {Control-e End} {
	bind $win <$right> {
	    tkTextSetCursor %W {insert lineend}
	    break
	}
    }
    bind $win <Control-d> {
	if {[%W compare insert < promptEnd]} then {
	    break
	}
    }
    bind $win <Control-k> {
	if {[%W compare insert < promptEnd]} then {
	    %W mark set insert promptEnd
	}
    }
    bind $win <Control-t> {
	if {[%W compare insert < promptEnd]} then {
	    break
	}
    }
    bind $win <Meta-d> {
	if {[%W compare insert < promptEnd]} then {
	    break
	}
    }
    bind $win <Meta-BackSpace> {
	if {[%W compare insert <= promptEnd]} then {
	    break
	}
    }
    bind $win <Control-h> {
	if {[%W compare insert <= promptEnd]} then {
	    break
	}
    }
    foreach prev {Control-p Up} {
	bind $win <$prev> {
	    tkConsoleHistory prev
	    break
	}
    }
    foreach prev {Control-n Down} {
	bind $win <$prev> {
	    tkConsoleHistory next
	    break
	}
    }
    bind $win <Insert> {
	catch {tkConsoleInsert %W [selection get -displayof %W]}
	break
    }
    bind $win <KeyPress> {
	tkConsoleInsert %W %A
	break
    }
    foreach left {Control-b Left} {
	bind $win <$left> {
	    if {[%W compare insert == promptEnd]} then {
		break
	    }
	    tkTextSetCursor %W insert-1c
	    break
	}
    }
    foreach right {Control-f Right} {
	bind $win <$right> {
	    tkTextSetCursor %W insert+1c
	    break
	}
    }
    bind $win <F9> {
	eval destroy [winfo child .]
	if {[string equal $tcl_platform(platform) "macintosh"]} then {
	    source -rsrc Console
	} else {
	    source [file join $tk_library console.tcl]
	}
    }
    bind $win <<Cut>> {
	if {![catch {set data [%W get sel.first sel.last]}]} then {
	    clipboard clear -displayof %W
	    clipboard append -displayof %W $data
	}
	break
    }
    bind $win <<Copy>> {
	if {![catch {set data [%W get sel.first sel.last]}]} then {
	    clipboard clear -displayof %W
	    clipboard append -displayof %W $data
	}
	break
    }
    bind $win <<Paste>> {
	catch {
	    set clip [selection get -displayof %W -selection CLIPBOARD]
	    set list [split $clip \n\r]
	    tkConsoleInsert %W [lindex $list 0]
	    foreach x [lrange $list 1 end] {
		%W mark set insert {end - 1c}
		tkConsoleInsert %W "\n"
		tkConsoleInvoke
		tkConsoleInsert %W $x
	    }
	}
	break
    }
}
proc tkConsoleInsert {w s} {
    if {[string equal $s ""]} then {
	return
    }
    catch {
	if {[$w compare sel.first <= insert] && [$w compare sel.last >= insert]} then {
	    $w tag remove sel sel.first promptEnd
	    $w delete sel.first sel.last
	}
    }
    if {[$w compare insert < promptEnd]} then {
	$w mark set insert end
    }
    $w insert insert $s {input stdin}
    $w see insert
}
proc tkConsoleOutput {dest string} {
    .console insert output $string $dest
    .console see insert
}
proc tkConsoleExit {} {
    destroy .
}
proc tkConsoleAbout {} {
    global tk_patchLevel
    tk_messageBox -type ok -message "Tcl for Windows
Copyright \251 2000 Scriptics Corporation
Tcl [info patchlevel]
Tk $tk_patchLevel"
}
tkConsoleInit
proc tk_dialog {w title text bitmap default args} {
    global tkPriv tcl_platform
    if {[string is int $default]} then {
	if {$default >= [llength $args]} then {
	    return -code error "default button index greater than number of buttons specified for tk_dialog"
	}
    } elseif {[string equal {} $default]} {
	set default -1
    } else {
	set default [lsearch -exact $args $default]
    }
    catch {destroy $w}
    toplevel $w -class Dialog
    wm title $w $title
    wm iconname $w Dialog
    wm protocol $w WM_DELETE_WINDOW { }
    if {[winfo viewable [winfo toplevel [winfo parent $w]]]} then {
	wm transient $w [winfo toplevel [winfo parent $w]]
    }
    if {[string equal $tcl_platform(platform) "macintosh"]} then {
	unsupported1 style $w dBoxProc
    }
    frame $w.bot
    frame $w.top
    if {[string equal $tcl_platform(platform) "unix"]} then {
	$w.bot configure -relief raised -bd 1
	$w.top configure -relief raised -bd 1
    }
    pack $w.bot -side bottom -fill both
    pack $w.top -side top -fill both -expand 1
    option add *Dialog.msg.wrapLength 3i widgetDefault
    if {[string equal $tcl_platform(platform) "macintosh"]} then {
	option add *Dialog.msg.font system widgetDefault
    } else {
	option add *Dialog.msg.font {Times 12} widgetDefault
    }
    label $w.msg -justify left -text $text
    pack $w.msg -in $w.top -side right -expand 1 -fill both -padx 3m -pady 3m
    if {[string compare $bitmap ""]} then {
	if {[string equal $tcl_platform(platform) "macintosh"] && [string equal $bitmap "error"]} then {
	    set bitmap "stop"
	}
	label $w.bitmap -bitmap $bitmap
	pack $w.bitmap -in $w.top -side left -padx 3m -pady 3m
    }
    set i 0
    foreach but $args {
	button $w.button$i -text $but -command [list set tkPriv(button) $i]
	if {$i == $default} then {
	    $w.button$i configure -default active
	} else {
	    $w.button$i configure -default normal
	}
	grid $w.button$i -in $w.bot -column $i -row 0 -sticky ew -padx 10
	grid columnconfigure $w.bot $i
	if {[string equal $tcl_platform(platform) "macintosh"]} then {
	    set tmp [string tolower $but]
	    if {[string equal $tmp "ok"] || [string equal $tmp "cancel"]} then {
		grid columnconfigure $w.bot $i -minsize [expr {59 + 20}]
	    }
	}
	incr i
    }
    if {$default >= 0} then {
	bind $w <Return> "
[list $w.button$default] configure -state active -relief sunken
update idletasks
after 100
set tkPriv(button) $default
"
    }
    bind $w <Destroy> {set tkPriv(button) -1}
    wm withdraw $w
    update idletasks
    set x [expr {[winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 - [winfo vrootx [winfo parent $w]]}]
    set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 - [winfo vrooty [winfo parent $w]]}]
    wm geom $w +$x+$y
    wm deiconify $w
    set oldFocus [focus]
    set oldGrab [grab current $w]
    if {[string compare $oldGrab ""]} then {
	set grabStatus [grab status $oldGrab]
    }
    grab $w
    if {$default >= 0} then {
	focus $w.button$default
    } else {
	focus $w
    }
    tkwait variable tkPriv(button)
    catch {focus $oldFocus}
    catch {
	bind $w <Destroy> {}
	destroy $w
    }
    if {[string compare $oldGrab ""]} then {
	if {[string compare $grabStatus "global"]} then {
	    grab $oldGrab
	} else {
	    grab -global $oldGrab
	}
    }
    return $tkPriv(button)
}
bind Entry <<Cut>> {
    if {![catch {tkEntryGetSelection %W} tkPriv(data)]} then {
	clipboard clear -displayof %W
	clipboard append -displayof %W $tkPriv(data)
	%W delete sel.first sel.last
	unset tkPriv(data)
    }
}
bind Entry <<Copy>> {
    if {![catch {tkEntryGetSelection %W} tkPriv(data)]} then {
	clipboard clear -displayof %W
	clipboard append -displayof %W $tkPriv(data)
	unset tkPriv(data)
    }
}
bind Entry <<Paste>> {
    global tcl_platform
    catch {
	if {[string compare $tcl_platform(platform) "unix"]} then {
	    catch {
		%W delete sel.first sel.last
	    }
	}
	%W insert insert [selection get -displayof %W -selection CLIPBOARD]
	tkEntrySeeInsert %W
    }
}
bind Entry <<Clear>> {
    %W delete sel.first sel.last
}
bind Entry <<PasteSelection>> {
    if {!$tkPriv(mouseMoved) || $tk_strictMotif} then {
	tkEntryPaste %W %x
    }
}
bind Entry <1> {
    tkEntryButton1 %W %x
    %W selection clear
}
bind Entry <B1-Motion> {
    set tkPriv(x) %x
    tkEntryMouseSelect %W %x
}
bind Entry <Double-1> {
    set tkPriv(selectMode) word
    tkEntryMouseSelect %W %x
    catch {%W icursor sel.first}
}
bind Entry <Triple-1> {
    set tkPriv(selectMode) line
    tkEntryMouseSelect %W %x
    %W icursor 0
}
bind Entry <Shift-1> {
    set tkPriv(selectMode) char
    %W selection adjust @%x
}
bind Entry <Double-Shift-1> {
    set tkPriv(selectMode) word
    tkEntryMouseSelect %W %x
}
bind Entry <Triple-Shift-1> {
    set tkPriv(selectMode) line
    tkEntryMouseSelect %W %x
}
bind Entry <B1-Leave> {
    set tkPriv(x) %x
    tkEntryAutoScan %W
}
bind Entry <B1-Enter> {
    tkCancelRepeat
}
bind Entry <ButtonRelease-1> {
    tkCancelRepeat
}
bind Entry <Control-1> {
    %W icursor @%x
}
bind Entry <Left> {
    tkEntrySetCursor %W [expr {[%W index insert] - 1}]
}
bind Entry <Right> {
    tkEntrySetCursor %W [expr {[%W index insert] + 1}]
}
bind Entry <Shift-Left> {
    tkEntryKeySelect %W [expr {[%W index insert] - 1}]
    tkEntrySeeInsert %W
}
bind Entry <Shift-Right> {
    tkEntryKeySelect %W [expr {[%W index insert] + 1}]
    tkEntrySeeInsert %W
}
bind Entry <Control-Left> {
    tkEntrySetCursor %W [tkEntryPreviousWord %W insert]
}
bind Entry <Control-Right> {
    tkEntrySetCursor %W [tkEntryNextWord %W insert]
}
bind Entry <Shift-Control-Left> {
    tkEntryKeySelect %W [tkEntryPreviousWord %W insert]
    tkEntrySeeInsert %W
}
bind Entry <Shift-Control-Right> {
    tkEntryKeySelect %W [tkEntryNextWord %W insert]
    tkEntrySeeInsert %W
}
bind Entry <Home> {
    tkEntrySetCursor %W 0
}
bind Entry <Shift-Home> {
    tkEntryKeySelect %W 0
    tkEntrySeeInsert %W
}
bind Entry <End> {
    tkEntrySetCursor %W end
}
bind Entry <Shift-End> {
    tkEntryKeySelect %W end
    tkEntrySeeInsert %W
}
bind Entry <Delete> {
    if {[%W selection present]} then {
	%W delete sel.first sel.last
    } else {
	%W delete insert
    }
}
bind Entry <BackSpace> {
    tkEntryBackspace %W
}
bind Entry <Control-space> {
    %W selection from insert
}
bind Entry <Select> {
    %W selection from insert
}
bind Entry <Control-Shift-space> {
    %W selection adjust insert
}
bind Entry <Shift-Select> {
    %W selection adjust insert
}
bind Entry <Control-slash> {
    %W selection range 0 end
}
bind Entry <Control-backslash> {
    %W selection clear
}
bind Entry <KeyPress> {
    tkEntryInsert %W %A
}
bind Entry <Alt-KeyPress> {# nothing}
bind Entry <Meta-KeyPress> {# nothing}
bind Entry <Control-KeyPress> {# nothing}
bind Entry <Escape> {# nothing}
bind Entry <Return> {# nothing}
bind Entry <KP_Enter> {# nothing}
bind Entry <Tab> {# nothing}
if {[string equal $tcl_platform(platform) "macintosh"]} then {
    bind Entry <Command-KeyPress> {# nothing}
}
if {[string compare $tcl_platform(platform) "windows"]} then {
    bind Entry <Insert> {
	catch {tkEntryInsert %W [selection get -displayof %W]}
    }
}
bind Entry <Control-a> {
    if {!$tk_strictMotif} then {
	tkEntrySetCursor %W 0
    }
}
bind Entry <Control-b> {
    if {!$tk_strictMotif} then {
	tkEntrySetCursor %W [expr {[%W index insert] - 1}]
    }
}
bind Entry <Control-d> {
    if {!$tk_strictMotif} then {
	%W delete insert
    }
}
bind Entry <Control-e> {
    if {!$tk_strictMotif} then {
	tkEntrySetCursor %W end
    }
}
bind Entry <Control-f> {
    if {!$tk_strictMotif} then {
	tkEntrySetCursor %W [expr {[%W index insert] + 1}]
    }
}
bind Entry <Control-h> {
    if {!$tk_strictMotif} then {
	tkEntryBackspace %W
    }
}
bind Entry <Control-k> {
    if {!$tk_strictMotif} then {
	%W delete insert end
    }
}
bind Entry <Control-t> {
    if {!$tk_strictMotif} then {
	tkEntryTranspose %W
    }
}
bind Entry <Meta-b> {
    if {!$tk_strictMotif} then {
	tkEntrySetCursor %W [tkEntryPreviousWord %W insert]
    }
}
bind Entry <Meta-d> {
    if {!$tk_strictMotif} then {
	%W delete insert [tkEntryNextWord %W insert]
    }
}
bind Entry <Meta-f> {
    if {!$tk_strictMotif} then {
	tkEntrySetCursor %W [tkEntryNextWord %W insert]
    }
}
bind Entry <Meta-BackSpace> {
    if {!$tk_strictMotif} then {
	%W delete [tkEntryPreviousWord %W insert] insert
    }
}
bind Entry <Meta-Delete> {
    if {!$tk_strictMotif} then {
	%W delete [tkEntryPreviousWord %W insert] insert
    }
}
bind Entry <2> {
    if {!$tk_strictMotif} then {
	%W scan mark %x
	set tkPriv(x) %x
	set tkPriv(y) %y
	set tkPriv(mouseMoved) 0
    }
}
bind Entry <B2-Motion> {
    if {!$tk_strictMotif} then {
	if {abs(%x-$tkPriv(x)) > 2} then {
	    set tkPriv(mouseMoved) 1
	}
	%W scan dragto %x
    }
}
proc tkEntryClosestGap {w x} {
    set pos [$w index @$x]
    set bbox [$w bbox $pos]
    if {($x - [lindex $bbox 0]) <([lindex $bbox 2]/2)} then {
	return $pos
    }
    incr pos
}
proc tkEntryButton1 {w x} {
    global tkPriv
    set tkPriv(selectMode) char
    set tkPriv(mouseMoved) 0
    set tkPriv(pressX) $x
    $w icursor [tkEntryClosestGap $w $x]
    $w selection from insert
    if {[string equal [$w cget -state] "normal"]} then {
	focus $w
    }
}
proc tkEntryMouseSelect {w x} {
    global tkPriv
    set cur [tkEntryClosestGap $w $x]
    set anchor [$w index anchor]
    if {($cur != $anchor) ||(abs($tkPriv(pressX) - $x) >= 3)} then {
	set tkPriv(mouseMoved) 1
    }
    switch $tkPriv(selectMode) {
    char {
	    if {$tkPriv(mouseMoved)} then {
		if {$cur < $anchor} then {
		    $w selection range $cur $anchor
		} elseif {$cur > $anchor} {
		    $w selection range $anchor $cur
		} else {
		    $w selection clear
		}
	    }
	}
    word {
	    if {$cur < [$w index anchor]} then {
		set before [tcl_wordBreakBefore [$w get] $cur]
		set after [tcl_wordBreakAfter [$w get] [expr {$anchor-1}]]
	    } else {
		set before [tcl_wordBreakBefore [$w get] $anchor]
		set after [tcl_wordBreakAfter [$w get] [expr {$cur - 1}]]
	    }
	    if {$before < 0} then {
		set before 0
	    }
	    if {$after < 0} then {
		set after end
	    }
	    $w selection range $before $after
	}
    line {
	    $w selection range 0 end
	}
    }
    update idletasks
}
proc tkEntryPaste {w x} {
    global tkPriv
    $w icursor [tkEntryClosestGap $w $x]
    catch {$w insert insert [selection get -displayof $w]}
    if {[string equal [$w cget -state] "normal"]} then {
	focus $w
    }
}
proc tkEntryAutoScan {w} {
    global tkPriv
    set x $tkPriv(x)
    if {![winfo exists $w]} then return
    if {$x >= [winfo width $w]} then {
	$w xview scroll 2 units
	tkEntryMouseSelect $w $x
    } elseif {$x < 0} {
	$w xview scroll -2 units
	tkEntryMouseSelect $w $x
    }
    set tkPriv(afterId) [after 50 [list tkEntryAutoScan $w]]
}
proc tkEntryKeySelect {w new} {
    if {![$w selection present]} then {
	$w selection from insert
	$w selection to $new
    } else {
	$w selection adjust $new
    }
    $w icursor $new
}
proc tkEntryInsert {w s} {
    if {[string equal $s ""]} then {
	return
    }
    catch {
	set insert [$w index insert]
	if {([$w index sel.first] <= $insert) &&([$w index sel.last] >= $insert)} then {
	    $w delete sel.first sel.last
	}
    }
    $w insert insert $s
    tkEntrySeeInsert $w
}
proc tkEntryBackspace w {
    if {[$w selection present]} then {
	$w delete sel.first sel.last
    } else {
	set x [expr {[$w index insert] - 1}]
	if {$x >= 0} then {
	    $w delete $x
	}
	if {[$w index @0] >= [$w index insert]} then {
	    set range [$w xview]
	    set left [lindex $range 0]
	    set right [lindex $range 1]
	    $w xview moveto [expr {$left -($right - $left) /2.0}]
	}
    }
}
proc tkEntrySeeInsert w {
    set c [$w index insert]
    if {($c < [$w index @0]) ||($c > [$w index @[winfo width $w]])} then {
	$w xview $c
    }
}
proc tkEntrySetCursor {w pos} {
    $w icursor $pos
    $w selection clear
    tkEntrySeeInsert $w
}
proc tkEntryTranspose w {
    set i [$w index insert]
    if {$i < [$w index end]} then {
	incr i
    }
    set first [expr {$i-2}]
    if {$first < 0} then {
	return
    }
    set new [string index [$w get] [expr {$i-1}]][string index [$w get] $first]
    $w delete $first $i
    $w insert insert $new
    tkEntrySeeInsert $w
}
if {[string equal $tcl_platform(platform) "windows"]} then {
    proc tkEntryNextWord {w start} {
	set pos [tcl_endOfWord [$w get] [$w index $start]]
	if {$pos >= 0} then {
	    set pos [tcl_startOfNextWord [$w get] $pos]
	}
	if {$pos < 0} then {
	    return end
	}
	return $pos
    }
} else {
    proc tkEntryNextWord {w start} {
	set pos [tcl_endOfWord [$w get] [$w index $start]]
	if {$pos < 0} then {
	    return end
	}
	return $pos
    }
}
proc tkEntryPreviousWord {w start} {
    set pos [tcl_startOfPreviousWord [$w get] [$w index $start]]
    if {$pos < 0} then {
	return 0
    }
    return $pos
}
proc tkEntryGetSelection {w} {
    set entryString [string range [$w get] [$w index sel.first] [expr {[$w index sel.last] - 1}]]
    if {[string compare [$w cget -show] ""]} then {
	regsub -all . $entryString [string index [$w cget -show] 0] entryString
    }
    return $entryString
}
proc tk_focusNext w {
    set cur $w
    while {1} {
	set parent $cur
	set children [winfo children $cur]
	set i -1
	while {1} {
	    incr i
	    if {$i < [llength $children]} then {
		set cur [lindex $children $i]
		if {[string equal [winfo toplevel $cur] $cur]} then {
		    continue
		} else {
		    break
		}
	    }
	    set cur $parent
	    if {[string equal [winfo toplevel $cur] $cur]} then {
		break
	    }
	    set parent [winfo parent $parent]
	    set children [winfo children $parent]
	    set i [lsearch -exact $children $cur]
	}
	if {[string equal $w $cur] || [tkFocusOK $cur]} then {
	    return $cur
	}
    }
}
proc tk_focusPrev w {
    set cur $w
    while {1} {
	if {[string equal [winfo toplevel $cur] $cur]} then {
	    set parent $cur
	    set children [winfo children $cur]
	    set i [llength $children]
	} else {
	    set parent [winfo parent $cur]
	    set children [winfo children $parent]
	    set i [lsearch -exact $children $cur]
	}
	while {$i > 0} {
	    incr i -1
	    set cur [lindex $children $i]
	    if {[string equal [winfo toplevel $cur] $cur]} then {
		continue
	    }
	    set parent $cur
	    set children [winfo children $parent]
	    set i [llength $children]
	}
	set cur $parent
	if {[string equal $w $cur] || [tkFocusOK $cur]} then {
	    return $cur
	}
    }
}
proc tkFocusOK w {
    set code [catch {$w cget -takefocus} value]
    if {($code == 0) && [string compare $value ""]} then {
	if {$value == 0} then {
	    return 0
	} elseif {$value == 1} {
	    return [winfo viewable $w]
	} else {
	    set value [uplevel #0 [list $value $w]]
	    if {[string compare $value ""]} then {
		return $value
	    }
	}
    }
    if {![winfo viewable $w]} then {
	return 0
    }
    set code [catch {$w cget -state} value]
    if {($code == 0) && [string equal $value "disabled"]} then {
	return 0
    }
    regexp Key|Focus "[bind $w] [bind [winfo class $w]]"
}
proc tk_focusFollowsMouse {} {
    set old [bind all <Enter>]
    set script {
if {[string equal "%d" "NotifyAncestor"] \
		|| [string equal "%d" "NotifyNonlinear"] \
		|| [string equal "%d" "NotifyInferior"]} {
if {[tkFocusOK %W]} {
focus %W
}
}
}
    if {[string compare $old ""]} then {
	bind all <Enter> "$old; $script"
    } else {
	bind all <Enter> $script
    }
}
bind Listbox <1> {
    if {[winfo exists %W]} then {
	tkListboxBeginSelect %W [%W index @%x,%y]
    }
}
bind Listbox <Double-1> {
}
bind Listbox <B1-Motion> {
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkListboxMotion %W [%W index @%x,%y]
}
bind Listbox <ButtonRelease-1> {
    tkCancelRepeat
    %W activate @%x,%y
}
bind Listbox <Shift-1> {
    tkListboxBeginExtend %W [%W index @%x,%y]
}
bind Listbox <Control-1> {
    tkListboxBeginToggle %W [%W index @%x,%y]
}
bind Listbox <B1-Leave> {
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkListboxAutoScan %W
}
bind Listbox <B1-Enter> {
    tkCancelRepeat
}
bind Listbox <Up> {
    tkListboxUpDown %W -1
}
bind Listbox <Shift-Up> {
    tkListboxExtendUpDown %W -1
}
bind Listbox <Down> {
    tkListboxUpDown %W 1
}
bind Listbox <Shift-Down> {
    tkListboxExtendUpDown %W 1
}
bind Listbox <Left> {
    %W xview scroll -1 units
}
bind Listbox <Control-Left> {
    %W xview scroll -1 pages
}
bind Listbox <Right> {
    %W xview scroll 1 units
}
bind Listbox <Control-Right> {
    %W xview scroll 1 pages
}
bind Listbox <Prior> {
    %W yview scroll -1 pages
    %W activate @0,0
}
bind Listbox <Next> {
    %W yview scroll 1 pages
    %W activate @0,0
}
bind Listbox <Control-Prior> {
    %W xview scroll -1 pages
}
bind Listbox <Control-Next> {
    %W xview scroll 1 pages
}
bind Listbox <Home> {
    %W xview moveto 0
}
bind Listbox <End> {
    %W xview moveto 1
}
bind Listbox <Control-Home> {
    %W activate 0
    %W see 0
    %W selection clear 0 end
    %W selection set 0
    event generate %W <<ListboxSelect>>
}
bind Listbox <Shift-Control-Home> {
    tkListboxDataExtend %W 0
}
bind Listbox <Control-End> {
    %W activate end
    %W see end
    %W selection clear 0 end
    %W selection set end
    event generate %W <<ListboxSelect>>
}
bind Listbox <Shift-Control-End> {
    tkListboxDataExtend %W [%W index end]
}
bind Listbox <<Copy>> {
    if {[string equal [selection own -displayof %W] "%W"]} then {
	clipboard clear -displayof %W
	clipboard append -displayof %W [selection get -displayof %W]
    }
}
bind Listbox <space> {
    tkListboxBeginSelect %W [%W index active]
}
bind Listbox <Select> {
    tkListboxBeginSelect %W [%W index active]
}
bind Listbox <Control-Shift-space> {
    tkListboxBeginExtend %W [%W index active]
}
bind Listbox <Shift-Select> {
    tkListboxBeginExtend %W [%W index active]
}
bind Listbox <Escape> {
    tkListboxCancel %W
}
bind Listbox <Control-slash> {
    tkListboxSelectAll %W
}
bind Listbox <Control-backslash> {
    if {[string compare [%W cget -selectmode] "browse"]} then {
	%W selection clear 0 end
	event generate %W <<ListboxSelect>>
    }
}
bind Listbox <2> {
    %W scan mark %x %y
}
bind Listbox <B2-Motion> {
    %W scan dragto %x %y
}
bind Listbox <MouseWheel> {
    %W yview scroll [expr {-(%D / 120) * 4}] units
}
if {[string equal "unix" $tcl_platform(platform)]} then {
    bind Listbox <4> {
	if {!$tk_strictMotif} then {
	    %W yview scroll -5 units
	}
    }
    bind Listbox <5> {
	if {!$tk_strictMotif} then {
	    %W yview scroll 5 units
	}
    }
}
proc tkListboxBeginSelect {w el} {
    global tkPriv
    if {[string equal [$w cget -selectmode] "multiple"]} then {
	if {[$w selection includes $el]} then {
	    $w selection clear $el
	} else {
	    $w selection set $el
	}
    } else {
	$w selection clear 0 end
	$w selection set $el
	$w selection anchor $el
	set tkPriv(listboxSelection) {}
	set tkPriv(listboxPrev) $el
    }
    event generate $w <<ListboxSelect>>
}
proc tkListboxMotion {w el} {
    global tkPriv
    if {$el == $tkPriv(listboxPrev)} then {
	return
    }
    set anchor [$w index anchor]
    switch [$w cget -selectmode] {
    browse {
	    $w selection clear 0 end
	    $w selection set $el
	    set tkPriv(listboxPrev) $el
	    event generate $w <<ListboxSelect>>
	}
    extended {
	    set i $tkPriv(listboxPrev)
	    if {[string equal {} $i]} then {
		set i $el
		$w selection set $el
	    }
	    if {[$w selection includes anchor]} then {
		$w selection clear $i $el
		$w selection set anchor $el
	    } else {
		$w selection clear $i $el
		$w selection clear anchor $el
	    }
	    if {![info exists tkPriv(listboxSelection)]} then {
		set tkPriv(listboxSelection) [$w curselection]
	    }
	    while {($i < $el) &&($i < $anchor)} {
		if {[lsearch $tkPriv(listboxSelection) $i] >= 0} then {
		    $w selection set $i
		}
		incr i
	    }
	    while {($i > $el) &&($i > $anchor)} {
		if {[lsearch $tkPriv(listboxSelection) $i] >= 0} then {
		    $w selection set $i
		}
		incr i -1
	    }
	    set tkPriv(listboxPrev) $el
	    event generate $w <<ListboxSelect>>
	}
    }
}
proc tkListboxBeginExtend {w el} {
    if {[string equal [$w cget -selectmode] "extended"]} then {
	if {[$w selection includes anchor]} then {
	    tkListboxMotion $w $el
	} else {
	    tkListboxBeginSelect $w $el
	}
    }
}
proc tkListboxBeginToggle {w el} {
    global tkPriv
    if {[string equal [$w cget -selectmode] "extended"]} then {
	set tkPriv(listboxSelection) [$w curselection]
	set tkPriv(listboxPrev) $el
	$w selection anchor $el
	if {[$w selection includes $el]} then {
	    $w selection clear $el
	} else {
	    $w selection set $el
	}
	event generate $w <<ListboxSelect>>
    }
}
proc tkListboxAutoScan {w} {
    global tkPriv
    if {![winfo exists $w]} then return
    set x $tkPriv(x)
    set y $tkPriv(y)
    if {$y >= [winfo height $w]} then {
	$w yview scroll 1 units
    } elseif {$y < 0} {
	$w yview scroll -1 units
    } elseif {$x >= [winfo width $w]} {
	$w xview scroll 2 units
    } elseif {$x < 0} {
	$w xview scroll -2 units
    } else {
	return
    }
    tkListboxMotion $w [$w index @$x,$y]
    set tkPriv(afterId) [after 50 [list tkListboxAutoScan $w]]
}
proc tkListboxUpDown {w amount} {
    global tkPriv
    $w activate [expr {[$w index active] + $amount}]
    $w see active
    switch [$w cget -selectmode] {
    browse {
	    $w selection clear 0 end
	    $w selection set active
	    event generate $w <<ListboxSelect>>
	}
    extended {
	    $w selection clear 0 end
	    $w selection set active
	    $w selection anchor active
	    set tkPriv(listboxPrev) [$w index active]
	    set tkPriv(listboxSelection) {}
	    event generate $w <<ListboxSelect>>
	}
    }
}
proc tkListboxExtendUpDown {w amount} {
    if {[string compare [$w cget -selectmode] "extended"]} then {
	return
    }
    set active [$w index active]
    if {![info exists tkPriv(listboxSelection)]} then {
	global tkPriv
	$w selection set $active
	set tkPriv(listboxSelection) [$w curselection]
    }
    $w activate [expr {$active + $amount}]
    $w see active
    tkListboxMotion $w [$w index active]
}
proc tkListboxDataExtend {w el} {
    set mode [$w cget -selectmode]
    if {[string equal $mode "extended"]} then {
	$w activate $el
	$w see $el
	if {[$w selection includes anchor]} then {
	    tkListboxMotion $w $el
	}
    } elseif {[string equal $mode "multiple"]} {
	$w activate $el
	$w see $el
    }
}
proc tkListboxCancel w {
    global tkPriv
    if {[string compare [$w cget -selectmode] "extended"]} then {
	return
    }
    set first [$w index anchor]
    set last $tkPriv(listboxPrev)
    if {[string equal $last ""]} then {
	return
    }
    if {$first > $last} then {
	set tmp $first
	set first $last
	set last $tmp
    }
    $w selection clear $first $last
    while {$first <= $last} {
	if {[lsearch $tkPriv(listboxSelection) $first] >= 0} then {
	    $w selection set $first
	}
	incr first
    }
    event generate $w <<ListboxSelect>>
}
proc tkListboxSelectAll w {
    set mode [$w cget -selectmode]
    if {[string equal $mode "single"] || [string equal $mode "browse"]} then {
	$w selection clear 0 end
	$w selection set active
    } else {
	$w selection set 0 end
    }
    event generate $w <<ListboxSelect>>
}
bind Menubutton <FocusIn> {}
bind Menubutton <Enter> {
    tkMbEnter %W
}
bind Menubutton <Leave> {
    tkMbLeave %W
}
bind Menubutton <1> {
    if {[string compare $tkPriv(inMenubutton) ""]} then {
	tkMbPost $tkPriv(inMenubutton) %X %Y
    }
}
bind Menubutton <Motion> {
    tkMbMotion %W up %X %Y
}
bind Menubutton <B1-Motion> {
    tkMbMotion %W down %X %Y
}
bind Menubutton <ButtonRelease-1> {
    tkMbButtonUp %W
}
bind Menubutton <space> {
    tkMbPost %W
    tkMenuFirstEntry [%W cget -menu]
}
bind Menu <FocusIn> {}
bind Menu <Enter> {
    set tkPriv(window) %W
    if {[string equal [%W cget -type] "tearoff"]} then {
	if {[string compare "%m" "NotifyUngrab"]} then {
	    if {[string equal $tcl_platform(platform) "unix"]} then {
		tk_menuSetFocus %W
	    }
	}
    }
    tkMenuMotion %W %x %y %s
}
bind Menu <Leave> {
    tkMenuLeave %W %X %Y %s
}
bind Menu <Motion> {
    tkMenuMotion %W %x %y %s
}
bind Menu <ButtonPress> {
    tkMenuButtonDown %W
}
bind Menu <ButtonRelease> {
    tkMenuInvoke %W 1
}
bind Menu <space> {
    tkMenuInvoke %W 0
}
bind Menu <Return> {
    tkMenuInvoke %W 0
}
bind Menu <Escape> {
    tkMenuEscape %W
}
bind Menu <Left> {
    tkMenuLeftArrow %W
}
bind Menu <Right> {
    tkMenuRightArrow %W
}
bind Menu <Up> {
    tkMenuUpArrow %W
}
bind Menu <Down> {
    tkMenuDownArrow %W
}
bind Menu <KeyPress> {
    tkTraverseWithinMenu %W %A
}
if {[string equal $tcl_platform(platform) "unix"]} then {
    bind all <Alt-KeyPress> {
	tkTraverseToMenu %W %A
    }
    bind all <F10> {
	tkFirstMenu %W
    }
} else {
    bind Menubutton <Alt-KeyPress> {
	tkTraverseToMenu %W %A
    }
    bind Menubutton <F10> {
	tkFirstMenu %W
    }
}
proc tkMbEnter w {
    global tkPriv
    if {[string compare $tkPriv(inMenubutton) ""]} then {
	tkMbLeave $tkPriv(inMenubutton)
    }
    set tkPriv(inMenubutton) $w
    if {[string compare [$w cget -state] "disabled"]} then {
	$w configure -state active
    }
}
proc tkMbLeave w {
    global tkPriv
    set tkPriv(inMenubutton) {}
    if {![winfo exists $w]} then {
	return
    }
    if {[string equal [$w cget -state] "active"]} then {
	$w configure -state normal
    }
}
proc tkMbPost {w {x {}} {y {}}} {
    global tkPriv errorInfo
    global tcl_platform
    if {[string equal [$w cget -state] "disabled"] || [string equal $w $tkPriv(postedMb)]} then {
	return
    }
    set menu [$w cget -menu]
    if {[string equal $menu ""]} then {
	return
    }
    set tearoff [expr {[string equal $tcl_platform(platform) "unix"] || [string equal [$menu cget -type] "tearoff"]}]
    if {[string first $w $menu] != 0} then {
	error "can't post $menu:  it isn't a descendant of $w (this is a new requirement in Tk versions 3.0 and later)"
    }
    set cur $tkPriv(postedMb)
    if {[string compare $cur ""]} then {
	tkMenuUnpost {}
    }
    set tkPriv(cursor) [$w cget -cursor]
    set tkPriv(relief) [$w cget -relief]
    $w configure -cursor arrow
    $w configure -relief raised
    set tkPriv(postedMb) $w
    set tkPriv(focus) [focus]
    $menu activate none
    tkGenerateMenuSelect $menu
    update idletasks
    if {[catch {
	switch [$w cget -direction] {
	above {
		set x [winfo rootx $w]
		set y [expr {[winfo rooty $w] - [winfo reqheight $menu]}]
		$menu post $x $y
	    }
	below {
		set x [winfo rootx $w]
		set y [expr {[winfo rooty $w] + [winfo height $w]}]
		$menu post $x $y
	    }
	left {
		set x [expr {[winfo rootx $w] - [winfo reqwidth $menu]}]
		set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]
		set entry [tkMenuFindName $menu [$w cget -text]]
		if {[$w cget -indicatoron]} then {
		    if {$entry == [$menu index last]} then {
			incr y [expr {-([$menu yposition $entry] + [winfo reqheight $menu]) /2}]
		    } else {
			incr y [expr {-([$menu yposition $entry] + [$menu yposition [expr {$entry+1}]]) /2}]
		    }
		}
		$menu post $x $y
		if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} then {
		    $menu activate $entry
		    tkGenerateMenuSelect $menu
		}
	    }
	right {
		set x [expr {[winfo rootx $w] + [winfo width $w]}]
		set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]
		set entry [tkMenuFindName $menu [$w cget -text]]
		if {[$w cget -indicatoron]} then {
		    if {$entry == [$menu index last]} then {
			incr y [expr {-([$menu yposition $entry] + [winfo reqheight $menu]) /2}]
		    } else {
			incr y [expr {-([$menu yposition $entry] + [$menu yposition [expr {$entry+1}]]) /2}]
		    }
		}
		$menu post $x $y
		if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} then {
		    $menu activate $entry
		    tkGenerateMenuSelect $menu
		}
	    }
	default {
		if {[$w cget -indicatoron]} then {
		    if {[string equal $y {}]} then {
			set x [expr {[winfo rootx $w] + [winfo width $w]/2}]
			set y [expr {[winfo rooty $w] + [winfo height $w]/2}]
		    }
		    tkPostOverPoint $menu $x $y [tkMenuFindName $menu [$w cget -text]]
		} else {
		    $menu post [winfo rootx $w] [expr {[winfo rooty $w]+[winfo height $w]}]
		}
	    }
	}
    } msg]} then {
	set savedInfo $errorInfo
	tkMenuUnpost {}
	error $msg $savedInfo
    }
    set tkPriv(tearoff) $tearoff
    if {$tearoff != 0} then {
	focus $menu
	if {[winfo viewable $w]} then {
	    tkSaveGrabInfo $w
	    grab -global $w
	}
    }
}
proc tkMenuUnpost menu {
    global tcl_platform
    global tkPriv
    set mb $tkPriv(postedMb)
    catch {focus $tkPriv(focus)}
    set tkPriv(focus) ""
    catch {
	if {[string compare $mb ""]} then {
	    set menu [$mb cget -menu]
	    $menu unpost
	    set tkPriv(postedMb) {}
	    $mb configure -cursor $tkPriv(cursor)
	    $mb configure -relief $tkPriv(relief)
	} elseif {[string compare $tkPriv(popup) ""]} {
	    $tkPriv(popup) unpost
	    set tkPriv(popup) {}
	} elseif {[string compare [$menu cget -type] "menubar"] && [string compare [$menu cget -type] "tearoff"]} {
	    while {1} {
		set parent [winfo parent $menu]
		if {[string compare [winfo class $parent] "Menu"] || ![winfo ismapped $parent]} then {
		    break
		}
		$parent activate none
		$parent postcascade none
		tkGenerateMenuSelect $parent
		set type [$parent cget -type]
		if {[string equal $type "menubar"] || [string equal $type "tearoff"]} then {
		    break
		}
		set menu $parent
	    }
	    if {[string compare [$menu cget -type] "menubar"]} then {
		$menu unpost
	    }
	}
    }
    if {($tkPriv(tearoff) != 0) || [string compare $tkPriv(menuBar) ""]} then {
	if {[string compare $menu ""]} then {
	    set grab [grab current $menu]
	    if {[string compare $grab ""]} then {
		grab release $grab
	    }
	}
	tkRestoreOldGrab
	if {[string compare $tkPriv(menuBar) ""]} then {
	    $tkPriv(menuBar) configure -cursor $tkPriv(cursor)
	    set tkPriv(menuBar) {}
	}
	if {[string compare $tcl_platform(platform) "unix"]} then {
	    set tkPriv(tearoff) 0
	}
    }
}
proc tkMbMotion {w upDown rootx rooty} {
    global tkPriv
    if {[string equal $tkPriv(inMenubutton) $w]} then {
	return
    }
    set new [winfo containing $rootx $rooty]
    if {[string compare $new $tkPriv(inMenubutton)] &&([string equal $new ""] || [string equal [winfo toplevel $new] [winfo toplevel $w]])} then {
	if {[string compare $tkPriv(inMenubutton) ""]} then {
	    tkMbLeave $tkPriv(inMenubutton)
	}
	if {[string compare $new ""] && [string equal [winfo class $new] "Menubutton"] &&([$new cget -indicatoron] == 0) &&([$w cget -indicatoron] == 0)} then {
	    if {[string equal $upDown "down"]} then {
		tkMbPost $new $rootx $rooty
	    } else {
		tkMbEnter $new
	    }
	}
    }
}
proc tkMbButtonUp w {
    global tkPriv
    global tcl_platform
    set menu [$w cget -menu]
    set tearoff [expr {[string equal $tcl_platform(platform) "unix"] ||([string compare $menu {}] && [string equal [$menu cget -type] "tearoff"])}]
    if {($tearoff != 0) && [string equal $tkPriv(postedMb) $w] && [string equal $tkPriv(inMenubutton) $w]} then {
	tkMenuFirstEntry [$tkPriv(postedMb) cget -menu]
    } else {
	tkMenuUnpost {}
    }
}
proc tkMenuMotion {menu x y state} {
    global tkPriv
    if {[string equal $menu $tkPriv(window)]} then {
	if {[string equal [$menu cget -type] "menubar"]} then {
	    if {[info exists tkPriv(focus)] && [string compare $menu $tkPriv(focus)]} then {
		$menu activate @$x,$y
		tkGenerateMenuSelect $menu
	    }
	} else {
	    $menu activate @$x,$y
	    tkGenerateMenuSelect $menu
	}
    }
    if {($state & 0x1f00) != 0} then {
	$menu postcascade active
    }
}
proc tkMenuButtonDown menu {
    global tkPriv
    global tcl_platform
    if {![winfo viewable $menu]} then {
	return
    }
    $menu postcascade active
    if {[string compare $tkPriv(postedMb) ""] && [winfo viewable $tkPriv(postedMb)]} then {
	grab -global $tkPriv(postedMb)
    } else {
	while {[string equal [$menu cget -type] "normal"] && [string equal [winfo class [winfo parent $menu]] "Menu"] && [winfo ismapped [winfo parent $menu]]} {
	    set menu [winfo parent $menu]
	}
	if {[string equal $tkPriv(menuBar) {}]} then {
	    set tkPriv(menuBar) $menu
	    set tkPriv(cursor) [$menu cget -cursor]
	    $menu configure -cursor arrow
	}
	if {[string compare $menu [grab current $menu]]} then {
	    tkSaveGrabInfo $menu
	}
	if {[string equal $tcl_platform(platform) "unix"]} then {
	    grab -global $menu
	}
    }
}
proc tkMenuLeave {menu rootx rooty state} {
    global tkPriv
    set tkPriv(window) {}
    if {[string equal [$menu index active] "none"]} then {
	return
    }
    if {[string equal [$menu type active] "cascade"] && [string equal [winfo containing $rootx $rooty] [$menu entrycget active -menu]]} then {
	return
    }
    $menu activate none
    tkGenerateMenuSelect $menu
}
proc tkMenuInvoke {w buttonRelease} {
    global tkPriv
    if {$buttonRelease && [string equal $tkPriv(window) {}]} then {
	$w postcascade none
	$w activate none
	event generate $w <<MenuSelect>>
	tkMenuUnpost $w
	return
    }
    if {[string equal [$w type active] "cascade"]} then {
	$w postcascade active
	set menu [$w entrycget active -menu]
	tkMenuFirstEntry $menu
    } elseif {[string equal [$w type active] "tearoff"]} {
	tkTearOffMenu $w
	tkMenuUnpost $w
    } elseif {[string equal [$w cget -type] "menubar"]} {
	$w postcascade none
	set active [$w index active]
	set isCascade [string equal [$w type $active] "cascade"]
	if {$isCascade} then {
	    $w activate none
	    event generate $w <<MenuSelect>>
	}
	tkMenuUnpost $w
	if {!$isCascade} then {
	    uplevel #0 [list $w invoke $active]
	}
    } else {
	tkMenuUnpost $w
	uplevel #0 [list $w invoke active]
    }
}
proc tkMenuEscape menu {
    set parent [winfo parent $menu]
    if {[string compare [winfo class $parent] "Menu"]} then {
	tkMenuUnpost $menu
    } elseif {[string equal [$parent cget -type] "menubar"]} {
	tkMenuUnpost $menu
	tkRestoreOldGrab
    } else {
	tkMenuNextMenu $menu left
    }
}
proc tkMenuUpArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} then {
	tkMenuNextMenu $menu left
    } else {
	tkMenuNextEntry $menu -1
    }
}
proc tkMenuDownArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} then {
	tkMenuNextMenu $menu right
    } else {
	tkMenuNextEntry $menu 1
    }
}
proc tkMenuLeftArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} then {
	tkMenuNextEntry $menu -1
    } else {
	tkMenuNextMenu $menu left
    }
}
proc tkMenuRightArrow {menu} {
    if {[string equal [$menu cget -type] "menubar"]} then {
	tkMenuNextEntry $menu 1
    } else {
	tkMenuNextMenu $menu right
    }
}
proc tkMenuNextMenu {menu direction} {
    global tkPriv
    if {[string equal $direction "right"]} then {
	set count 1
	set parent [winfo parent $menu]
	set class [winfo class $parent]
	if {[string equal [$menu type active] "cascade"]} then {
	    $menu postcascade active
	    set m2 [$menu entrycget active -menu]
	    if {[string compare $m2 ""]} then {
		tkMenuFirstEntry $m2
	    }
	    return
	} else {
	    set parent [winfo parent $menu]
	    while {[string compare $parent "."]} {
		if {[string equal [winfo class $parent] "Menu"] && [string equal [$parent cget -type] "menubar"]} then {
		    tk_menuSetFocus $parent
		    tkMenuNextEntry $parent 1
		    return
		}
		set parent [winfo parent $parent]
	    }
	}
    } else {
	set count -1
	set m2 [winfo parent $menu]
	if {[string equal [winfo class $m2] "Menu"]} then {
	    if {[string compare [$m2 cget -type] "menubar"]} then {
		$menu activate none
		tkGenerateMenuSelect $menu
		tk_menuSetFocus $m2
		set tmp [$m2 index active]
		$m2 activate none
		$m2 activate $tmp
		return
	    }
	}
    }
    set m2 [winfo parent $menu]
    if {[string equal [winfo class $m2] "Menu"]} then {
	if {[string equal [$m2 cget -type] "menubar"]} then {
	    tk_menuSetFocus $m2
	    tkMenuNextEntry $m2 -1
	    return
	}
    }
    set w $tkPriv(postedMb)
    if {[string equal $w ""]} then {
	return
    }
    set buttons [winfo children [winfo parent $w]]
    set length [llength $buttons]
    set i [expr {[lsearch -exact $buttons $w] + $count}]
    while {1} {
	while {$i < 0} {
	    incr i $length
	}
	while {$i >= $length} {
	    incr i -$length
	}
	set mb [lindex $buttons $i]
	if {[string equal [winfo class $mb] "Menubutton"] && [string compare [$mb cget -state] "disabled"] && [string compare [$mb cget -menu] ""] && [string compare [[$mb cget -menu] index last] "none"]} then {
	    break
	}
	if {[string equal $mb $w]} then {
	    return
	}
	incr i $count
    }
    tkMbPost $mb
    tkMenuFirstEntry [$mb cget -menu]
}
proc tkMenuNextEntry {menu count} {
    global tkPriv
    if {[string equal [$menu index last] "none"]} then {
	return
    }
    set length [expr {[$menu index last]+1}]
    set quitAfter $length
    set active [$menu index active]
    if {[string equal $active "none"]} then {
	set i 0
    } else {
	set i [expr {$active + $count}]
    }
    while {1} {
	if {$quitAfter <= 0} then {
	    return
	}
	while {$i < 0} {
	    incr i $length
	}
	while {$i >= $length} {
	    incr i -$length
	}
	if {[catch {$menu entrycget $i -state} state] == 0} then {
	    if {[string compare $state "disabled"]} then {
		break
	    }
	}
	if {$i == $active} then {
	    return
	}
	incr i $count
	incr quitAfter -1
    }
    $menu activate $i
    tkGenerateMenuSelect $menu
    if {[string equal [$menu type $i] "cascade"]} then {
	set cascade [$menu entrycget $i -menu]
	if {[string compare $cascade ""]} then {
	    $menu postcascade $i
	    tkMenuFirstEntry $cascade
	}
    }
}
proc tkMenuFind {w char} {
    global tkPriv
    set char [string tolower $char]
    set windowlist [winfo child $w]
    foreach child $windowlist {
	if {[string compare [winfo toplevel [focus]] [winfo toplevel $child]]} then {
	    continue
	}
	if {[string equal [winfo class $child] "Menu"] && [string equal [$child cget -type] "menubar"]} then {
	    if {[string equal $char ""]} then {
		return $child
	    }
	    set last [$child index last]
	    for {set i [$child cget -tearoff]} {$i <= $last} {incr i} {
		if {[string equal [$child type $i] "separator"]} then {
		    continue
		}
		set char2 [string index [$child entrycget $i -label] [$child entrycget $i -underline]]
		if {[string equal $char [string tolower $char2]] || [string equal $char ""]} then {
		    if {[string compare [$child entrycget $i -state] "disabled"]} then {
			return $child
		    }
		}
	    }
	}
    }
    foreach child $windowlist {
	if {[string compare [winfo toplevel [focus]] [winfo toplevel $child]]} then {
	    continue
	}
	switch [winfo class $child] {
	Menubutton {
		set char2 [string index [$child cget -text] [$child cget -underline]]
		if {[string equal $char [string tolower $char2]] || [string equal $char ""]} then {
		    if {[string compare [$child cget -state] "disabled"]} then {
			return $child
		    }
		}
	    }
	default {
		set match [tkMenuFind $child $char]
		if {[string compare $match ""]} then {
		    return $match
		}
	    }
	}
    }
    return {}
}
proc tkTraverseToMenu {w char} {
    global tkPriv
    if {[string equal $char ""]} then {
	return
    }
    while {[string equal [winfo class $w] "Menu"]} {
	if {[string compare [$w cget -type] "menubar"] && [string equal $tkPriv(postedMb) ""]} then {
	    return
	}
	if {[string equal [$w cget -type] "menubar"]} then {
	    break
	}
	set w [winfo parent $w]
    }
    set w [tkMenuFind [winfo toplevel $w] $char]
    if {[string compare $w ""]} then {
	if {[string equal [winfo class $w] "Menu"]} then {
	    tk_menuSetFocus $w
	    set tkPriv(window) $w
	    tkSaveGrabInfo $w
	    grab -global $w
	    tkTraverseWithinMenu $w $char
	} else {
	    tkMbPost $w
	    tkMenuFirstEntry [$w cget -menu]
	}
    }
}
proc tkFirstMenu w {
    set w [tkMenuFind [winfo toplevel $w] ""]
    if {[string compare $w ""]} then {
	if {[string equal [winfo class $w] "Menu"]} then {
	    tk_menuSetFocus $w
	    set tkPriv(window) $w
	    tkSaveGrabInfo $w
	    grab -global $w
	    tkMenuFirstEntry $w
	} else {
	    tkMbPost $w
	    tkMenuFirstEntry [$w cget -menu]
	}
    }
}
proc tkTraverseWithinMenu {w char} {
    if {[string equal $char ""]} then {
	return
    }
    set char [string tolower $char]
    set last [$w index last]
    if {[string equal $last "none"]} then {
	return
    }
    for {set i 0} {$i <= $last} {incr i} {
	if {[catch {set char2 [string index [$w entrycget $i -label] [$w entrycget $i -underline]]}]} then {
	    continue
	}
	if {[string equal $char [string tolower $char2]]} then {
	    if {[string equal [$w type $i] "cascade"]} then {
		$w activate $i
		$w postcascade active
		event generate $w <<MenuSelect>>
		set m2 [$w entrycget $i -menu]
		if {[string compare $m2 ""]} then {
		    tkMenuFirstEntry $m2
		}
	    } else {
		tkMenuUnpost $w
		uplevel #0 [list $w invoke $i]
	    }
	    return
	}
    }
}
proc tkMenuFirstEntry menu {
    if {[string equal $menu ""]} then {
	return
    }
    tk_menuSetFocus $menu
    if {[string compare [$menu index active] "none"]} then {
	return
    }
    set last [$menu index last]
    if {[string equal $last "none"]} then {
	return
    }
    for {set i 0} {$i <= $last} {incr i} {
	if {([catch {set state [$menu entrycget $i -state]}] == 0) && [string compare $state "disabled"] && [string compare [$menu type $i] "tearoff"]} then {
	    $menu activate $i
	    tkGenerateMenuSelect $menu
	    if {[string equal [$menu type $i] "cascade"] && [string equal [$menu cget -type] "menubar"]} then {
		set cascade [$menu entrycget $i -menu]
		if {[string compare $cascade ""]} then {
		    $menu postcascade $i
		    tkMenuFirstEntry $cascade
		}
	    }
	    return
	}
    }
}
proc tkMenuFindName {menu s} {
    set i ""
    if {![regexp {^active$|^last$|^none$|^[0-9]|^@} $s]} then {
	catch {set i [$menu index $s]}
	return $i
    }
    set last [$menu index last]
    if {[string equal $last "none"]} then {
	return
    }
    for {set i 0} {$i <= $last} {incr i} {
	if {![catch {$menu entrycget $i -label} label]} then {
	    if {[string equal $label $s]} then {
		return $i
	    }
	}
    }
    return ""
}
proc tkPostOverPoint {menu x y {entry {}}} {
    global tcl_platform
    if {[string compare $entry {}]} then {
	if {$entry == [$menu index last]} then {
	    incr y [expr {-([$menu yposition $entry] + [winfo reqheight $menu]) /2}]
	} else {
	    incr y [expr {-([$menu yposition $entry] + [$menu yposition [expr {$entry+1}]]) /2}]
	}
	incr x [expr {-[winfo reqwidth $menu]/2}]
    }
    $menu post $x $y
    if {[string compare $entry {}] && [string compare [$menu entrycget $entry -state] "disabled"]} then {
	$menu activate $entry
	tkGenerateMenuSelect $menu
    }
}
proc tkSaveGrabInfo w {
    global tkPriv
    set tkPriv(oldGrab) [grab current $w]
    if {[string compare $tkPriv(oldGrab) ""]} then {
	set tkPriv(grabStatus) [grab status $tkPriv(oldGrab)]
    }
}
proc tkRestoreOldGrab {} {
    global tkPriv
    if {[string compare $tkPriv(oldGrab) ""]} then {
	catch {
	    if {[string equal $tkPriv(grabStatus) "global"]} then {
		grab set -global $tkPriv(oldGrab)
	    } else {
		grab set $tkPriv(oldGrab)
	    }
	}
	set tkPriv(oldGrab) ""
    }
}
proc tk_menuSetFocus {menu} {
    global tkPriv
    if {![info exists tkPriv(focus)] || [string equal $tkPriv(focus) {}]} then {
	set tkPriv(focus) [focus]
    }
    focus $menu
}
proc tkGenerateMenuSelect {menu} {
    global tkPriv
    if {[string equal $tkPriv(activeMenu) $menu] && [string equal $tkPriv(activeItem) [$menu index active]]} then {
	return
    }
    set tkPriv(activeMenu) $menu
    set tkPriv(activeItem) [$menu index active]
    event generate $menu <<MenuSelect>>
}
proc tk_popup {menu x y {entry {}}} {
    global tkPriv
    global tcl_platform
    if {[string compare $tkPriv(popup) ""] || [string compare $tkPriv(postedMb) ""]} then {
	tkMenuUnpost {}
    }
    tkPostOverPoint $menu $x $y $entry
    if {[string equal $tcl_platform(platform) "unix"] && [winfo viewable $menu]} then {
	tkSaveGrabInfo $menu
	grab -global $menu
	set tkPriv(popup) $menu
	tk_menuSetFocus $menu
    }
}
namespace eval ::tk::dialog {}
image create bitmap ::tk::dialog::b1 -foreground black -data "#define b1_width 32\n#define b1_height 32
static unsigned char q1_bits[] = {
0x00, 0xf8, 0x1f, 0x00, 0x00, 0x07, 0xe0, 0x00, 0xc0, 0x00, 0x00, 0x03,
0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x10,
0x04, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40,
0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
0x01, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40,
0x04, 0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x08,
0x60, 0x00, 0x00, 0x04, 0x80, 0x03, 0x80, 0x03, 0x00, 0x0c, 0x78, 0x00,
0x00, 0x30, 0x04, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x40, 0x04, 0x00,
0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};"
image create bitmap ::tk::dialog::b2 -foreground white -data "#define b2_width 32\n#define b2_height 32
static unsigned char b2_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x00,
0xc0, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x0f,
0xf8, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0x3f,
0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
0xfe, 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0x3f,
0xf8, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0x07,
0x80, 0xff, 0xff, 0x03, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xf0, 0x07, 0x00,
0x00, 0xc0, 0x03, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x80, 0x03, 0x00,
0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};"
image create bitmap ::tk::dialog::q -foreground blue -data "#define q_width 32\n#define q_height 32
static unsigned char q_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00,
0x00, 0x10, 0x0f, 0x00, 0x00, 0x18, 0x1e, 0x00, 0x00, 0x38, 0x1e, 0x00,
0x00, 0x38, 0x1e, 0x00, 0x00, 0x10, 0x0f, 0x00, 0x00, 0x80, 0x07, 0x00,
0x00, 0xc0, 0x01, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x00,
0x00, 0xe0, 0x01, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};"
image create bitmap ::tk::dialog::i -foreground blue -data "#define i_width 32\n#define i_height 32
static unsigned char i_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xe0, 0x01, 0x00, 0x00, 0xf0, 0x03, 0x00, 0x00, 0xf0, 0x03, 0x00,
0x00, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xf8, 0x03, 0x00, 0x00, 0xf0, 0x03, 0x00, 0x00, 0xe0, 0x03, 0x00,
0x00, 0xe0, 0x03, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xe0, 0x03, 0x00,
0x00, 0xe0, 0x03, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf0, 0x07, 0x00,
0x00, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};"
image create bitmap ::tk::dialog::w1 -foreground black -data "#define w1_width 32\n#define w1_height 32
static unsigned char w1_bits[] = {
0x00, 0x80, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x20, 0x04, 0x00,
0x00, 0x10, 0x04, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x08, 0x08, 0x00,
0x00, 0x08, 0x10, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x04, 0x20, 0x00,
0x00, 0x02, 0x20, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00,
0x00, 0x01, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x01,
0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x02,
0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x08,
0x08, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x10,
0x04, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 0x40,
0x01, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x20,
0xfc, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00};"
image create bitmap ::tk::dialog::w2 -foreground yellow -data "#define w2_width 32\n#define w2_height 32
static unsigned char w2_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0xc0, 0x03, 0x00,
0x00, 0xe0, 0x03, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xf0, 0x07, 0x00,
0x00, 0xf0, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x1f, 0x00,
0x00, 0xfc, 0x1f, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0xfe, 0x3f, 0x00,
0x00, 0xfe, 0x7f, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0xff, 0xff, 0x00,
0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x01, 0xc0, 0xff, 0xff, 0x01,
0xc0, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0x07,
0xf0, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 0x0f,
0xf8, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0x3f,
0xfe, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0x1f,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};"
image create bitmap ::tk::dialog::w3 -foreground black -data "#define w3_width 32\n#define w3_height 32
static unsigned char w3_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xc0, 0x03, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
0x00, 0xc0, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00,
0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0xc0, 0x03, 0x00,
0x00, 0xc0, 0x03, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};"
proc tkMessageBox {args} {
    global tkPriv tcl_platform tk_strictMotif
    set w tkPrivMsgBox
    upvar #0 $w data
    set specs {
{-default "" "" ""}
{-icon "" "" "info"}
{-message "" "" ""}
{-parent "" "" .}
{-title "" "" " "}
{-type "" "" "ok"}
}
    tclParseConfigSpec $w $specs "" $args
    if {[lsearch -exact {info warning error question} $data(-icon)] == -1} then {
	error "bad -icon value \"$data(-icon)\": must be error, info, question, or warning"
    }
    if {[string equal $tcl_platform(platform) "macintosh"]} then {
	switch -- $data(-icon) {
	"error" {
		set data(-icon) "stop"
	    }
	"warning" {
		set data(-icon) "caution"
	    }
	"info" {
		set data(-icon) "note"
	    }
	}
    }
    if {![winfo exists $data(-parent)]} then {
	error "bad window path name \"$data(-parent)\""
    }
    switch -- $data(-type) {
    abortretryignore {
	    set buttons {
{abort  -width 6 -text Abort -under 0}
{retry  -width 6 -text Retry -under 0}
{ignore -width 6 -text Ignore -under 0}
}
	}
    ok {
	    set buttons {
{ok -width 6 -text OK -under 0}
}
	    if {[string equal $data(-default) ""]} then {
		set data(-default) "ok"
	    }
	}
    okcancel {
	    set buttons {
{ok     -width 6 -text OK     -under 0}
{cancel -width 6 -text Cancel -under 0}
}
	}
    retrycancel {
	    set buttons {
{retry  -width 6 -text Retry  -under 0}
{cancel -width 6 -text Cancel -under 0}
}
	}
    yesno {
	    set buttons {
{yes    -width 6 -text Yes -under 0}
{no     -width 6 -text No  -under 0}
}
	}
    yesnocancel {
	    set buttons {
{yes    -width 6 -text Yes -under 0}
{no     -width 6 -text No  -under 0}
{cancel -width 6 -text Cancel -under 0}
}
	}
    default {
	    error "bad -type value \"$data(-type)\": must be abortretryignore, ok, okcancel, retrycancel, yesno, or yesnocancel"
	}
    }
    if {[string compare $data(-default) ""]} then {
	set valid 0
	foreach btn $buttons {
	    if {[string equal [lindex $btn 0] $data(-default)]} then {
		set valid 1
		break
	    }
	}
	if {!$valid} then {
	    error "invalid default button \"$data(-default)\""
	}
    }
    if {[string compare $data(-parent) .]} then {
	set w $data(-parent).__tk__messagebox
    } else {
	set w .__tk__messagebox
    }
    catch {destroy $w}
    toplevel $w -class Dialog
    wm title $w $data(-title)
    wm iconname $w Dialog
    wm protocol $w WM_DELETE_WINDOW { }
    if {[winfo viewable [winfo toplevel $data(-parent)]]} then {
	wm transient $w $data(-parent)
    }
    if {[string equal $tcl_platform(platform) "macintosh"]} then {
	unsupported1 style $w dBoxProc
    }
    frame $w.bot
    pack $w.bot -side bottom -fill both
    frame $w.top
    pack $w.top -side top -fill both -expand 1
    if {[string compare $tcl_platform(platform) "macintosh"]} then {
	$w.bot configure -relief raised -bd 1
	$w.top configure -relief raised -bd 1
    }
    option add *Dialog.msg.wrapLength 3i widgetDefault
    if {[string equal $tcl_platform(platform) "macintosh"]} then {
	option add *Dialog.msg.font system widgetDefault
    } else {
	option add *Dialog.msg.font {Times 18} widgetDefault
    }
    label $w.msg -anchor nw -justify left -text $data(-message)
    if {[string compare $data(-icon) ""]} then {
	if {[string equal $tcl_platform(platform) "macintosh"] ||([winfo depth $w] < 4) || $tk_strictMotif} then {
	    label $w.bitmap -bitmap $data(-icon)
	} else {
	    canvas $w.bitmap -width 32 -height 32 -highlightthickness 0
	    switch $data(-icon) {
	    error {
		    $w.bitmap create oval 0 0 31 31 -fill red -outline black
		    $w.bitmap create line 9 9 23 23 -fill white -width 4
		    $w.bitmap create line 9 23 23 9 -fill white -width 4
		}
	    info {
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::b1
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::b2
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::i
		}
	    question {
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::b1
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::b2
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::q
		}
	    default {
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::w1
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::w2
		    $w.bitmap create image 0 0 -anchor nw -image ::tk::dialog::w3
		}
	    }
	}
    }
    grid $w.bitmap $w.msg -in $w.top -sticky news -padx 2m -pady 2m
    grid columnconfigure $w.top 1 -weight 1
    grid rowconfigure $w.top 0 -weight 1
    set i 0
    foreach but $buttons {
	set name [lindex $but 0]
	set opts [lrange $but 1 end]
	if {![llength $opts]} then {
	    set capName [string toupper $name 0]
	    set opts [list -text $capName]
	}
	eval button [list $w.$name] $opts [list -command [list set tkPriv(button) $name]]
	if {[string equal $name $data(-default)]} then {
	    $w.$name configure -default active
	}
	pack $w.$name -in $w.bot -side left -expand 1 -padx 3m -pady 2m
	set underIdx [$w.$name cget -under]
	if {$underIdx >= 0} then {
	    set key [string index [$w.$name cget -text] $underIdx]
	    bind $w <Alt-[string tolower $key]> [list $w.$name invoke]
	    bind $w <Alt-[string toupper $key]> [list $w.$name invoke]
	}
	incr i
    }
    if {[string compare {} $data(-default)]} then {
	bind $w <FocusIn> {
	    if {[string equal Button [winfo class %W]]} then {
		%W configure -default active
	    }
	}
	bind $w <FocusOut> {
	    if {[string equal Button [winfo class %W]]} then {
		%W configure -default normal
	    }
	}
    }
    bind $w <Return> {
	if {[string equal Button [winfo class %W]]} then {
	    tkButtonInvoke %W
	}
    }
    ::tk::PlaceWindow $w widget $data(-parent)
    if {[string compare $data(-default) ""]} then {
	set focus $w.$data(-default)
    } else {
	set focus $w
    }
    ::tk::SetFocusGrab $w $focus
    tkwait variable tkPriv(button)
    ::tk::RestoreFocusGrab $w $focus
    return $tkPriv(button)
}
proc tk_menuBar args { }
proc tk_bindForTraversal args { }
proc tk_optionMenu {w varName firstValue args} {
    upvar #0 $varName var
    if {![info exists var]} then {
	set var $firstValue
    }
    menubutton $w -textvariable $varName -indicatoron 1 -menu $w.menu -relief raised -bd 2 -highlightthickness 2 -anchor c -direction flush
    menu $w.menu -tearoff 0
    $w.menu add radiobutton -label $firstValue -variable $varName
    foreach i $args {
	$w.menu add radiobutton -label $i -variable $varName
    }
    return $w.menu
}
proc tk_setPalette {args} {
    if {[winfo depth .] == 1} then {
	return
    }
    global tkPalette
    if {[llength $args] == 1} then {
	set new(background) [lindex $args 0]
    } else {
	array set new $args
    }
    if {![info exists new(background)]} then {
	error "must specify a background color"
    }
    if {![info exists new(foreground)]} then {
	set new(foreground) black
    }
    set bg [winfo rgb . $new(background)]
    set fg [winfo rgb . $new(foreground)]
    set darkerBg [format #%02x%02x%02x [expr {(9*[lindex $bg 0]) /2560}] [expr {(9*[lindex $bg 1]) /2560}] [expr {(9*[lindex $bg 2]) /2560}]]
    foreach i {activeForeground insertBackground selectForeground highlightColor} {
	if {![info exists new($i)]} then {
	    set new($i) $new(foreground)
	}
    }
    if {![info exists new(disabledForeground)]} then {
	set new(disabledForeground) [format #%02x%02x%02x [expr {(3*[lindex $bg 0] + [lindex $fg 0]) /1024}] [expr {(3*[lindex $bg 1] + [lindex $fg 1]) /1024}] [expr {(3*[lindex $bg 2] + [lindex $fg 2]) /1024}]]
    }
    if {![info exists new(highlightBackground)]} then {
	set new(highlightBackground) $new(background)
    }
    if {![info exists new(activeBackground)]} then {
	foreach i {0 1 2} {
	    set light($i) [expr {[lindex $bg $i]/256}]
	    set inc1 [expr {($light($i)*15) /100}]
	    set inc2 [expr {(255-$light($i)) /3}]
	    if {$inc1 > $inc2} then {
		incr light($i) $inc1
	    } else {
		incr light($i) $inc2
	    }
	    if {$light($i) > 255} then {
		set light($i) 255
	    }
	}
	set new(activeBackground) [format #%02x%02x%02x $light(0) $light(1) $light(2)]
    }
    if {![info exists new(selectBackground)]} then {
	set new(selectBackground) $darkerBg
    }
    if {![info exists new(troughColor)]} then {
	set new(troughColor) $darkerBg
    }
    if {![info exists new(selectColor)]} then {
	set new(selectColor) #b03060
    }
    toplevel .___tk_set_palette
    wm withdraw .___tk_set_palette
    foreach q {button canvas checkbutton entry frame label listbox menubutton menu message radiobutton scale scrollbar text} {
	$q .___tk_set_palette.$q
    }
    eval [tkRecolorTree . new]
    catch {destroy .___tk_set_palette}
    foreach option [array names new] {
	option add *$option $new($option) widgetDefault
    }
    array set tkPalette [array get new]
}
proc tkRecolorTree {w colors} {
    global tkPalette
    upvar $colors c
    set result {}
    foreach dbOption [array names c] {
	set option -[string tolower $dbOption]
	if {![catch {$w config $option} value]} then {
	    set defaultcolor [option get $w $dbOption widgetDefault]
	    if {[string match {} $defaultcolor]} then {
		set defaultcolor [winfo rgb . [lindex $value 3]]
	    } else {
		set defaultcolor [winfo rgb . $defaultcolor]
	    }
	    set chosencolor [winfo rgb . [lindex $value 4]]
	    if {[string match $defaultcolor $chosencolor]} then {
		append result ";\noption add [list *[winfo class $w].$dbOption $c($dbOption) 60]"
		$w configure $option $c($dbOption)
	    }
	}
    }
    foreach child [winfo children $w] {
	append result ";\n[tkRecolorTree $child c]"
    }
    return $result
}
proc tkDarken {color percent} {
    foreach {red green blue} [winfo rgb . $color] {
	set red [expr {($red/256) *$percent/100}]
	set green [expr {($green/256) *$percent/100}]
	set blue [expr {($blue/256) *$percent/100}]
	break
    }
    if {$red > 255} then {
	set red 255
    }
    if {$green > 255} then {
	set green 255
    }
    if {$blue > 255} then {
	set blue 255
    }
    return [format "#%02x%02x%02x" $red $green $blue]
}
proc tk_bisque {} {
    tk_setPalette activeBackground #e6ceb1 activeForeground black background #ffe4c4 disabledForeground #b0b0b0 foreground black highlightBackground #ffe4c4 highlightColor black insertBackground black selectColor #b03060 selectBackground #e6ceb1 selectForeground black troughColor #cdb79e
}
package require opt 0.4.1

namespace eval ::safe {
    variable tkSafeId 0

    proc ::safe::tkInterpInit {slave argv} {
	global env tk_library
	allowTk $slave $argv
	::interp eval $slave [list set tk_library [::safe::interpAddToAccessPath $slave $tk_library]]
	return $slave
    }
    proc ::safe::loadTk {} {}
    ::tcl::OptProc loadTk {
{slave -interp "name of the slave interpreter"}
{-use  -windowId {} "window Id to use (new toplevel otherwise)"}
{-display -displayName {} "display name to use (current one otherwise)"}
} {
set displayGiven [::tcl::OptProcArgGiven "-display"]
if {!$displayGiven} {
if {[catch {set display [winfo screen .]}]} {
if {[info exists ::env(DISPLAY)]} {
set display $::env(DISPLAY)
} else {
Log $slave "no winfo screen . nor env(DISPLAY)" WARNING
set display ":0.0"
}
}
}
if {![::tcl::OptProcArgGiven "-use"]} {
::tcl::Lassign [tkTopLevel $slave $display] w use
Set [DeleteHookName $slave] [list tkDelete {} $w]
} else {
Set [DeleteHookName $slave] [list disallowTk]
if {[string match ".*" $use]} {
set windowName $use
set use [winfo id $windowName]
set nDisplay [winfo screen $windowName]
} else {
if {![catch {winfo pathname $use} name]} {
set nDisplay [winfo screen $name]
} else {
set nDisplay $display
}
}
if {[string compare $nDisplay $display]} {
if {$displayGiven} {
error "conflicting -display $display and -use\
			$use -> $nDisplay"
} else {
set display $nDisplay
}
}
}
tkInterpInit $slave [list "-use" $use "-display" $display]
load {} Tk $slave
return $slave
}
    proc ::safe::TkInit {interpPath} {
	variable tkInit
	if {[info exists tkInit($interpPath)]} then {
	    set value $tkInit($interpPath)
	    Log $interpPath "TkInit called, returning \"$value\"" NOTICE
	    return $value
	} else {
	    Log $interpPath "TkInit called for interp with clearance: preventing Tk init" ERROR
	    error "not allowed"
	}
    }
    proc ::safe::allowTk {interpPath argv} {
	variable tkInit
	set tkInit($interpPath) $argv
	return
    }
    proc ::safe::disallowTk {interpPath} {
	variable tkInit
	if {[info exists tkInit($interpPath)]} then {
	    unset tkInit($interpPath)
	}
	return
    }
    proc ::safe::tkDelete {W window slave} {
	Log $slave "Called tkDelete $W $window" NOTICE
	if {[::interp exists $slave]} then {
	    if {[catch {::safe::interpDelete $slave} msg]} then {
		Log $slave "Deletion error : $msg"
	    }
	}
	if {[winfo exists $window]} then {
	    Log $slave "Destroy toplevel $window" NOTICE
	    destroy $window
	}
	disallowTk $slave
	return
    }
    proc ::safe::tkTopLevel {slave display} {
	variable tkSafeId
	incr tkSafeId
	set w ".safe$tkSafeId"
	if {[catch {toplevel $w -screen $display -class SafeTk} msg]} then {
	    return -code error "Unable to create toplevel for safe slave \"$slave\" ($msg)"
	}
	Log $slave "New toplevel $w" NOTICE
	set msg "Untrusted Tcl applet ($slave)"
	wm title $w $msg
	set wc $w.fc
	frame $wc -bg red -borderwidth 3 -relief ridge
	bindtags $wc [concat Safe$wc [bindtags $wc]]
	bind Safe$wc <Destroy> [list ::safe::tkDelete %W $w $slave]
	label $wc.l -text $msg -padx 2 -pady 0 -anchor w
	frame $wc.fb -bd 0
	button $wc.fb.b -text "Delete" -bd 1 -padx 2 -pady 0 -highlightthickness 0 -command [list ::safe::tkDelete $w $w $slave]
	pack $wc.fb.b -side right -fill both
	pack $wc.fb -side right -fill both -expand 1
	pack $wc.l -side left -fill both -expand 1
	pack $wc -side bottom -fill x
	frame $w.c -container 1
	pack $w.c -fill both -expand 1
	list $w [winfo id $w.c]
    }
}
bind Scale <Enter> {
    if {$tk_strictMotif} then {
	set tkPriv(activeBg) [%W cget -activebackground]
	%W config -activebackground [%W cget -background]
    }
    tkScaleActivate %W %x %y
}
bind Scale <Motion> {
    tkScaleActivate %W %x %y
}
bind Scale <Leave> {
    if {$tk_strictMotif} then {
	%W config -activebackground $tkPriv(activeBg)
    }
    if {[string equal [%W cget -state] "active"]} then {
	%W configure -state normal
    }
}
bind Scale <1> {
    tkScaleButtonDown %W %x %y
}
bind Scale <B1-Motion> {
    tkScaleDrag %W %x %y
}
bind Scale <B1-Leave> {}
bind Scale <B1-Enter> {}
bind Scale <ButtonRelease-1> {
    tkCancelRepeat
    tkScaleEndDrag %W
    tkScaleActivate %W %x %y
}
bind Scale <2> {
    tkScaleButton2Down %W %x %y
}
bind Scale <B2-Motion> {
    tkScaleDrag %W %x %y
}
bind Scale <B2-Leave> {}
bind Scale <B2-Enter> {}
bind Scale <ButtonRelease-2> {
    tkCancelRepeat
    tkScaleEndDrag %W
    tkScaleActivate %W %x %y
}
bind Scale <Control-1> {
    tkScaleControlPress %W %x %y
}
bind Scale <Up> {
    tkScaleIncrement %W up little noRepeat
}
bind Scale <Down> {
    tkScaleIncrement %W down little noRepeat
}
bind Scale <Left> {
    tkScaleIncrement %W up little noRepeat
}
bind Scale <Right> {
    tkScaleIncrement %W down little noRepeat
}
bind Scale <Control-Up> {
    tkScaleIncrement %W up big noRepeat
}
bind Scale <Control-Down> {
    tkScaleIncrement %W down big noRepeat
}
bind Scale <Control-Left> {
    tkScaleIncrement %W up big noRepeat
}
bind Scale <Control-Right> {
    tkScaleIncrement %W down big noRepeat
}
bind Scale <Home> {
    %W set [%W cget -from]
}
bind Scale <End> {
    %W set [%W cget -to]
}
proc tkScaleActivate {w x y} {
    if {[string equal [$w cget -state] "disabled"]} then {
	return
    }
    if {[string equal [$w identify $x $y] "slider"]} then {
	set state active
    } else {
	set state normal
    }
    if {[string compare [$w cget -state] $state]} then {
	$w configure -state $state
    }
}
proc tkScaleButtonDown {w x y} {
    global tkPriv
    set tkPriv(dragging) 0
    set el [$w identify $x $y]
    if {[string equal $el "trough1"]} then {
	tkScaleIncrement $w up little initial
    } elseif {[string equal $el "trough2"]} {
	tkScaleIncrement $w down little initial
    } elseif {[string equal $el "slider"]} {
	set tkPriv(dragging) 1
	set tkPriv(initValue) [$w get]
	set coords [$w coords]
	set tkPriv(deltaX) [expr {$x - [lindex $coords 0]}]
	set tkPriv(deltaY) [expr {$y - [lindex $coords 1]}]
	$w configure -sliderrelief sunken
    }
}
proc tkScaleDrag {w x y} {
    global tkPriv
    if {!$tkPriv(dragging)} then {
	return
    }
    $w set [$w get [expr {$x-$tkPriv(deltaX)}] [expr {$y-$tkPriv(deltaY)}]]
}
proc tkScaleEndDrag {w} {
    global tkPriv
    set tkPriv(dragging) 0
    $w configure -sliderrelief raised
}
proc tkScaleIncrement {w dir big repeat} {
    global tkPriv
    if {![winfo exists $w]} then return
    if {[string equal $big "big"]} then {
	set inc [$w cget -bigincrement]
	if {$inc == 0} then {
	    set inc [expr {abs([$w cget -to] - [$w cget -from]) /10.0}]
	}
	if {$inc < [$w cget -resolution]} then {
	    set inc [$w cget -resolution]
	}
    } else {
	set inc [$w cget -resolution]
    }
    if {([$w cget -from] > [$w cget -to]) ^ [string equal $dir "up"]} then {
	set inc [expr {-$inc}]
    }
    $w set [expr {[$w get] + $inc}]
    if {[string equal $repeat "again"]} then {
	set tkPriv(afterId) [after [$w cget -repeatinterval] [list tkScaleIncrement $w $dir $big again]]
    } elseif {[string equal $repeat "initial"]} {
	set delay [$w cget -repeatdelay]
	if {$delay > 0} then {
	    set tkPriv(afterId) [after $delay [list tkScaleIncrement $w $dir $big again]]
	}
    }
}
proc tkScaleControlPress {w x y} {
    set el [$w identify $x $y]
    if {[string equal $el "trough1"]} then {
	$w set [$w cget -from]
    } elseif {[string equal $el "trough2"]} {
	$w set [$w cget -to]
    }
}
proc tkScaleButton2Down {w x y} {
    global tkPriv
    if {[string equal [$w cget -state] "disabled"]} then {
	return
    }
    $w configure -state active
    $w set [$w get $x $y]
    set tkPriv(dragging) 1
    set tkPriv(initValue) [$w get]
    set coords "$x $y"
    set tkPriv(deltaX) 0
    set tkPriv(deltaY) 0
}
if {[string compare $tcl_platform(platform) "windows"] && [string compare $tcl_platform(platform) "macintosh"]} then {
    bind Scrollbar <Enter> {
	if {$tk_strictMotif} then {
	    set tkPriv(activeBg) [%W cget -activebackground]
	    %W config -activebackground [%W cget -background]
	}
	%W activate [%W identify %x %y]
    }
    bind Scrollbar <Motion> {
	%W activate [%W identify %x %y]
    }
    bind Scrollbar <Leave> {
	if {$tk_strictMotif && [info exists tkPriv(activeBg)]} then {
	    %W config -activebackground $tkPriv(activeBg)
	}
	%W activate {}
    }
    bind Scrollbar <1> {
	tkScrollButtonDown %W %x %y
    }
    bind Scrollbar <B1-Motion> {
	tkScrollDrag %W %x %y
    }
    bind Scrollbar <B1-B2-Motion> {
	tkScrollDrag %W %x %y
    }
    bind Scrollbar <ButtonRelease-1> {
	tkScrollButtonUp %W %x %y
    }
    bind Scrollbar <B1-Leave> {
    }
    bind Scrollbar <B1-Enter> {
    }
    bind Scrollbar <2> {
	tkScrollButton2Down %W %x %y
    }
    bind Scrollbar <B1-2> {
    }
    bind Scrollbar <B2-1> {
    }
    bind Scrollbar <B2-Motion> {
	tkScrollDrag %W %x %y
    }
    bind Scrollbar <ButtonRelease-2> {
	tkScrollButtonUp %W %x %y
    }
    bind Scrollbar <B1-ButtonRelease-2> {
    }
    bind Scrollbar <B2-ButtonRelease-1> {
    }
    bind Scrollbar <B2-Leave> {
    }
    bind Scrollbar <B2-Enter> {
    }
    bind Scrollbar <Control-1> {
	tkScrollTopBottom %W %x %y
    }
    bind Scrollbar <Control-2> {
	tkScrollTopBottom %W %x %y
    }
    bind Scrollbar <Up> {
	tkScrollByUnits %W v -1
    }
    bind Scrollbar <Down> {
	tkScrollByUnits %W v 1
    }
    bind Scrollbar <Control-Up> {
	tkScrollByPages %W v -1
    }
    bind Scrollbar <Control-Down> {
	tkScrollByPages %W v 1
    }
    bind Scrollbar <Left> {
	tkScrollByUnits %W h -1
    }
    bind Scrollbar <Right> {
	tkScrollByUnits %W h 1
    }
    bind Scrollbar <Control-Left> {
	tkScrollByPages %W h -1
    }
    bind Scrollbar <Control-Right> {
	tkScrollByPages %W h 1
    }
    bind Scrollbar <Prior> {
	tkScrollByPages %W hv -1
    }
    bind Scrollbar <Next> {
	tkScrollByPages %W hv 1
    }
    bind Scrollbar <Home> {
	tkScrollToPos %W 0
    }
    bind Scrollbar <End> {
	tkScrollToPos %W 1
    }
}
proc tkScrollButtonDown {w x y} {
    global tkPriv
    set tkPriv(relief) [$w cget -activerelief]
    $w configure -activerelief sunken
    set element [$w identify $x $y]
    if {[string equal $element "slider"]} then {
	tkScrollStartDrag $w $x $y
    } else {
	tkScrollSelect $w $element initial
    }
}
proc tkScrollButtonUp {w x y} {
    global tkPriv
    tkCancelRepeat
    if {[info exists tkPriv(relief)]} then {
	$w configure -activerelief $tkPriv(relief)
	tkScrollEndDrag $w $x $y
	$w activate [$w identify $x $y]
    }
}
proc tkScrollSelect {w element repeat} {
    global tkPriv
    if {![winfo exists $w]} then return
    switch -- $element {
    "arrow1" {
	    tkScrollByUnits $w hv -1
	}
    "trough1" {
	    tkScrollByPages $w hv -1
	}
    "trough2" {
	    tkScrollByPages $w hv 1
	}
    "arrow2" {
	    tkScrollByUnits $w hv 1
	}
    default {
	    return
	}
    }
    if {[string equal $repeat "again"]} then {
	set tkPriv(afterId) [after [$w cget -repeatinterval] [list tkScrollSelect $w $element again]]
    } elseif {[string equal $repeat "initial"]} {
	set delay [$w cget -repeatdelay]
	if {$delay > 0} then {
	    set tkPriv(afterId) [after $delay [list tkScrollSelect $w $element again]]
	}
    }
}
proc tkScrollStartDrag {w x y} {
    global tkPriv
    if {[string equal [$w cget -command] ""]} then {
	return
    }
    set tkPriv(pressX) $x
    set tkPriv(pressY) $y
    set tkPriv(initValues) [$w get]
    set iv0 [lindex $tkPriv(initValues) 0]
    if {[llength $tkPriv(initValues)] == 2} then {
	set tkPriv(initPos) $iv0
    } elseif {$iv0 == 0} {
	set tkPriv(initPos) 0.0
    } else {
	set tkPriv(initPos) [expr {(double([lindex $tkPriv(initValues) 2])) / [lindex $tkPriv(initValues) 0]}]
    }
}
proc tkScrollDrag {w x y} {
    global tkPriv
    if {[string equal $tkPriv(initPos) ""]} then {
	return
    }
    set delta [$w delta [expr {$x - $tkPriv(pressX)}] [expr {$y - $tkPriv(pressY)}]]
    if {[$w cget -jump]} then {
	if {[llength $tkPriv(initValues)] == 2} then {
	    $w set [expr {[lindex $tkPriv(initValues) 0] + $delta}] [expr {[lindex $tkPriv(initValues) 1] + $delta}]
	} else {
	    set delta [expr {round($delta * [lindex $tkPriv(initValues) 0])}]
	    eval [list $w] set [lreplace $tkPriv(initValues) 2 3 [expr {[lindex $tkPriv(initValues) 2] + $delta}] [expr {[lindex $tkPriv(initValues) 3] + $delta}]]
	}
    } else {
	tkScrollToPos $w [expr {$tkPriv(initPos) + $delta}]
    }
}
proc tkScrollEndDrag {w x y} {
    global tkPriv
    if {[string equal $tkPriv(initPos) ""]} then {
	return
    }
    if {[$w cget -jump]} then {
	set delta [$w delta [expr {$x - $tkPriv(pressX)}] [expr {$y - $tkPriv(pressY)}]]
	tkScrollToPos $w [expr {$tkPriv(initPos) + $delta}]
    }
    set tkPriv(initPos) ""
}
proc tkScrollByUnits {w orient amount} {
    set cmd [$w cget -command]
    if {[string equal $cmd ""] ||([string first [string index [$w cget -orient] 0] $orient] < 0)} then {
	return
    }
    set info [$w get]
    if {[llength $info] == 2} then {
	uplevel #0 $cmd scroll $amount units
    } else {
	uplevel #0 $cmd [expr {[lindex $info 2] + $amount}]
    }
}
proc tkScrollByPages {w orient amount} {
    set cmd [$w cget -command]
    if {[string equal $cmd ""] ||([string first [string index [$w cget -orient] 0] $orient] < 0)} then {
	return
    }
    set info [$w get]
    if {[llength $info] == 2} then {
	uplevel #0 $cmd scroll $amount pages
    } else {
	uplevel #0 $cmd [expr {[lindex $info 2] + $amount*([lindex $info 1] - 1)}]
    }
}
proc tkScrollToPos {w pos} {
    set cmd [$w cget -command]
    if {[string equal $cmd ""]} then {
	return
    }
    set info [$w get]
    if {[llength $info] == 2} then {
	uplevel #0 $cmd moveto $pos
    } else {
	uplevel #0 $cmd [expr {round([lindex $info 0]*$pos)}]
    }
}
proc tkScrollTopBottom {w x y} {
    global tkPriv
    set element [$w identify $x $y]
    if {[string match *1 $element]} then {
	tkScrollToPos $w 0
    } elseif {[string match *2 $element]} {
	tkScrollToPos $w 1
    }
    set tkPriv(relief) [$w cget -activerelief]
}
proc tkScrollButton2Down {w x y} {
    global tkPriv
    set element [$w identify $x $y]
    if {[string match {arrow[12]} $element]} then {
	tkScrollButtonDown $w $x $y
	return
    }
    tkScrollToPos $w [$w fraction $x $y]
    set tkPriv(relief) [$w cget -activerelief]
    update idletasks
    $w configure -activerelief sunken
    $w activate slider
    tkScrollStartDrag $w $x $y
}
# Tcl autoload index file, version 2.0
# This file is generated by the "auto_mkindex" command
# and sourced to set up indexing information for one or
# more commands.  Typically each line is a command that
# sets an element in the auto_index array, where the
# element name is the name of a command and the value is
# a script that loads the command.

set auto_index(tkButtonEnter) [list source [file join $dir button.tcl]]
set auto_index(tkButtonLeave) [list source [file join $dir button.tcl]]
set auto_index(tkCheckRadioEnter) [list source [file join $dir button.tcl]]
set auto_index(tkButtonDown) [list source [file join $dir button.tcl]]
set auto_index(tkCheckRadioDown) [list source [file join $dir button.tcl]]
set auto_index(tkButtonUp) [list source [file join $dir button.tcl]]
set auto_index(tkButtonEnter) [list source [file join $dir button.tcl]]
set auto_index(tkButtonLeave) [list source [file join $dir button.tcl]]
set auto_index(tkButtonDown) [list source [file join $dir button.tcl]]
set auto_index(tkButtonUp) [list source [file join $dir button.tcl]]
set auto_index(tkButtonEnter) [list source [file join $dir button.tcl]]
set auto_index(tkButtonLeave) [list source [file join $dir button.tcl]]
set auto_index(tkButtonDown) [list source [file join $dir button.tcl]]
set auto_index(tkButtonUp) [list source [file join $dir button.tcl]]
set auto_index(tkButtonInvoke) [list source [file join $dir button.tcl]]
set auto_index(tkCheckRadioInvoke) [list source [file join $dir button.tcl]]
set auto_index(tk_dialog) [list source [file join $dir dialog.tcl]]
set auto_index(tkEntryClosestGap) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryButton1) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryMouseSelect) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryPaste) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryAutoScan) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryKeySelect) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryInsert) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryBackspace) [list source [file join $dir entry.tcl]]
set auto_index(tkEntrySeeInsert) [list source [file join $dir entry.tcl]]
set auto_index(tkEntrySetCursor) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryTranspose) [list source [file join $dir entry.tcl]]
set auto_index(tkEntryPreviousWord) [list source [file join $dir entry.tcl]]
set auto_index(tkListboxBeginSelect) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxMotion) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxBeginExtend) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxBeginToggle) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxAutoScan) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxUpDown) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxExtendUpDown) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxDataExtend) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxCancel) [list source [file join $dir listbox.tcl]]
set auto_index(tkListboxSelectAll) [list source [file join $dir listbox.tcl]]
set auto_index(tkMbEnter) [list source [file join $dir menu.tcl]]
set auto_index(tkMbLeave) [list source [file join $dir menu.tcl]]
set auto_index(tkMbPost) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuUnpost) [list source [file join $dir menu.tcl]]
set auto_index(tkMbMotion) [list source [file join $dir menu.tcl]]
set auto_index(tkMbButtonUp) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuMotion) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuButtonDown) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuLeave) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuInvoke) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuEscape) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuUpArrow) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuDownArrow) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuLeftArrow) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuRightArrow) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuNextMenu) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuNextEntry) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuFind) [list source [file join $dir menu.tcl]]
set auto_index(tkTraverseToMenu) [list source [file join $dir menu.tcl]]
set auto_index(tkFirstMenu) [list source [file join $dir menu.tcl]]
set auto_index(tkTraverseWithinMenu) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuFirstEntry) [list source [file join $dir menu.tcl]]
set auto_index(tkMenuFindName) [list source [file join $dir menu.tcl]]
set auto_index(tkPostOverPoint) [list source [file join $dir menu.tcl]]
set auto_index(tkSaveGrabInfo) [list source [file join $dir menu.tcl]]
set auto_index(tkRestoreOldGrab) [list source [file join $dir menu.tcl]]
set auto_index(tk_menuSetFocus) [list source [file join $dir menu.tcl]]
set auto_index(tkGenerateMenuSelect) [list source [file join $dir menu.tcl]]
set auto_index(tk_popup) [list source [file join $dir menu.tcl]]
set auto_index(tkScrollButtonDown) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollButtonUp) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollSelect) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollStartDrag) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollDrag) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollEndDrag) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollByUnits) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollByPages) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollToPos) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollTopBottom) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkScrollButton2Down) [list source [file join $dir scrlbar.tcl]]
set auto_index(tkTextClosestGap) [list source [file join $dir text.tcl]]
set auto_index(tkTextButton1) [list source [file join $dir text.tcl]]
set auto_index(tkTextSelectTo) [list source [file join $dir text.tcl]]
set auto_index(tkTextKeyExtend) [list source [file join $dir text.tcl]]
set auto_index(tkTextPaste) [list source [file join $dir text.tcl]]
set auto_index(tkTextAutoScan) [list source [file join $dir text.tcl]]
set auto_index(tkTextSetCursor) [list source [file join $dir text.tcl]]
set auto_index(tkTextKeySelect) [list source [file join $dir text.tcl]]
set auto_index(tkTextResetAnchor) [list source [file join $dir text.tcl]]
set auto_index(tkTextInsert) [list source [file join $dir text.tcl]]
set auto_index(tkTextUpDownLine) [list source [file join $dir text.tcl]]
set auto_index(tkTextPrevPara) [list source [file join $dir text.tcl]]
set auto_index(tkTextNextPara) [list source [file join $dir text.tcl]]
set auto_index(tkTextScrollPages) [list source [file join $dir text.tcl]]
set auto_index(tkTextTranspose) [list source [file join $dir text.tcl]]
set auto_index(tk_textCopy) [list source [file join $dir text.tcl]]
set auto_index(tk_textCut) [list source [file join $dir text.tcl]]
set auto_index(tk_textPaste) [list source [file join $dir text.tcl]]
set auto_index(tkTextNextPos) [list source [file join $dir text.tcl]]
set auto_index(tkTextPrevPos) [list source [file join $dir text.tcl]]
set auto_index(tkScreenChanged) [list source [file join $dir tk.tcl]]
set auto_index(tkEventMotifBindings) [list source [file join $dir tk.tcl]]
set auto_index(tkCancelRepeat) [list source [file join $dir tk.tcl]]
set auto_index(tkTabToWindow) [list source [file join $dir tk.tcl]]
set auto_index(bgerror) [list source [file join $dir bgerror.tcl]]
set auto_index(tkScaleActivate) [list source [file join $dir scale.tcl]]
set auto_index(tkScaleButtonDown) [list source [file join $dir scale.tcl]]
set auto_index(tkScaleDrag) [list source [file join $dir scale.tcl]]
set auto_index(tkScaleEndDrag) [list source [file join $dir scale.tcl]]
set auto_index(tkScaleIncrement) [list source [file join $dir scale.tcl]]
set auto_index(tkScaleControlPress) [list source [file join $dir scale.tcl]]
set auto_index(tkScaleButton2Down) [list source [file join $dir scale.tcl]]
set auto_index(tk_optionMenu) [list source [file join $dir optMenu.tcl]]
set auto_index(tkTearOffMenu) [list source [file join $dir tearoff.tcl]]
set auto_index(tkMenuDup) [list source [file join $dir tearoff.tcl]]
set auto_index(tk_menuBar) [list source [file join $dir obsolete.tcl]]
set auto_index(tk_bindForTraversal) [list source [file join $dir obsolete.tcl]]
set auto_index(tk_focusNext) [list source [file join $dir focus.tcl]]
set auto_index(tk_focusPrev) [list source [file join $dir focus.tcl]]
set auto_index(tkFocusOK) [list source [file join $dir focus.tcl]]
set auto_index(tk_focusFollowsMouse) [list source [file join $dir focus.tcl]]
set auto_index(tkConsoleInit) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleSource) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleInvoke) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleHistory) [list source [file join $dir console.tcl]]
set auto_index(tkConsolePrompt) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleBind) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleInsert) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleOutput) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleExit) [list source [file join $dir console.tcl]]
set auto_index(tkConsoleAbout) [list source [file join $dir console.tcl]]
set auto_index(tk_setPalette) [list source [file join $dir palette.tcl]]
set auto_index(tkRecolorTree) [list source [file join $dir palette.tcl]]
set auto_index(tkDarken) [list source [file join $dir palette.tcl]]
set auto_index(tk_bisque) [list source [file join $dir palette.tcl]]
set auto_index(tkColorDialog) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_InitValues) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_Config) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_BuildDialog) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_SetRGBValue) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_XToRgb) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_RgbToX) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_DrawColorScale) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_CreateSelector) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_RedrawFinalColor) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_RedrawColorBars) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_StartMove) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_MoveSelector) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_ReleaseMouse) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_ResizeColorBars) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_HandleSelEntry) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_HandleRGBEntry) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_EnterColorBar) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_LeaveColorBar) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_OkCmd) [list source [file join $dir clrpick.tcl]]
set auto_index(tkColorDialog_CancelCmd) [list source [file join $dir clrpick.tcl]]
set auto_index(tclParseConfigSpec) [list source [file join $dir comdlg.tcl]]
set auto_index(tclListValidFlags) [list source [file join $dir comdlg.tcl]]
set auto_index(tclSortNoCase) [list source [file join $dir comdlg.tcl]]
set auto_index(tclVerifyInteger) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFocusGroup_Create) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFocusGroup_BindIn) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFocusGroup_BindOut) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFocusGroup_Destroy) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFocusGroup_In) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFocusGroup_Out) [list source [file join $dir comdlg.tcl]]
set auto_index(tkFDGetFileTypes) [list source [file join $dir comdlg.tcl]]
set auto_index(::safe::loadTk) [list source [file join $dir safetk.tcl]]
set auto_index(::safe::TkInit) [list source [file join $dir safetk.tcl]]
set auto_index(::safe::allowTk) [list source [file join $dir safetk.tcl]]
set auto_index(::safe::tkTopLevel) [list source [file join $dir safetk.tcl]]
set auto_index(tkMessageBox) [list source [file join $dir msgbox.tcl]]
set auto_index(tkIconList) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Config) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Create) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_AutoScan) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_DeleteAll) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Add) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Arrange) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Invoke) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_See) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_SelectAtXY) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Select) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Unselect) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Get) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Btn1) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Motion1) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Double1) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_ReturnKey) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Leave1) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_FocusIn) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_UpDown) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_LeftRight) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_KeyPress) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Goto) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkIconList_Reset) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::tkFDialog) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::Config) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::Create) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::UpdateWhenIdle) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::Update) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::SetPathSilently) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::SetPath) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::SetFilter) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkFDialogResolveFile) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::EntFocusIn) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::EntFocusOut) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::ActivateEnt) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::InvokeBtn) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::UpDirCmd) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::JoinFile) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::OkCmd) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::CancelCmd) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::ListBrowse) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::ListInvoke) [list source [file join $dir tkfbox.tcl]]
set auto_index(::tk::dialog::file::Done) [list source [file join $dir tkfbox.tcl]]
set auto_index(tkMotifFDialog) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_Config) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_Create) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_MakeSList) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_BrowseDList) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_ActivateDList) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_BrowseFList) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_ActivateFList) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_ActivateFEnt) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_InterpFilter) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_ActivateSEnt) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_OkCmd) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_FilterCmd) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_CancelCmd) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_Update) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkMotifFDialog_LoadFiles) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkListBoxKeyAccel_Set) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkListBoxKeyAccel_Unset) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkListBoxKeyAccel_Key) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkListBoxKeyAccel_Goto) [list source [file join $dir xmfbox.tcl]]
set auto_index(tkListBoxKeyAccel_Reset) [list source [file join $dir xmfbox.tcl]]
set auto_index(::tk::dialog::file::chooseDir::tkChooseDirectory) [list source [file join $dir choosedir.tcl]]
proc tkTearOffMenu {w {x 0} {y 0}} {
    if {$x == 0} then {
	set x [winfo rootx $w]
    }
    if {$y == 0} then {
	set y [winfo rooty $w]
    }
    set parent [winfo parent $w]
    while {[string compare [winfo toplevel $parent] $parent] || [string equal [winfo class $parent] "Menu"]} {
	set parent [winfo parent $parent]
    }
    if {[string equal $parent "."]} then {
	set parent ""
    }
    for {set i 1} 1 {incr i} {
	set menu $parent.tearoff$i
	if {![winfo exists $menu]} then {
	    break
	}
    }
    $w clone $menu tearoff
    set parent [winfo parent $w]
    if {[string compare [$menu cget -title] ""]} then {
	wm title $menu [$menu cget -title]
    } else {
	switch [winfo class $parent] {
	Menubutton {
		wm title $menu [$parent cget -text]
	    }
	Menu {
		wm title $menu [$parent entrycget active -label]
	    }
	}
    }
    $menu post $x $y
    if {[winfo exists $menu] == 0} then {
	return ""
    }
    bind $menu <Enter> {
	set tkPriv(focus) %W
    }
    set cmd [$w cget -tearoffcommand]
    if {[string compare $cmd ""]} then {
	uplevel #0 $cmd [list $w $menu]
    }
    return $menu
}
proc tkMenuDup {src dst type} {
    set cmd [list menu $dst -type $type]
    foreach option [$src configure] {
	if {[llength $option] == 2} then {
	    continue
	}
	if {[string equal [lindex $option 0] "-type"]} then {
	    continue
	}
	lappend cmd [lindex $option 0] [lindex $option 4]
    }
    eval $cmd
    set last [$src index last]
    if {[string equal $last "none"]} then {
	return
    }
    for {set i [$src cget -tearoff]} {$i <= $last} {incr i} {
	set cmd [list $dst add [$src type $i]]
	foreach option [$src entryconfigure $i] {
	    lappend cmd [lindex $option 0] [lindex $option 4]
	}
	eval $cmd
    }
    set tags [bindtags $src]
    set srcLen [string length $src]
    while {[set index [string first $src $tags]] != -1} {
	append x [string range $tags 0 [expr {$index - 1}]]$dst
	set tags [string range $tags [expr {$index + $srcLen}] end]
    }
    append x $tags
    bindtags $dst $x
    foreach event [bind $src] {
	unset x
	set script [bind $src $event]
	set eventLen [string length $event]
	while {[set index [string first $event $script]] != -1} {
	    append x [string range $script 0 [expr {$index - 1}]]
	    append x $dst
	    set script [string range $script [expr {$index + $eventLen}] end]
	}
	append x $script
	bind $dst $event $x
    }
}
bind Text <1> {
    tkTextButton1 %W %x %y
    %W tag remove sel 0.0 end
}
bind Text <B1-Motion> {
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkTextSelectTo %W %x %y
}
bind Text <Double-1> {
    set tkPriv(selectMode) word
    tkTextSelectTo %W %x %y
    catch {%W mark set insert sel.last}
    catch {%W mark set anchor sel.first}
}
bind Text <Triple-1> {
    set tkPriv(selectMode) line
    tkTextSelectTo %W %x %y
    catch {%W mark set insert sel.last}
    catch {%W mark set anchor sel.first}
}
bind Text <Shift-1> {
    tkTextResetAnchor %W @%x,%y
    set tkPriv(selectMode) char
    tkTextSelectTo %W %x %y
}
bind Text <Double-Shift-1> {
    set tkPriv(selectMode) word
    tkTextSelectTo %W %x %y 1
}
bind Text <Triple-Shift-1> {
    set tkPriv(selectMode) line
    tkTextSelectTo %W %x %y
}
bind Text <B1-Leave> {
    set tkPriv(x) %x
    set tkPriv(y) %y
    tkTextAutoScan %W
}
bind Text <B1-Enter> {
    tkCancelRepeat
}
bind Text <ButtonRelease-1> {
    tkCancelRepeat
}
bind Text <Control-1> {
    %W mark set insert @%x,%y
}
bind Text <Left> {
    tkTextSetCursor %W insert-1c
}
bind Text <Right> {
    tkTextSetCursor %W insert+1c
}
bind Text <Up> {
    tkTextSetCursor %W [tkTextUpDownLine %W -1]
}
bind Text <Down> {
    tkTextSetCursor %W [tkTextUpDownLine %W 1]
}
bind Text <Shift-Left> {
    tkTextKeySelect %W [%W index {insert - 1c}]
}
bind Text <Shift-Right> {
    tkTextKeySelect %W [%W index {insert + 1c}]
}
bind Text <Shift-Up> {
    tkTextKeySelect %W [tkTextUpDownLine %W -1]
}
bind Text <Shift-Down> {
    tkTextKeySelect %W [tkTextUpDownLine %W 1]
}
bind Text <Control-Left> {
    tkTextSetCursor %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
}
bind Text <Control-Right> {
    tkTextSetCursor %W [tkTextNextWord %W insert]
}
bind Text <Control-Up> {
    tkTextSetCursor %W [tkTextPrevPara %W insert]
}
bind Text <Control-Down> {
    tkTextSetCursor %W [tkTextNextPara %W insert]
}
bind Text <Shift-Control-Left> {
    tkTextKeySelect %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
}
bind Text <Shift-Control-Right> {
    tkTextKeySelect %W [tkTextNextWord %W insert]
}
bind Text <Shift-Control-Up> {
    tkTextKeySelect %W [tkTextPrevPara %W insert]
}
bind Text <Shift-Control-Down> {
    tkTextKeySelect %W [tkTextNextPara %W insert]
}
bind Text <Prior> {
    tkTextSetCursor %W [tkTextScrollPages %W -1]
}
bind Text <Shift-Prior> {
    tkTextKeySelect %W [tkTextScrollPages %W -1]
}
bind Text <Next> {
    tkTextSetCursor %W [tkTextScrollPages %W 1]
}
bind Text <Shift-Next> {
    tkTextKeySelect %W [tkTextScrollPages %W 1]
}
bind Text <Control-Prior> {
    %W xview scroll -1 page
}
bind Text <Control-Next> {
    %W xview scroll 1 page
}
bind Text <Home> {
    tkTextSetCursor %W {insert linestart}
}
bind Text <Shift-Home> {
    tkTextKeySelect %W {insert linestart}
}
bind Text <End> {
    tkTextSetCursor %W {insert lineend}
}
bind Text <Shift-End> {
    tkTextKeySelect %W {insert lineend}
}
bind Text <Control-Home> {
    tkTextSetCursor %W 1.0
}
bind Text <Control-Shift-Home> {
    tkTextKeySelect %W 1.0
}
bind Text <Control-End> {
    tkTextSetCursor %W {end - 1 char}
}
bind Text <Control-Shift-End> {
    tkTextKeySelect %W {end - 1 char}
}
bind Text <Tab> {
    tkTextInsert %W \t
    focus %W
    break
}
bind Text <Shift-Tab> {
    break
}
bind Text <Control-Tab> {
    focus [tk_focusNext %W]
}
bind Text <Control-Shift-Tab> {
    focus [tk_focusPrev %W]
}
bind Text <Control-i> {
    tkTextInsert %W \t
}
bind Text <Return> {
    tkTextInsert %W \n
}
bind Text <Delete> {
    if {[string compare [%W tag nextrange sel 1.0 end] ""]} then {
	%W delete sel.first sel.last
    } else {
	%W delete insert
	%W see insert
    }
}
bind Text <BackSpace> {
    if {[string compare [%W tag nextrange sel 1.0 end] ""]} then {
	%W delete sel.first sel.last
    } elseif {[%W compare insert != 1.0]} {
	%W delete insert-1c
	%W see insert
    }
}
bind Text <Control-space> {
    %W mark set anchor insert
}
bind Text <Select> {
    %W mark set anchor insert
}
bind Text <Control-Shift-space> {
    set tkPriv(selectMode) char
    tkTextKeyExtend %W insert
}
bind Text <Shift-Select> {
    set tkPriv(selectMode) char
    tkTextKeyExtend %W insert
}
bind Text <Control-slash> {
    %W tag add sel 1.0 end
}
bind Text <Control-backslash> {
    %W tag remove sel 1.0 end
}
bind Text <<Cut>> {
    tk_textCut %W
}
bind Text <<Copy>> {
    tk_textCopy %W
}
bind Text <<Paste>> {
    tk_textPaste %W
}
bind Text <<Clear>> {
    catch {%W delete sel.first sel.last}
}
bind Text <<PasteSelection>> {
    if {!$tkPriv(mouseMoved) || $tk_strictMotif} then {
	tkTextPaste %W %x %y
    }
}
bind Text <Insert> {
    catch {tkTextInsert %W [selection get -displayof %W]}
}
bind Text <KeyPress> {
    tkTextInsert %W %A
}
bind Text <Alt-KeyPress> {# nothing }
bind Text <Meta-KeyPress> {# nothing}
bind Text <Control-KeyPress> {# nothing}
bind Text <Escape> {# nothing}
bind Text <KP_Enter> {# nothing}
if {[string equal $tcl_platform(platform) "macintosh"]} then {
    bind Text <Command-KeyPress> {# nothing}
}
bind Text <Control-a> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W {insert linestart}
    }
}
bind Text <Control-b> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W insert-1c
    }
}
bind Text <Control-d> {
    if {!$tk_strictMotif} then {
	%W delete insert
    }
}
bind Text <Control-e> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W {insert lineend}
    }
}
bind Text <Control-f> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W insert+1c
    }
}
bind Text <Control-k> {
    if {!$tk_strictMotif} then {
	if {[%W compare insert == {insert lineend}]} then {
	    %W delete insert
	} else {
	    %W delete insert {insert lineend}
	}
    }
}
bind Text <Control-n> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W [tkTextUpDownLine %W 1]
    }
}
bind Text <Control-o> {
    if {!$tk_strictMotif} then {
	%W insert insert \n
	%W mark set insert insert-1c
    }
}
bind Text <Control-p> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W [tkTextUpDownLine %W -1]
    }
}
bind Text <Control-t> {
    if {!$tk_strictMotif} then {
	tkTextTranspose %W
    }
}
if {[string compare $tcl_platform(platform) "windows"]} then {
    bind Text <Control-v> {
	if {!$tk_strictMotif} then {
	    tkTextScrollPages %W 1
	}
    }
}
bind Text <Meta-b> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
    }
}
bind Text <Meta-d> {
    if {!$tk_strictMotif} then {
	%W delete insert [tkTextNextWord %W insert]
    }
}
bind Text <Meta-f> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W [tkTextNextWord %W insert]
    }
}
bind Text <Meta-less> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W 1.0
    }
}
bind Text <Meta-greater> {
    if {!$tk_strictMotif} then {
	tkTextSetCursor %W end-1c
    }
}
bind Text <Meta-BackSpace> {
    if {!$tk_strictMotif} then {
	%W delete [tkTextPrevPos %W insert tcl_startOfPreviousWord] insert
    }
}
bind Text <Meta-Delete> {
    if {!$tk_strictMotif} then {
	%W delete [tkTextPrevPos %W insert tcl_startOfPreviousWord] insert
    }
}
if {[string equal $tcl_platform(platform) "macintosh"]} then {
    bind Text <FocusIn> {
	%W tag configure sel -borderwidth 0
	%W configure -selectbackground systemHighlight -selectforeground systemHighlightText
    }
    bind Text <FocusOut> {
	%W tag configure sel -borderwidth 1
	%W configure -selectbackground white -selectforeground black
    }
    bind Text <Option-Left> {
	tkTextSetCursor %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
    }
    bind Text <Option-Right> {
	tkTextSetCursor %W [tkTextNextWord %W insert]
    }
    bind Text <Option-Up> {
	tkTextSetCursor %W [tkTextPrevPara %W insert]
    }
    bind Text <Option-Down> {
	tkTextSetCursor %W [tkTextNextPara %W insert]
    }
    bind Text <Shift-Option-Left> {
	tkTextKeySelect %W [tkTextPrevPos %W insert tcl_startOfPreviousWord]
    }
    bind Text <Shift-Option-Right> {
	tkTextKeySelect %W [tkTextNextWord %W insert]
    }
    bind Text <Shift-Option-Up> {
	tkTextKeySelect %W [tkTextPrevPara %W insert]
    }
    bind Text <Shift-Option-Down> {
	tkTextKeySelect %W [tkTextNextPara %W insert]
    }
}
bind Text <Control-h> {
    if {!$tk_strictMotif} then {
	if {[%W compare insert != 1.0]} then {
	    %W delete insert-1c
	    %W see insert
	}
    }
}
bind Text <2> {
    if {!$tk_strictMotif} then {
	%W scan mark %x %y
	set tkPriv(x) %x
	set tkPriv(y) %y
	set tkPriv(mouseMoved) 0
    }
}
bind Text <B2-Motion> {
    if {!$tk_strictMotif} then {
	if {(%x != $tkPriv(x)) ||(%y != $tkPriv(y))} then {
	    set tkPriv(mouseMoved) 1
	}
	if {$tkPriv(mouseMoved)} then {
	    %W scan dragto %x %y
	}
    }
}
set tkPriv(prevPos) {}
bind Text <MouseWheel> {
    %W yview scroll [expr {-(%D / 120) * 4}] units
}
if {[string equal "unix" $tcl_platform(platform)]} then {
    bind Text <4> {
	if {!$tk_strictMotif} then {
	    %W yview scroll -5 units
	}
    }
    bind Text <5> {
	if {!$tk_strictMotif} then {
	    %W yview scroll 5 units
	}
    }
}
proc tkTextClosestGap {w x y} {
    set pos [$w index @$x,$y]
    set bbox [$w bbox $pos]
    if {[string equal $bbox ""]} then {
	return $pos
    }
    if {($x - [lindex $bbox 0]) <([lindex $bbox 2]/2)} then {
	return $pos
    }
    $w index "$pos + 1 char"
}
proc tkTextButton1 {w x y} {
    global tkPriv
    set tkPriv(selectMode) char
    set tkPriv(mouseMoved) 0
    set tkPriv(pressX) $x
    $w mark set insert [tkTextClosestGap $w $x $y]
    $w mark set anchor insert
    if {[string equal [$w cget -state] "normal"]} then {
	focus $w
    }
}
proc tkTextSelectTo {w x y {extend 0}} {
    global tkPriv tcl_platform
    set cur [tkTextClosestGap $w $x $y]
    if {[catch {$w index anchor}]} then {
	$w mark set anchor $cur
    }
    set anchor [$w index anchor]
    if {[$w compare $cur != $anchor] ||(abs($tkPriv(pressX) - $x) >= 3)} then {
	set tkPriv(mouseMoved) 1
    }
    switch $tkPriv(selectMode) {
    char {
	    if {[$w compare $cur < anchor]} then {
		set first $cur
		set last anchor
	    } else {
		set first anchor
		set last $cur
	    }
	}
    word {
	    if {[$w compare $cur < anchor]} then {
		set first [tkTextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
		if {!$extend} then {
		    set last [tkTextNextPos $w "anchor" tcl_wordBreakAfter]
		} else {
		    set last anchor
		}
	    } else {
		set last [tkTextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
		if {!$extend} then {
		    set first [tkTextPrevPos $w anchor tcl_wordBreakBefore]
		} else {
		    set first anchor
		}
	    }
	}
    line {
	    if {[$w compare $cur < anchor]} then {
		set first [$w index "$cur linestart"]
		set last [$w index "anchor - 1c lineend + 1c"]
	    } else {
		set first [$w index "anchor linestart"]
		set last [$w index "$cur lineend + 1c"]
	    }
	}
    }
    if {$tkPriv(mouseMoved) || [string compare $tkPriv(selectMode) "char"]} then {
	if {[string compare $tcl_platform(platform) "unix"] && [$w compare $cur < anchor]} then {
	    $w mark set insert $first
	} else {
	    $w mark set insert $last
	}
	$w tag remove sel 0.0 $first
	$w tag add sel $first $last
	$w tag remove sel $last end
	update idletasks
    }
}
proc tkTextKeyExtend {w index} {
    global tkPriv
    set cur [$w index $index]
    if {[catch {$w index anchor}]} then {
	$w mark set anchor $cur
    }
    set anchor [$w index anchor]
    if {[$w compare $cur < anchor]} then {
	set first $cur
	set last anchor
    } else {
	set first anchor
	set last $cur
    }
    $w tag remove sel 0.0 $first
    $w tag add sel $first $last
    $w tag remove sel $last end
}
proc tkTextPaste {w x y} {
    $w mark set insert [tkTextClosestGap $w $x $y]
    catch {$w insert insert [selection get -displayof $w]}
    if {[string equal [$w cget -state] "normal"]} then {
	focus $w
    }
}
proc tkTextAutoScan {w} {
    global tkPriv
    if {![winfo exists $w]} then return
    if {$tkPriv(y) >= [winfo height $w]} then {
	$w yview scroll 2 units
    } elseif {$tkPriv(y) < 0} {
	$w yview scroll -2 units
    } elseif {$tkPriv(x) >= [winfo width $w]} {
	$w xview scroll 2 units
    } elseif {$tkPriv(x) < 0} {
	$w xview scroll -2 units
    } else {
	return
    }
    tkTextSelectTo $w $tkPriv(x) $tkPriv(y)
    set tkPriv(afterId) [after 50 [list tkTextAutoScan $w]]
}
proc tkTextSetCursor {w pos} {
    global tkPriv
    if {[$w compare $pos == end]} then {
	set pos {end - 1 chars}
    }
    $w mark set insert $pos
    $w tag remove sel 1.0 end
    $w see insert
}
proc tkTextKeySelect {w new} {
    global tkPriv
    if {[string equal [$w tag nextrange sel 1.0 end] ""]} then {
	if {[$w compare $new < insert]} then {
	    $w tag add sel $new insert
	} else {
	    $w tag add sel insert $new
	}
	$w mark set anchor insert
    } else {
	if {[$w compare $new < anchor]} then {
	    set first $new
	    set last anchor
	} else {
	    set first anchor
	    set last $new
	}
	$w tag remove sel 1.0 $first
	$w tag add sel $first $last
	$w tag remove sel $last end
    }
    $w mark set insert $new
    $w see insert
    update idletasks
}
proc tkTextResetAnchor {w index} {
    global tkPriv
    if {[string equal [$w tag ranges sel] ""]} then {
	$w mark set anchor $index
	return
    }
    set a [$w index $index]
    set b [$w index sel.first]
    set c [$w index sel.last]
    if {[$w compare $a < $b]} then {
	$w mark set anchor sel.last
	return
    }
    if {[$w compare $a > $c]} then {
	$w mark set anchor sel.first
	return
    }
    scan $a "%d.%d" lineA chA
    scan $b "%d.%d" lineB chB
    scan $c "%d.%d" lineC chC
    if {$lineB < $lineC+2} then {
	set total [string length [$w get $b $c]]
	if {$total <= 2} then {
	    return
	}
	if {[string length [$w get $b $a]] <($total/2)} then {
	    $w mark set anchor sel.last
	} else {
	    $w mark set anchor sel.first
	}
	return
    }
    if {($lineA-$lineB) <($lineC-$lineA)} then {
	$w mark set anchor sel.last
    } else {
	$w mark set anchor sel.first
    }
}
proc tkTextInsert {w s} {
    if {[string equal $s ""] || [string equal [$w cget -state] "disabled"]} then {
	return
    }
    catch {
	if {[$w compare sel.first <= insert] && [$w compare sel.last >= insert]} then {
	    $w delete sel.first sel.last
	}
    }
    $w insert insert $s
    $w see insert
}
proc tkTextUpDownLine {w n} {
    global tkPriv
    set i [$w index insert]
    scan $i "%d.%d" line char
    if {[string compare $tkPriv(prevPos) $i]} then {
	set tkPriv(char) $char
    }
    set new [$w index [expr {$line + $n}].$tkPriv(char)]
    if {[$w compare $new == end] || [$w compare $new == "insert linestart"]} then {
	set new $i
    }
    set tkPriv(prevPos) $new
    return $new
}
proc tkTextPrevPara {w pos} {
    set pos [$w index "$pos linestart"]
    while {1} {
	if {([string equal [$w get "$pos - 1 line"] "\n"] && [string compare [$w get $pos] "\n"]) || [string equal $pos "1.0"]} then {
	    if {[regexp -indices {^[ 	]+(.)} [$w get $pos "$pos lineend"] dummy index]} then {
		set pos [$w index "$pos + [lindex $index 0] chars"]
	    }
	    if {[$w compare $pos != insert] || [string equal $pos 1.0]} then {
		return $pos
	    }
	}
	set pos [$w index "$pos - 1 line"]
    }
}
proc tkTextNextPara {w start} {
    set pos [$w index "$start linestart + 1 line"]
    while {[string compare [$w get $pos] "\n"]} {
	if {[$w compare $pos == end]} then {
	    return [$w index "end - 1c"]
	}
	set pos [$w index "$pos + 1 line"]
    }
    while {[string equal [$w get $pos] "\n"]} {
	set pos [$w index "$pos + 1 line"]
	if {[$w compare $pos == end]} then {
	    return [$w index "end - 1c"]
	}
    }
    if {[regexp -indices {^[ 	]+(.)} [$w get $pos "$pos lineend"] dummy index]} then {
	return [$w index "$pos + [lindex $index 0] chars"]
    }
    return $pos
}
proc tkTextScrollPages {w count} {
    set bbox [$w bbox insert]
    $w yview scroll $count pages
    if {[string equal $bbox ""]} then {
	return [$w index @[expr {[winfo height $w]/2}],0]
    }
    return [$w index @[lindex $bbox 0],[lindex $bbox 1]]
}
proc tkTextTranspose w {
    set pos insert
    if {[$w compare $pos != "$pos lineend"]} then {
	set pos [$w index "$pos + 1 char"]
    }
    set new [$w get "$pos - 1 char"][$w get "$pos - 2 char"]
    if {[$w compare "$pos - 1 char" == 1.0]} then {
	return
    }
    $w delete "$pos - 2 char" $pos
    $w insert insert $new
    $w see insert
}
proc tk_textCopy w {
    if {![catch {set data [$w get sel.first sel.last]}]} then {
	clipboard clear -displayof $w
	clipboard append -displayof $w $data
    }
}
proc tk_textCut w {
    if {![catch {set data [$w get sel.first sel.last]}]} then {
	clipboard clear -displayof $w
	clipboard append -displayof $w $data
	$w delete sel.first sel.last
    }
}
proc tk_textPaste w {
    global tcl_platform
    catch {
	if {[string compare $tcl_platform(platform) "unix"]} then {
	    catch {
		$w delete sel.first sel.last
	    }
	}
	$w insert insert [selection get -displayof $w -selection CLIPBOARD]
    }
}
if {[string equal $tcl_platform(platform) "windows"]} then {
    proc tkTextNextWord {w start} {
	tkTextNextPos $w [tkTextNextPos $w $start tcl_endOfWord] tcl_startOfNextWord
    }
} else {
    proc tkTextNextWord {w start} {
	tkTextNextPos $w $start tcl_endOfWord
    }
}
proc tkTextNextPos {w start op} {
    set text ""
    set cur $start
    while {[$w compare $cur < end]} {
	set text $text[$w get $cur "$cur lineend + 1c"]
	set pos [$op $text 0]
	if {$pos >= 0} then {
	    set dump [$w dump -image -window $start "$start + $pos c"]
	    if {[llength $dump]} then {
		set pos [expr {$pos +([llength $dump]/3)}]
	    }
	    return [$w index "$start + $pos c"]
	}
	set cur [$w index "$cur lineend +1c"]
    }
    return end
}
proc tkTextPrevPos {w start op} {
    set text ""
    set cur $start
    while {[$w compare $cur > 0.0]} {
	set text [$w get "$cur linestart - 1c" $cur]$text
	set pos [$op $text end]
	if {$pos >= 0} then {
	    set dump [$w dump -image -window "$cur linestart" "$start - 1c"]
	    if {[llength $dump]} then {
		if {[$w compare [lindex $dump 2] > "$cur linestart - 1c + $pos c"]} then {
		    incr pos -1
		}
		set pos [expr {$pos +([llength $dump]/3)}]
	    }
	    return [$w index "$cur linestart - 1c + $pos c"]
	}
	set cur [$w index "$cur linestart - 1c"]
    }
    return 0.0
}
package require -exact Tk 8.3
package require -exact Tcl 8.3
if {[info exists auto_path] && [string compare {} $tk_library] && [lsearch -exact $auto_path $tk_library] < 0} then {
    lappend auto_path $tk_library
}
set tk_strictMotif 0
namespace eval ::tk {
}
proc ::tk::PlaceWindow {w {place ""} {anchor ""}} {
    wm withdraw $w
    update idletasks
    set checkBounds 1
    if {[string equal -len [string length $place] $place "pointer"]} then {
	if {[string equal -len [string length $anchor] $anchor "center"]} then {
	    set x [expr {[winfo pointerx $w]-[winfo reqwidth $w]/2}]
	    set y [expr {[winfo pointery $w]-[winfo reqheight $w]/2}]
	} else {
	    set x [winfo pointerx $w]
	    set y [winfo pointery $w]
	}
    } elseif {[string equal -len [string length $place] $place "widget"] && [winfo exists $anchor] && [winfo ismapped $anchor]} {
	set x [expr {[winfo rootx $anchor] +([winfo width $anchor]-[winfo reqwidth $w]) /2}]
	set y [expr {[winfo rooty $anchor] +([winfo height $anchor]-[winfo reqheight $w]) /2}]
    } else {
	set x [expr {([winfo screenwidth $w]-[winfo reqwidth $w]) /2}]
	set y [expr {([winfo screenheight $w]-[winfo reqheight $w]) /2}]
	set checkBounds 0
    }
    if {$checkBounds} then {
	if {$x < 0} then {
	    set x 0
	} elseif {$x >([winfo screenwidth $w]-[winfo reqwidth $w])} {
	    set x [expr {[winfo screenwidth $w]-[winfo reqwidth $w]}]
	}
	if {$y < 0} then {
	    set y 0
	} elseif {$y >([winfo screenheight $w]-[winfo reqheight $w])} {
	    set y [expr {[winfo screenheight $w]-[winfo reqheight $w]}]
	}
    }
    wm geometry $w +$x+$y
    wm deiconify $w
}
proc ::tk::SetFocusGrab {grab {focus {}}} {
    set index "$grab,$focus"
    upvar ::tk::FocusGrab($index) data
    lappend data [focus]
    set oldGrab [grab current $grab]
    lappend data $oldGrab
    if {[winfo exists $oldGrab]} then {
	lappend data [grab status $oldGrab]
    }
    grab $grab
    if {[winfo exists $focus]} then {
	focus $focus
    }
}
proc ::tk::RestoreFocusGrab {grab focus {destroy destroy}} {
    set index "$grab,$focus"
    foreach {oldFocus oldGrab oldStatus} $::tk::FocusGrab($index) {
	break
    }
    unset ::tk::FocusGrab($index)
    catch {focus $oldFocus}
    grab release $grab
    if {[string equal $destroy "withdraw"]} then {
	wm withdraw $grab
    } else {
	destroy $grab
    }
    if {[winfo exists $oldGrab] && [winfo ismapped $oldGrab]} then {
	if {[string equal $oldStatus "global"]} then {
	    grab -global $oldGrab
	} else {
	    grab $oldGrab
	}
    }
}
proc tkScreenChanged screen {
    set x [string last . $screen]
    if {$x > 0} then {
	set disp [string range $screen 0 [expr {$x - 1}]]
    } else {
	set disp $screen
    }
    uplevel #0 upvar #0 tkPriv.$disp tkPriv
    global tkPriv
    global tcl_platform
    if {[info exists tkPriv]} then {
	set tkPriv(screen) $screen
	return
    }
    array set tkPriv {
activeMenu	{}
activeItem	{}
afterId		{}
buttons		0
buttonWindow	{}
dragging	0
focus		{}
grab		{}
initPos		{}
inMenubutton	{}
listboxPrev	{}
menuBar		{}
mouseMoved	0
oldGrab		{}
popup		{}
postedMb	{}
pressX		0
pressY		0
prevPos		0
selectMode	char
}
    set tkPriv(screen) $screen
    set tkPriv(tearoff) [string equal $tcl_platform(platform) "unix"]
    set tkPriv(window) {}
}
tkScreenChanged [winfo screen .]
proc tkEventMotifBindings {n1 dummy dummy} {
    upvar $n1 name
    if {$name} then {
	set op delete
    } else {
	set op add
    }
    event $op <<Cut>> <Control-Key-w>
    event $op <<Copy>> <Meta-Key-w>
    event $op <<Paste>> <Control-Key-y>
}
if {[string equal [info commands tk_chooseColor] ""]} then {
    proc tk_chooseColor {args} {
	return [eval tkColorDialog $args]
    }
}
if {[string equal [info commands tk_getOpenFile] ""]} then {
    proc tk_getOpenFile {args} {
	if {$::tk_strictMotif} then {
	    return [eval tkMotifFDialog open $args]
	} else {
	    return [eval ::tk::dialog::file::tkFDialog open $args]
	}
    }
}
if {[string equal [info commands tk_getSaveFile] ""]} then {
    proc tk_getSaveFile {args} {
	if {$::tk_strictMotif} then {
	    return [eval tkMotifFDialog save $args]
	} else {
	    return [eval ::tk::dialog::file::tkFDialog save $args]
	}
    }
}
if {[string equal [info commands tk_messageBox] ""]} then {
    proc tk_messageBox {args} {
	return [eval tkMessageBox $args]
    }
}
if {[string equal [info command tk_chooseDirectory] ""]} then {
    proc tk_chooseDirectory {args} {
	return [eval ::tk::dialog::file::chooseDir::tkChooseDirectory $args]
    }
}
switch $tcl_platform(platform) {
"unix" {
	event add <<Cut>> <Control-Key-x> <Key-F20>
	event add <<Copy>> <Control-Key-c> <Key-F16>
	event add <<Paste>> <Control-Key-v> <Key-F18>
	event add <<PasteSelection>> <ButtonRelease-2>
	if {[info exists tcl_platform(os)]} then {
	    switch $tcl_platform(os) {
	    "IRIX" -
	    "Linux" {
		    event add <<PrevWindow>> <ISO_Left_Tab>
		}
	    "HP-UX" {
		    event add <<PrevWindow>> <hpBackTab>
		}
	    }
	}
	trace variable tk_strictMotif w tkEventMotifBindings
	set tk_strictMotif $tk_strictMotif
    }
"windows" {
	event add <<Cut>> <Control-Key-x> <Shift-Key-Delete>
	event add <<Copy>> <Control-Key-c> <Control-Key-Insert>
	event add <<Paste>> <Control-Key-v> <Shift-Key-Insert>
	event add <<PasteSelection>> <ButtonRelease-2>
    }
"macintosh" {
	event add <<Cut>> <Control-Key-x> <Key-F2>
	event add <<Copy>> <Control-Key-c> <Key-F3>
	event add <<Paste>> <Control-Key-v> <Key-F4>
	event add <<PasteSelection>> <ButtonRelease-2>
	event add <<Clear>> <Clear>
    }
}
if {[string compare $tcl_platform(platform) "macintosh"] && [string compare {} $tk_library]} then {
    source [file join $tk_library button.tcl]
    source [file join $tk_library entry.tcl]
    source [file join $tk_library listbox.tcl]
    source [file join $tk_library menu.tcl]
    source [file join $tk_library scale.tcl]
    source [file join $tk_library scrlbar.tcl]
    source [file join $tk_library text.tcl]
}
event add <<PrevWindow>> <Shift-Tab>
bind all <Tab> {tkTabToWindow [tk_focusNext %W]}
bind all <<PrevWindow>> {tkTabToWindow [tk_focusPrev %W]}
proc tkCancelRepeat {} {
    global tkPriv
    after cancel $tkPriv(afterId)
    set tkPriv(afterId) {}
}
proc tkTabToWindow {w} {
    if {[string equal [winfo class $w] Entry]} then {
	$w selection range 0 end
	$w icursor end
    }
    focus $w
}
proc tkIconList {w args} {
    upvar #0 $w data
    tkIconList_Config $w $args
    tkIconList_Create $w
}
proc tkIconList_Config {w argList} {
    upvar #0 $w data
    set specs {
{-browsecmd "" "" ""}
{-command "" "" ""}
}
    tclParseConfigSpec $w $specs "" $argList
}
proc tkIconList_Create {w} {
    upvar #0 $w data
    frame $w
    set data(sbar) [scrollbar $w.sbar -orient horizontal -highlightthickness 0 -takefocus 0]
    set data(canvas) [canvas $w.canvas -bd 2 -relief sunken -width 400 -height 120 -takefocus 1]
    pack $data(sbar) -side bottom -fill x -padx 2
    pack $data(canvas) -expand yes -fill both
    $data(sbar) config -command [list $data(canvas) xview]
    $data(canvas) config -xscrollcommand [list $data(sbar) set]
    set data(maxIW) 1
    set data(maxIH) 1
    set data(maxTW) 1
    set data(maxTH) 1
    set data(numItems) 0
    set data(curItem) {}
    set data(noScroll) 1
    bind $data(canvas) <Configure> [list tkIconList_Arrange $w]
    bind $data(canvas) <1> [list tkIconList_Btn1 $w %x %y]
    bind $data(canvas) <B1-Motion> [list tkIconList_Motion1 $w %x %y]
    bind $data(canvas) <B1-Leave> [list tkIconList_Leave1 $w %x %y]
    bind $data(canvas) <B1-Enter> [list tkCancelRepeat]
    bind $data(canvas) <ButtonRelease-1> [list tkCancelRepeat]
    bind $data(canvas) <Double-ButtonRelease-1> [list tkIconList_Double1 $w %x %y]
    bind $data(canvas) <Up> [list tkIconList_UpDown $w -1]
    bind $data(canvas) <Down> [list tkIconList_UpDown $w 1]
    bind $data(canvas) <Left> [list tkIconList_LeftRight $w -1]
    bind $data(canvas) <Right> [list tkIconList_LeftRight $w 1]
    bind $data(canvas) <Return> [list tkIconList_ReturnKey $w]
    bind $data(canvas) <KeyPress> [list tkIconList_KeyPress $w %A]
    bind $data(canvas) <Control-KeyPress> ";"
    bind $data(canvas) <Alt-KeyPress> ";"
    bind $data(canvas) <FocusIn> [list tkIconList_FocusIn $w]
    return $w
}
proc tkIconList_AutoScan {w} {
    upvar #0 $w data
    global tkPriv
    if {![winfo exists $w]} then return
    set x $tkPriv(x)
    set y $tkPriv(y)
    if {$data(noScroll)} then {
	return
    }
    if {$x >= [winfo width $data(canvas)]} then {
	$data(canvas) xview scroll 1 units
    } elseif {$x < 0} {
	$data(canvas) xview scroll -1 units
    } elseif {$y >= [winfo height $data(canvas)]} {
    } elseif {$y < 0} {
    } else {
	return
    }
    tkIconList_Motion1 $w $x $y
    set tkPriv(afterId) [after 50 [list tkIconList_AutoScan $w]]
}
proc tkIconList_DeleteAll {w} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
    $data(canvas) delete all
    catch {unset data(selected)}
    catch {unset data(rect)}
    catch {unset data(list)}
    catch {unset itemList}
    set data(maxIW) 1
    set data(maxIH) 1
    set data(maxTW) 1
    set data(maxTH) 1
    set data(numItems) 0
    set data(curItem) {}
    set data(noScroll) 1
    $data(sbar) set 0.0 1.0
    $data(canvas) xview moveto 0
}
proc tkIconList_Add {w image text} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
    upvar #0 $w:textList textList
    set iTag [$data(canvas) create image 0 0 -image $image -anchor nw]
    set tTag [$data(canvas) create text 0 0 -text $text -anchor nw -font $data(font)]
    set rTag [$data(canvas) create rect 0 0 0 0 -fill "" -outline ""]
    set b [$data(canvas) bbox $iTag]
    set iW [expr {[lindex $b 2]-[lindex $b 0]}]
    set iH [expr {[lindex $b 3]-[lindex $b 1]}]
    if {$data(maxIW) < $iW} then {
	set data(maxIW) $iW
    }
    if {$data(maxIH) < $iH} then {
	set data(maxIH) $iH
    }
    set b [$data(canvas) bbox $tTag]
    set tW [expr {[lindex $b 2]-[lindex $b 0]}]
    set tH [expr {[lindex $b 3]-[lindex $b 1]}]
    if {$data(maxTW) < $tW} then {
	set data(maxTW) $tW
    }
    if {$data(maxTH) < $tH} then {
	set data(maxTH) $tH
    }
    lappend data(list) [list $iTag $tTag $rTag $iW $iH $tW $tH $data(numItems)]
    set itemList($rTag) [list $iTag $tTag $text $data(numItems)]
    set textList($data(numItems)) [string tolower $text]
    incr data(numItems)
}
proc tkIconList_Arrange {w} {
    upvar #0 $w data
    if {![info exists data(list)]} then {
	if {[info exists data(canvas)] && [winfo exists $data(canvas)]} then {
	    set data(noScroll) 1
	    $data(sbar) config -command ""
	}
	return
    }
    set W [winfo width $data(canvas)]
    set H [winfo height $data(canvas)]
    set pad [expr {[$data(canvas) cget -highlightthickness] + [$data(canvas) cget -bd]}]
    if {$pad < 2} then {
	set pad 2
    }
    incr W -[expr {$pad*2}]
    incr H -[expr {$pad*2}]
    set dx [expr {$data(maxIW) + $data(maxTW) + 8}]
    if {$data(maxTH) > $data(maxIH)} then {
	set dy $data(maxTH)
    } else {
	set dy $data(maxIH)
    }
    incr dy 2
    set shift [expr {$data(maxIW) + 4}]
    set x [expr {$pad * 2}]
    set y [expr {$pad * 1}]
    # Why * 1 ?
    set usedColumn 0
    foreach sublist $data(list) {
	set usedColumn 1
	set iTag [lindex $sublist 0]
	set tTag [lindex $sublist 1]
	set rTag [lindex $sublist 2]
	set iW [lindex $sublist 3]
	set iH [lindex $sublist 4]
	set tW [lindex $sublist 5]
	set tH [lindex $sublist 6]
	set i_dy [expr {($dy - $iH) /2}]
	set t_dy [expr {($dy - $tH) /2}]
	$data(canvas) coords $iTag $x [expr {$y + $i_dy}]
	$data(canvas) coords $tTag [expr {$x + $shift}] [expr {$y + $t_dy}]
	$data(canvas) coords $tTag [expr {$x + $shift}] [expr {$y + $t_dy}]
	$data(canvas) coords $rTag $x $y [expr {$x+$dx}] [expr {$y+$dy}]
	incr y $dy
	if {($y + $dy) > $H} then {
	    set y [expr {$pad * 1}]
	    # *1 ?
	    incr x $dx
	    set usedColumn 0
	}
    }
    if {$usedColumn} then {
	set sW [expr {$x + $dx}]
    } else {
	set sW $x
    }
    if {$sW < $W} then {
	$data(canvas) config -scrollregion [list $pad $pad $sW $H]
	$data(sbar) config -command ""
	$data(canvas) xview moveto 0
	set data(noScroll) 1
    } else {
	$data(canvas) config -scrollregion [list $pad $pad $sW $H]
	$data(sbar) config -command [list $data(canvas) xview]
	set data(noScroll) 0
    }
    set data(itemsPerColumn) [expr {($H-$pad) /$dy}]
    if {$data(itemsPerColumn) < 1} then {
	set data(itemsPerColumn) 1
    }
    if {$data(curItem) != ""} then {
	tkIconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 0
    }
}
proc tkIconList_Invoke {w} {
    upvar #0 $w data
    if {$data(-command) != "" && [info exists data(selected)]} then {
	uplevel #0 $data(-command)
    }
}
proc tkIconList_See {w rTag} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
    if {$data(noScroll)} then {
	return
    }
    set sRegion [$data(canvas) cget -scrollregion]
    if {[string equal $sRegion {}]} then {
	return
    }
    if {![info exists itemList($rTag)]} then {
	return
    }
    set bbox [$data(canvas) bbox $rTag]
    set pad [expr {[$data(canvas) cget -highlightthickness] + [$data(canvas) cget -bd]}]
    set x1 [lindex $bbox 0]
    set x2 [lindex $bbox 2]
    incr x1 -[expr {$pad * 2}]
    incr x2 -[expr {$pad * 1}]
    # *1 ?
    set cW [expr {[winfo width $data(canvas)] - $pad*2}]
    set scrollW [expr {[lindex $sRegion 2]-[lindex $sRegion 0]+1}]
    set dispX [expr {int([lindex [$data(canvas) xview] 0]*$scrollW)}]
    set oldDispX $dispX
    if {($x2 - $dispX) >= $cW} then {
	set dispX [expr {$x2 - $cW}]
    }
    if {($x1 - $dispX) < 0} then {
	set dispX $x1
    }
    if {$oldDispX != $dispX} then {
	set fraction [expr {double($dispX) /double($scrollW)}]
	$data(canvas) xview moveto $fraction
    }
}
proc tkIconList_SelectAtXY {w x y} {
    upvar #0 $w data
    tkIconList_Select $w [$data(canvas) find closest [$data(canvas) canvasx $x] [$data(canvas) canvasy $y]]
}
proc tkIconList_Select {w rTag {callBrowse 1}} {
    upvar #0 $w data
    upvar #0 $w:itemList itemList
    if {![info exists itemList($rTag)]} then {
	return
    }
    set iTag [lindex $itemList($rTag) 0]
    set tTag [lindex $itemList($rTag) 1]
    set text [lindex $itemList($rTag) 2]
    set serial [lindex $itemList($rTag) 3]
    if {![info exists data(rect)]} then {
	set data(rect) [$data(canvas) create rect 0 0 0 0 -fill #a0a0ff -outline #a0a0ff]
    }
    $data(canvas) lower $data(rect)
    set bbox [$data(canvas) bbox $tTag]
    eval [list $data(canvas) coords $data(rect)] $bbox
    set data(curItem) $serial
    set data(selected) $text
    if {$callBrowse && $data(-browsecmd) != ""} then {
	eval $data(-browsecmd) [list $text]
    }
}
proc tkIconList_Unselect {w} {
    upvar #0 $w data
    if {[info exists data(rect)]} then {
	$data(canvas) delete $data(rect)
	unset data(rect)
    }
    if {[info exists data(selected)]} then {
	unset data(selected)
    }
    #set data(curItem)  {}
}
proc tkIconList_Get {w} {
    upvar #0 $w data
    if {[info exists data(selected)]} then {
	return $data(selected)
    } else {
	return ""
    }
}
proc tkIconList_Btn1 {w x y} {
    upvar #0 $w data
    focus $data(canvas)
    tkIconList_SelectAtXY $w $x $y
}
proc tkIconList_Motion1 {w x y} {
    global tkPriv
    set tkPriv(x) $x
    set tkPriv(y) $y
    tkIconList_SelectAtXY $w $x $y
}
proc tkIconList_Double1 {w x y} {
    upvar #0 $w data
    if {[string compare $data(curItem) {}]} then {
	tkIconList_Invoke $w
    }
}
proc tkIconList_ReturnKey {w} {
    tkIconList_Invoke $w
}
proc tkIconList_Leave1 {w x y} {
    global tkPriv
    set tkPriv(x) $x
    set tkPriv(y) $y
    tkIconList_AutoScan $w
}
proc tkIconList_FocusIn {w} {
    upvar #0 $w data
    if {![info exists data(list)]} then {
	return
    }
    if {[string compare $data(curItem) {}]} then {
	tkIconList_Select $w [lindex [lindex $data(list) $data(curItem)] 2] 1
    }
}
proc tkIconList_UpDown {w amount} {
    upvar #0 $w data
    if {![info exists data(list)]} then {
	return
    }
    if {[string equal $data(curItem) {}]} then {
	set rTag [lindex [lindex $data(list) 0] 2]
    } else {
	set oldRTag [lindex [lindex $data(list) $data(curItem)] 2]
	set rTag [lindex [lindex $data(list) [expr {$data(curItem)+$amount}]] 2]
	if {[string equal $rTag ""]} then {
	    set rTag $oldRTag
	}
    }
    if {[string compare $rTag ""]} then {
	tkIconList_Select $w $rTag
	tkIconList_See $w $rTag
    }
}
proc tkIconList_LeftRight {w amount} {
    upvar #0 $w data
    if {![info exists data(list)]} then {
	return
    }
    if {[string equal $data(curItem) {}]} then {
	set rTag [lindex [lindex $data(list) 0] 2]
    } else {
	set oldRTag [lindex [lindex $data(list) $data(curItem)] 2]
	set newItem [expr {$data(curItem)+($amount*$data(itemsPerColumn))}]
	set rTag [lindex [lindex $data(list) $newItem] 2]
	if {[string equal $rTag ""]} then {
	    set rTag $oldRTag
	}
    }
    if {[string compare $rTag ""]} then {
	tkIconList_Select $w $rTag
	tkIconList_See $w $rTag
    }
}
proc tkIconList_KeyPress {w key} {
    global tkPriv
    append tkPriv(ILAccel,$w) $key
    tkIconList_Goto $w $tkPriv(ILAccel,$w)
    catch {
	after cancel $tkPriv(ILAccel,$w,afterId)
    }
    set tkPriv(ILAccel,$w,afterId) [after 500 [list tkIconList_Reset $w]]
}
proc tkIconList_Goto {w text} {
    upvar #0 $w data
    upvar #0 $w:textList textList
    global tkPriv
    if {![info exists data(list)]} then {
	return
    }
    if {[string equal {} $text]} then {
	return
    }
    if {$data(curItem) == "" || $data(curItem) == 0} then {
	set start 0
    } else {
	set start $data(curItem)
    }
    set text [string tolower $text]
    set theIndex -1
    set less 0
    set len [string length $text]
    set len0 [expr {$len-1}]
    set i $start
    while {1} {
	set sub [string range $textList($i) 0 $len0]
	if {[string equal $text $sub]} then {
	    set theIndex $i
	    break
	}
	incr i
	if {$i == $data(numItems)} then {
	    set i 0
	}
	if {$i == $start} then {
	    break
	}
    }
    if {$theIndex > -1} then {
	set rTag [lindex [lindex $data(list) $theIndex] 2]
	tkIconList_Select $w $rTag
	tkIconList_See $w $rTag
    }
}
proc tkIconList_Reset {w} {
    global tkPriv
    catch {unset tkPriv(ILAccel,$w)}
}
namespace eval ::tk::dialog {}
namespace eval ::tk::dialog::file {}
proc ::tk::dialog::file::tkFDialog {type args} {
    global tkPriv
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data
    ::tk::dialog::file::Config $dataName $type $args
    if {[string equal $data(-parent) .]} then {
	set w .$dataName
    } else {
	set w $data(-parent).$dataName
    }
    if {![winfo exists $w]} then {
	::tk::dialog::file::Create $w TkFDialog
    } elseif {[string compare [winfo class $w] TkFDialog]} {
	destroy $w
	::tk::dialog::file::Create $w TkFDialog
    } else {
	set data(dirMenuBtn) $w.f1.menu
	set data(dirMenu) $w.f1.menu.menu
	set data(upBtn) $w.f1.up
	set data(icons) $w.icons
	set data(ent) $w.f2.ent
	set data(typeMenuLab) $w.f3.lab
	set data(typeMenuBtn) $w.f3.menu
	set data(typeMenu) $data(typeMenuBtn).m
	set data(okBtn) $w.f2.ok
	set data(cancelBtn) $w.f3.cancel
    }
    wm transient $w $data(-parent)
    trace variable data(selectPath) w "::tk::dialog::file::SetPath $w"
    $data(dirMenuBtn) configure -textvariable ::tk::dialog::file::${dataName}(selectPath)
    if {[llength $data(-filetypes)]} then {
	$data(typeMenu) delete 0 end
	foreach type $data(-filetypes) {
	    set title [lindex $type 0]
	    set filter [lindex $type 1]
	    $data(typeMenu) add command -label $title -command [list ::tk::dialog::file::SetFilter $w $type]
	}
	::tk::dialog::file::SetFilter $w [lindex $data(-filetypes) 0]
	$data(typeMenuBtn) config -state normal
	$data(typeMenuLab) config -state normal
    } else {
	set data(filter) "*"
	$data(typeMenuBtn) config -state disabled -takefocus 0
	$data(typeMenuLab) config -state disabled
    }
    ::tk::dialog::file::UpdateWhenIdle $w
    ::tk::PlaceWindow $w widget $data(-parent)
    wm title $w $data(-title)
    ::tk::SetFocusGrab $w $data(ent)
    $data(ent) delete 0 end
    $data(ent) insert 0 $data(selectFile)
    $data(ent) selection range 0 end
    $data(ent) icursor end
    tkwait variable tkPriv(selectFilePath)
    ::tk::RestoreFocusGrab $w $data(ent) withdraw
    foreach trace [trace vinfo data(selectPath)] {
	trace vdelete data(selectPath) [lindex $trace 0] [lindex $trace 1]
    }
    $data(dirMenuBtn) configure -textvariable {}
    return $tkPriv(selectFilePath)
}
proc ::tk::dialog::file::Config {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data
    set data(type) $type
    foreach trace [trace vinfo data(selectPath)] {
	trace vdelete data(selectPath) [lindex $trace 0] [lindex $trace 1]
    }
    set specs {
{-defaultextension "" "" ""}
{-filetypes "" "" ""}
{-initialdir "" "" ""}
{-initialfile "" "" ""}
{-parent "" "" "."}
{-title "" "" ""}
}
    if {![info exists data(selectPath)]} then {
	set data(selectPath) [pwd]
	set data(selectFile) ""
    }
    tclParseConfigSpec ::tk::dialog::file::$dataName $specs "" $argList
    if {$data(-title) == ""} then {
	if {[string equal $type "open"]} then {
	    set data(-title) "Open"
	} else {
	    set data(-title) "Save As"
	}
    }
    if {$data(-initialdir) != ""} then {
	if {[file isdirectory $data(-initialdir)]} then {
	    set old [pwd]
	    cd $data(-initialdir)
	    set data(selectPath) [pwd]
	    cd $old
	} else {
	    set data(selectPath) [pwd]
	}
    }
    set data(selectFile) $data(-initialfile)
    set data(-filetypes) [tkFDGetFileTypes $data(-filetypes)]
    if {![winfo exists $data(-parent)]} then {
	error "bad window path name \"$data(-parent)\""
    }
}
proc ::tk::dialog::file::Create {w class} {
    set dataName [lindex [split $w .] end]
    upvar ::tk::dialog::file::$dataName data
    global tk_library tkPriv
    toplevel $w -class $class
    set f1 [frame $w.f1]
    label $f1.lab -text "Directory:" -under 0
    set data(dirMenuBtn) $f1.menu
    set data(dirMenu) [tk_optionMenu $f1.menu [format %s(selectPath) ::tk::dialog::file::$dataName] ""]
    set data(upBtn) [button $f1.up]
    if {![info exists tkPriv(updirImage)]} then {
	set tkPriv(updirImage) [image create bitmap -data {
#define updir_width 28
#define updir_height 16
static char updir_bits[] = {
0x00, 0x00, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00,
0x20, 0x40, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x01, 0x10, 0x00, 0x00, 0x01,
0x10, 0x02, 0x00, 0x01, 0x10, 0x07, 0x00, 0x01, 0x90, 0x0f, 0x00, 0x01,
0x10, 0x02, 0x00, 0x01, 0x10, 0x02, 0x00, 0x01, 0x10, 0x02, 0x00, 0x01,
0x10, 0xfe, 0x07, 0x01, 0x10, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x01,
0xf0, 0xff, 0xff, 0x01};}]
    }
    $data(upBtn) config -image $tkPriv(updirImage)
    $f1.menu config -takefocus 1 -highlightthickness 2
    pack $data(upBtn) -side right -padx 4 -fill both
    pack $f1.lab -side left -padx 4 -fill both
    pack $f1.menu -expand yes -fill both -padx 4
    if {[string equal $class TkFDialog]} then {
	set fNameCaption "File name:"
	set fNameUnder 5
	set iconListCommand [list ::tk::dialog::file::OkCmd $w]
    } else {
	set fNameCaption "Selection:"
	set fNameUnder 0
	set iconListCommand [list ::tk::dialog::file::chooseDir::DblClick $w]
    }
    set data(icons) [tkIconList $w.icons -browsecmd [list ::tk::dialog::file::ListBrowse $w] -command $iconListCommand]
    set f2 [frame $w.f2 -bd 0]
    label $f2.lab -text $fNameCaption -anchor e -width 14 -under $fNameUnder -pady 0
    set data(ent) [entry $f2.ent]
    global $w.icons
    set $w.icons(font) [$data(ent) cget -font]
    set f3 [frame $w.f3 -bd 0]
    if {[string equal $class TkFDialog]} then {
	set data(typeMenuLab) [button $f3.lab -text "Files of type:" -anchor e -width 14 -under 9 -bd [$f2.lab cget -bd] -highlightthickness [$f2.lab cget -highlightthickness] -relief [$f2.lab cget -relief] -padx [$f2.lab cget -padx] -pady [$f2.lab cget -pady]]
	bindtags $data(typeMenuLab) [list $data(typeMenuLab) Label [winfo toplevel $data(typeMenuLab)] all]
	set data(typeMenuBtn) [menubutton $f3.menu -indicatoron 1 -menu $f3.menu.m]
	set data(typeMenu) [menu $data(typeMenuBtn).m -tearoff 0]
	$data(typeMenuBtn) config -takefocus 1 -highlightthickness 2 -relief raised -bd 2 -anchor w
    }
    set data(okBtn) [button $f2.ok -text OK -under 0 -width 6 -default active -pady 3]
    set data(cancelBtn) [button $f3.cancel -text Cancel -under 0 -width 6 -default normal -pady 3]
    pack $data(okBtn) -side right -padx 4 -anchor e
    pack $f2.lab -side left -padx 4
    pack $f2.ent -expand yes -fill x -padx 2 -pady 0
    pack $data(cancelBtn) -side right -padx 4 -anchor w
    if {[string equal $class TkFDialog]} then {
	pack $data(typeMenuLab) -side left -padx 4
	pack $data(typeMenuBtn) -expand yes -fill x -side right
    }
    pack $f1 -side top -fill x -pady 4
    pack $f3 -side bottom -fill x
    pack $f2 -side bottom -fill x
    pack $data(icons) -expand yes -fill both -padx 4 -pady 1
    wm protocol $w WM_DELETE_WINDOW [list ::tk::dialog::file::CancelCmd $w]
    $data(upBtn) config -command [list ::tk::dialog::file::UpDirCmd $w]
    $data(cancelBtn) config -command [list ::tk::dialog::file::CancelCmd $w]
    bind $w <KeyPress-Escape> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-c> [list tkButtonInvoke $data(cancelBtn)]
    bind $w <Alt-d> [list focus $data(dirMenuBtn)]
    if {[string equal $class TkFDialog]} then {
	bind $data(ent) <Return> [list ::tk::dialog::file::ActivateEnt $w]
	$data(okBtn) config -command [list ::tk::dialog::file::OkCmd $w]
	bind $w <Alt-t> [format {
if {[string equal [%s cget -state] "normal"]} {
focus %s
}
} $data(typeMenuBtn) $data(typeMenuBtn)]
	bind $w <Alt-n> [list focus $data(ent)]
	bind $w <Alt-o> [list ::tk::dialog::file::InvokeBtn $w Open]
	bind $w <Alt-s> [list ::tk::dialog::file::InvokeBtn $w Save]
    } else {
	set okCmd [list ::tk::dialog::file::chooseDir::OkCmd $w]
	bind $data(ent) <Return> $okCmd
	$data(okBtn) config -command $okCmd
	bind $w <Alt-s> [list focus $data(ent)]
	bind $w <Alt-o> [list tkButtonInvoke $data(okBtn)]
    }
    tkFocusGroup_Create $w
    tkFocusGroup_BindIn $w $data(ent) [list ::tk::dialog::file::EntFocusIn $w]
    tkFocusGroup_BindOut $w $data(ent) [list ::tk::dialog::file::EntFocusOut $w]
}
proc ::tk::dialog::file::UpdateWhenIdle {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[info exists data(updateId)]} then {
	return
    } else {
	set data(updateId) [after idle [list ::tk::dialog::file::Update $w]]
    }
}
proc ::tk::dialog::file::Update {w} {
    if {![winfo exists $w]} then {
	return
    }
    set class [winfo class $w]
    if {[string compare $class TkFDialog] && [string compare $class TkChooseDir]} then {
	return
    }
    set dataName [winfo name $w]
    upvar ::tk::dialog::file::$dataName data
    global tk_library tkPriv
    catch {unset data(updateId)}
    if {![info exists tkPriv(folderImage)]} then {
	set tkPriv(folderImage) [image create photo -data {
R0lGODlhEAAMAKEAAAD//wAAAPD/gAAAACH5BAEAAAAALAAAAAAQAAwAAAIghINhyycvVFsB
QtmS3rjaH1Hg141WaT5ouprt2HHcUgAAOw==}]
	set tkPriv(fileImage) [image create photo -data {
R0lGODlhDAAMAKEAALLA3AAAAP//8wAAACH5BAEAAAAALAAAAAAMAAwAAAIgRI4Ha+IfWHsO
rSASvJTGhnhcV3EJlo3kh53ltF5nAhQAOw==}]
    }
    set folder $tkPriv(folderImage)
    set file $tkPriv(fileImage)
    set appPWD [pwd]
    if {[catch {
	cd $data(selectPath)
    }]} then {
	tk_messageBox -type ok -parent $w -message "Cannot change to the directory \"$data(selectPath)\".\nPermission denied." -icon warning
	cd $appPWD
	return
    }
    set entCursor [$data(ent) cget -cursor]
    set dlgCursor [$w cget -cursor]
    $data(ent) config -cursor watch
    $w config -cursor watch
    update idletasks
    tkIconList_DeleteAll $data(icons)
    foreach f [lsort -dictionary [glob -nocomplain .* *]] {
	if {[string equal $f .]} then {
	    continue
	}
	if {[string equal $f ..]} then {
	    continue
	}
	if {[file isdir ./$f]} then {
	    if {![info exists hasDoneDir($f)]} then {
		tkIconList_Add $data(icons) $folder $f
		set hasDoneDir($f) 1
	    }
	}
    }
    if {[string equal $class TkFDialog]} then {
	if {[string equal $data(filter) *]} then {
	    set files [lsort -dictionary [glob -nocomplain .* *]]
	} else {
	    set files [lsort -dictionary [eval glob -nocomplain $data(filter)]]
	}
	foreach f $files {
	    if {![file isdir ./$f]} then {
		if {![info exists hasDoneFile($f)]} then {
		    tkIconList_Add $data(icons) $file $f
		    set hasDoneFile($f) 1
		}
	    }
	}
    }
    tkIconList_Arrange $data(icons)
    set list ""
    set dir ""
    foreach subdir [file split $data(selectPath)] {
	set dir [file join $dir $subdir]
	lappend list $dir
    }
    $data(dirMenu) delete 0 end
    set var [format %s(selectPath) ::tk::dialog::file::$dataName]
    foreach path $list {
	$data(dirMenu) add command -label $path -command [list set $var $path]
    }
    cd $appPWD
    if {[string equal $class TkFDialog]} then {
	if {[string equal $data(type) open]} then {
	    $data(okBtn) config -text "Open"
	} else {
	    $data(okBtn) config -text "Save"
	}
    }
    $data(ent) config -cursor $entCursor
    $w config -cursor $dlgCursor
}
proc ::tk::dialog::file::SetPathSilently {w path} {
    upvar ::tk::dialog::file::[winfo name $w] data
    trace vdelete data(selectPath) w [list ::tk::dialog::file::SetPath $w]
    set data(selectPath) $path
    trace variable data(selectPath) w [list ::tk::dialog::file::SetPath $w]
}
proc ::tk::dialog::file::SetPath {w name1 name2 op} {
    if {[winfo exists $w]} then {
	upvar ::tk::dialog::file::[winfo name $w] data
	::tk::dialog::file::UpdateWhenIdle $w
	if {[string equal [winfo class $w] TkChooseDir]} then {
	    $data(ent) delete 0 end
	    $data(ent) insert end $data(selectPath)
	}
    }
}
proc ::tk::dialog::file::SetFilter {w type} {
    upvar ::tk::dialog::file::[winfo name $w] data
    upvar \#0 $data(icons) icons
    set data(filter) [lindex $type 1]
    $data(typeMenuBtn) config -text [lindex $type 0] -indicatoron 1
    $icons(sbar) set 0.0 0.0
    ::tk::dialog::file::UpdateWhenIdle $w
}
proc ::tk::dialog::file::ResolveFile {context text defaultext} {
    set appPWD [pwd]
    set path [::tk::dialog::file::JoinFile $context $text]
    if {![file isdirectory $path] && [string equal [file ext $path] ""]} then {
	set path "$path$defaultext"
    }
    if {[catch {file exists $path}]} then {
	return [list ERROR $path ""]
    }
    if {[file exists $path]} then {
	if {[file isdirectory $path]} then {
	    if {[catch {cd $path}]} then {
		return [list CHDIR $path ""]
	    }
	    set directory [pwd]
	    set file ""
	    set flag OK
	    cd $appPWD
	} else {
	    if {[catch {cd [file dirname $path]}]} then {
		return [list CHDIR [file dirname $path] ""]
	    }
	    set directory [pwd]
	    set file [file tail $path]
	    set flag OK
	    cd $appPWD
	}
    } else {
	set dirname [file dirname $path]
	if {[file exists $dirname]} then {
	    if {[catch {cd $dirname}]} then {
		return [list CHDIR $dirname ""]
	    }
	    set directory [pwd]
	    set file [file tail $path]
	    if {[regexp {[*]|[?]} $file]} then {
		set flag PATTERN
	    } else {
		set flag FILE
	    }
	    cd $appPWD
	} else {
	    set directory $dirname
	    set file [file tail $path]
	    set flag PATH
	}
    }
    return [list $flag $directory $file]
}
proc ::tk::dialog::file::EntFocusIn {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string compare [$data(ent) get] ""]} then {
	$data(ent) selection range 0 end
	$data(ent) icursor end
    } else {
	$data(ent) selection clear
    }
    tkIconList_Unselect $data(icons)
    if {[string equal [winfo class $w] TkFDialog]} then {
	if {[string equal $data(type) open]} then {
	    $data(okBtn) config -text "Open"
	} else {
	    $data(okBtn) config -text "Save"
	}
    }
}
proc ::tk::dialog::file::EntFocusOut {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    $data(ent) selection clear
}
proc ::tk::dialog::file::ActivateEnt {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    set text [string trim [$data(ent) get]]
    set list [::tk::dialog::file::ResolveFile $data(selectPath) $text $data(-defaultextension)]
    set flag [lindex $list 0]
    set path [lindex $list 1]
    set file [lindex $list 2]
    switch -- $flag {
    OK {
	    if {[string equal $file ""]} then {
		set data(selectPath) $path
		$data(ent) delete 0 end
	    } else {
		::tk::dialog::file::SetPathSilently $w $path
		set data(selectFile) $file
		::tk::dialog::file::Done $w
	    }
	}
    PATTERN {
	    set data(selectPath) $path
	    set data(filter) $file
	}
    FILE {
	    if {[string equal $data(type) open]} then {
		tk_messageBox -icon warning -type ok -parent $w -message "File \"[file join $path $file]\" does not exist."
		$data(ent) selection range 0 end
		$data(ent) icursor end
	    } else {
		::tk::dialog::file::SetPathSilently $w $path
		set data(selectFile) $file
		::tk::dialog::file::Done $w
	    }
	}
    PATH {
	    tk_messageBox -icon warning -type ok -parent $w -message "Directory \"$path\" does not exist."
	    $data(ent) selection range 0 end
	    $data(ent) icursor end
	}
    CHDIR {
	    tk_messageBox -type ok -parent $w -message "Cannot change to the directory \"$path\".\nPermission denied." -icon warning
	    $data(ent) selection range 0 end
	    $data(ent) icursor end
	}
    ERROR {
	    tk_messageBox -type ok -parent $w -message "Invalid file name \"$path\"." -icon warning
	    $data(ent) selection range 0 end
	    $data(ent) icursor end
	}
    }
}
proc ::tk::dialog::file::InvokeBtn {w key} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string equal [$data(okBtn) cget -text] $key]} then {
	tkButtonInvoke $data(okBtn)
    }
}
proc ::tk::dialog::file::UpDirCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string compare $data(selectPath) "/"]} then {
	set data(selectPath) [file dirname $data(selectPath)]
    }
}
proc ::tk::dialog::file::JoinFile {path file} {
    if {[string match {~*} $file] && [file exists $path/$file]} then {
	return [file join $path ./$file]
    } else {
	return [file join $path $file]
    }
}
proc ::tk::dialog::file::OkCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    set text [tkIconList_Get $data(icons)]
    if {[string compare $text ""]} then {
	set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
	if {[file isdirectory $file]} then {
	    ::tk::dialog::file::ListInvoke $w $text
	    return
	}
    }
    ::tk::dialog::file::ActivateEnt $w
}
proc ::tk::dialog::file::CancelCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    global tkPriv
    set tkPriv(selectFilePath) ""
}
proc ::tk::dialog::file::ListBrowse {w text} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string equal $text ""]} then {
	return
    }
    set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
    if {![file isdirectory $file]} then {
	$data(ent) delete 0 end
	$data(ent) insert 0 $text
	if {[string equal [winfo class $w] TkFDialog]} then {
	    if {[string equal $data(type) open]} then {
		$data(okBtn) config -text "Open"
	    } else {
		$data(okBtn) config -text "Save"
	    }
	}
    } else {
	if {[string equal [winfo class $w] TkFDialog]} then {
	    $data(okBtn) config -text "Open"
	}
    }
}
proc ::tk::dialog::file::ListInvoke {w text} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string equal $text ""]} then {
	return
    }
    set file [::tk::dialog::file::JoinFile $data(selectPath) $text]
    set class [winfo class $w]
    if {[string equal $class TkChooseDir] || [file isdirectory $file]} then {
	set appPWD [pwd]
	if {[catch {cd $file}]} then {
	    tk_messageBox -type ok -parent $w -message "Cannot change to the directory \"$file\".\nPermission denied." -icon warning
	} else {
	    cd $appPWD
	    set data(selectPath) $file
	}
    } else {
	set data(selectFile) $file
	::tk::dialog::file::Done $w
    }
}
proc ::tk::dialog::file::Done {w {selectFilePath ""}} {
    upvar ::tk::dialog::file::[winfo name $w] data
    global tkPriv
    if {[string equal $selectFilePath ""]} then {
	set selectFilePath [::tk::dialog::file::JoinFile $data(selectPath) $data(selectFile)]
	set tkPriv(selectFile) $data(selectFile)
	set tkPriv(selectPath) $data(selectPath)
	if {[file exists $selectFilePath] && [string equal $data(type) save]} then {
	    set reply [tk_messageBox -icon warning -type yesno -parent $w -message "File \"$selectFilePath\" already exists.\nDo you want to overwrite it?"]
	    if {[string equal $reply "no"]} then {
		return
	    }
	}
    }
    set tkPriv(selectFilePath) $selectFilePath
}
namespace eval ::tk::dialog {}
namespace eval ::tk::dialog::file {}
proc tkMotifFDialog {type args} {
    global tkPriv
    set dataName __tk_filedialog
    upvar ::tk::dialog::file::$dataName data
    set w [tkMotifFDialog_Create $dataName $type $args]
    ::tk::SetFocusGrab $w $data(sEnt)
    $data(sEnt) selection range 0 end
    tkwait variable tkPriv(selectFilePath)
    ::tk::RestoreFocusGrab $w $data(sEnt) withdraw
    return $tkPriv(selectFilePath)
}
proc tkMotifFDialog_Create {dataName type argList} {
    global tkPriv
    upvar ::tk::dialog::file::$dataName data
    tkMotifFDialog_Config $dataName $type $argList
    if {[string equal $data(-parent) .]} then {
	set w .$dataName
    } else {
	set w $data(-parent).$dataName
    }
    if {![winfo exists $w]} then {
	tkMotifFDialog_BuildUI $w
    } elseif {[string compare [winfo class $w] TkMotifFDialog]} {
	destroy $w
	tkMotifFDialog_BuildUI $w
    } else {
	set data(fEnt) $w.top.f1.ent
	set data(dList) $w.top.f2.a.l
	set data(fList) $w.top.f2.b.l
	set data(sEnt) $w.top.f3.ent
	set data(okBtn) $w.bot.ok
	set data(filterBtn) $w.bot.filter
	set data(cancelBtn) $w.bot.cancel
    }
    wm transient $w $data(-parent)
    tkMotifFDialog_Update $w
    ::tk::PlaceWindow $w
    wm title $w $data(-title)
    return $w
}
proc tkMotifFDialog_Config {dataName type argList} {
    upvar ::tk::dialog::file::$dataName data
    set data(type) $type
    set specs {
{-defaultextension "" "" ""}
{-filetypes "" "" ""}
{-initialdir "" "" ""}
{-initialfile "" "" ""}
{-parent "" "" "."}
{-title "" "" ""}
}
    if {![info exists data(selectPath)]} then {
	set data(selectPath) [pwd]
	set data(selectFile) ""
    }
    tclParseConfigSpec ::tk::dialog::file::$dataName $specs "" $argList
    if {[string equal $data(-title) ""]} then {
	if {[string equal $type "open"]} then {
	    set data(-title) "Open"
	} else {
	    set data(-title) "Save As"
	}
    }
    if {[string compare $data(-initialdir) ""]} then {
	if {[file isdirectory $data(-initialdir)]} then {
	    set data(selectPath) [glob $data(-initialdir)]
	} else {
	    set data(selectPath) [pwd]
	}
	set old [pwd]
	cd $data(selectPath)
	set data(selectPath) [pwd]
	cd $old
    }
    set data(selectFile) $data(-initialfile)
    set data(-filetypes) [tkFDGetFileTypes $data(-filetypes)]
    if {![info exists data(filter)]} then {
	set data(filter) *
    }
    if {![winfo exists $data(-parent)]} then {
	error "bad window path name \"$data(-parent)\""
    }
}
proc tkMotifFDialog_BuildUI {w} {
    set dataName [lindex [split $w .] end]
    upvar ::tk::dialog::file::$dataName data
    toplevel $w -class TkMotifFDialog
    set top [frame $w.top -relief raised -bd 1]
    set bot [frame $w.bot -relief raised -bd 1]
    pack $w.bot -side bottom -fill x
    pack $w.top -side top -expand yes -fill both
    set f1 [frame $top.f1]
    set f2 [frame $top.f2]
    set f3 [frame $top.f3]
    pack $f1 -side top -fill x
    pack $f3 -side bottom -fill x
    pack $f2 -expand yes -fill both
    set f2a [frame $f2.a]
    set f2b [frame $f2.b]
    grid $f2a -row 0 -column 0 -rowspan 1 -columnspan 1 -padx 4 -pady 4 -sticky news
    grid $f2b -row 0 -column 1 -rowspan 1 -columnspan 1 -padx 4 -pady 4 -sticky news
    grid rowconfig $f2 0 -minsize 0 -weight 1
    grid columnconfig $f2 0 -minsize 0 -weight 1
    grid columnconfig $f2 1 -minsize 150 -weight 2
    label $f1.lab -text "Filter:" -under 3 -anchor w
    entry $f1.ent
    pack $f1.lab -side top -fill x -padx 6 -pady 4
    pack $f1.ent -side top -fill x -padx 4 -pady 0
    set data(fEnt) $f1.ent
    set data(dList) [tkMotifFDialog_MakeSList $w $f2a Directory: 0 DList]
    set data(fList) [tkMotifFDialog_MakeSList $w $f2b Files: 2 FList]
    label $f3.lab -text "Selection:" -under 0 -anchor w
    entry $f3.ent
    pack $f3.lab -side top -fill x -padx 6 -pady 0
    pack $f3.ent -side top -fill x -padx 4 -pady 4
    set data(sEnt) $f3.ent
    set data(okBtn) [button $bot.ok -text OK -width 6 -under 0 -command [list tkMotifFDialog_OkCmd $w]]
    set data(filterBtn) [button $bot.filter -text Filter -width 6 -under 0 -command [list tkMotifFDialog_FilterCmd $w]]
    set data(cancelBtn) [button $bot.cancel -text Cancel -width 6 -under 0 -command [list tkMotifFDialog_CancelCmd $w]]
    pack $bot.ok $bot.filter $bot.cancel -padx 10 -pady 10 -expand yes -side left
    bind $w <Alt-t> [list focus $data(fEnt)]
    bind $w <Alt-d> [list focus $data(dList)]
    bind $w <Alt-l> [list focus $data(fList)]
    bind $w <Alt-s> [list focus $data(sEnt)]
    bind $w <Alt-o> [list tkButtonInvoke $bot.ok]
    bind $w <Alt-f> [list tkButtonInvoke $bot.filter]
    bind $w <Alt-c> [list tkButtonInvoke $bot.cancel]
    bind $data(fEnt) <Return> [list tkMotifFDialog_ActivateFEnt $w]
    bind $data(sEnt) <Return> [list tkMotifFDialog_ActivateSEnt $w]
    wm protocol $w WM_DELETE_WINDOW [list tkMotifFDialog_CancelCmd $w]
}
proc tkMotifFDialog_MakeSList {w f label under cmdPrefix} {
    label $f.lab -text $label -under $under -anchor w
    listbox $f.l -width 12 -height 5 -selectmode browse -exportselection 0 -xscrollcommand [list $f.h set] -yscrollcommand [list $f.v set]
    scrollbar $f.v -orient vertical -takefocus 0 -command [list $f.l yview]
    scrollbar $f.h -orient horizontal -takefocus 0 -command [list $f.l xview]
    grid $f.lab -row 0 -column 0 -sticky news -rowspan 1 -columnspan 2 -padx 2 -pady 2
    grid $f.l -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
    grid $f.v -row 1 -column 1 -rowspan 1 -columnspan 1 -sticky news
    grid $f.h -row 2 -column 0 -rowspan 1 -columnspan 1 -sticky news
    grid rowconfig $f 0 -weight 0 -minsize 0
    grid rowconfig $f 1 -weight 1 -minsize 0
    grid columnconfig $f 0 -weight 1 -minsize 0
    set list $f.l
    bind $list <Up> [list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <Down> [list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <space> [list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <1> [list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <B1-Motion> [list tkMotifFDialog_Browse$cmdPrefix $w]
    bind $list <Double-ButtonRelease-1> [list tkMotifFDialog_Activate$cmdPrefix $w]
    bind $list <Return> "tkMotifFDialog_Browse$cmdPrefix [list $w];  tkMotifFDialog_Activate$cmdPrefix [list $w]"
    bindtags $list [list Listbox $list [winfo toplevel $list] all]
    tkListBoxKeyAccel_Set $list
    return $f.l
}
proc tkMotifFDialog_InterpFilter {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    set text [string trim [$data(fEnt) get]]
    set badTilde 0
    if {[string equal [string index $text 0] ~]} then {
	set list [file split $text]
	set tilde [lindex $list 0]
	if {[catch {set tilde [glob $tilde]}]} then {
	    set badTilde 1
	} else {
	    set text [eval file join [concat $tilde [lrange $list 1 end]]]
	}
    }
    set relative 0
    if {[string equal [file pathtype $text] "relative"]} then {
	set relative 1
    } elseif {$badTilde} {
	set relative 1
    }
    if {$relative} then {
	tk_messageBox -icon warning -type ok -message "\"$text\" must be an absolute pathname"
	$data(fEnt) delete 0 end
	$data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
	return [list $data(selectPath) $data(filter)]
    }
    set resolved [::tk::dialog::file::JoinFile [file dirname $text] [file tail $text]]
    if {[file isdirectory $resolved]} then {
	set dir $resolved
	set fil $data(filter)
    } else {
	set dir [file dirname $resolved]
	set fil [file tail $resolved]
    }
    return [list $dir $fil]
}
proc tkMotifFDialog_Update {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
    $data(sEnt) delete 0 end
    $data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(selectFile)]
    tkMotifFDialog_LoadFiles $w
}
proc tkMotifFDialog_LoadFiles {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    $data(dList) delete 0 end
    $data(fList) delete 0 end
    set appPWD [pwd]
    if {[catch {cd $data(selectPath)}]} then {
	cd $appPWD
	$data(dList) insert end ".."
	return
    }
    foreach f [lsort -dictionary [glob -nocomplain .* *]] {
	if {[file isdir ./$f]} then {
	    $data(dList) insert end $f
	}
    }
    if {[string equal $data(filter) *]} then {
	set files [lsort -dictionary [glob -nocomplain .* *]]
    } else {
	set files [lsort -dictionary [glob -nocomplain $data(filter)]]
    }
    set top 0
    foreach f $files {
	if {![file isdir ./$f]} then {
	    regsub {^[.]/} $f "" f
	    $data(fList) insert end $f
	    if {[string match .* $f]} then {
		incr top
	    }
	}
    }
    $data(fList) yview $top
    cd $appPWD
}
proc tkMotifFDialog_BrowseDList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    focus $data(dList)
    if {[string equal [$data(dList) curselection] ""]} then {
	return
    }
    set subdir [$data(dList) get [$data(dList) curselection]]
    if {[string equal $subdir ""]} then {
	return
    }
    $data(fList) selection clear 0 end
    set list [tkMotifFDialog_InterpFilter $w]
    set data(filter) [lindex $list 1]
    switch -- $subdir {
    . {
	    set newSpec [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
	}
    .. {
	    set newSpec [::tk::dialog::file::JoinFile [file dirname $data(selectPath)] $data(filter)]
	}
    default {
	    set newSpec [::tk::dialog::file::JoinFile [::tk::dialog::file::JoinFile $data(selectPath) $subdir] $data(filter)]
	}
    }
    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 $newSpec
}
proc tkMotifFDialog_ActivateDList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string equal [$data(dList) curselection] ""]} then {
	return
    }
    set subdir [$data(dList) get [$data(dList) curselection]]
    if {[string equal $subdir ""]} then {
	return
    }
    $data(fList) selection clear 0 end
    switch -- $subdir {
    . {
	    set newDir $data(selectPath)
	}
    .. {
	    set newDir [file dirname $data(selectPath)]
	}
    default {
	    set newDir [::tk::dialog::file::JoinFile $data(selectPath) $subdir]
	}
    }
    set data(selectPath) $newDir
    tkMotifFDialog_Update $w
    if {[string compare $subdir ..]} then {
	$data(dList) selection set 0
	$data(dList) activate 0
    } else {
	$data(dList) selection set 1
	$data(dList) activate 1
    }
}
proc tkMotifFDialog_BrowseFList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    focus $data(fList)
    if {[string equal [$data(fList) curselection] ""]} then {
	return
    }
    set data(selectFile) [$data(fList) get [$data(fList) curselection]]
    if {[string equal $data(selectFile) ""]} then {
	return
    }
    $data(dList) selection clear 0 end
    $data(fEnt) delete 0 end
    $data(fEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(filter)]
    $data(fEnt) xview end
    $data(sEnt) delete 0 end
    $data(sEnt) insert 0 [::tk::dialog::file::JoinFile $data(selectPath) $data(selectFile)]
    $data(sEnt) xview end
}
proc tkMotifFDialog_ActivateFList {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    if {[string equal [$data(fList) curselection] ""]} then {
	return
    }
    set data(selectFile) [$data(fList) get [$data(fList) curselection]]
    if {[string equal $data(selectFile) ""]} then {
	return
    } else {
	tkMotifFDialog_ActivateSEnt $w
    }
}
proc tkMotifFDialog_ActivateFEnt {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    set list [tkMotifFDialog_InterpFilter $w]
    set data(selectPath) [lindex $list 0]
    set data(filter) [lindex $list 1]
    tkMotifFDialog_Update $w
}
proc tkMotifFDialog_ActivateSEnt {w} {
    global tkPriv
    upvar ::tk::dialog::file::[winfo name $w] data
    set selectFilePath [string trim [$data(sEnt) get]]
    set selectFile [file tail $selectFilePath]
    set selectPath [file dirname $selectFilePath]
    if {[string equal $selectFilePath ""]} then {
	tkMotifFDialog_FilterCmd $w
	return
    }
    if {[file isdirectory $selectFilePath]} then {
	set data(selectPath) [glob $selectFilePath]
	set data(selectFile) ""
	tkMotifFDialog_Update $w
	return
    }
    if {[string compare [file pathtype $selectFilePath] "absolute"]} then {
	tk_messageBox -icon warning -type ok -message "\"$selectFilePath\" must be an absolute pathname"
	return
    }
    if {![file exists $selectPath]} then {
	tk_messageBox -icon warning -type ok -message "Directory \"$selectPath\" does not exist."
	return
    }
    if {![file exists $selectFilePath]} then {
	if {[string equal $data(type) open]} then {
	    tk_messageBox -icon warning -type ok -message "File \"$selectFilePath\" does not exist."
	    return
	}
    } else {
	if {[string equal $data(type) save]} then {
	    set message [format %s%s "File \"$selectFilePath\" already exists.\n\n" "Replace existing file?"]
	    set answer [tk_messageBox -icon warning -type yesno -message $message]
	    if {[string equal $answer "no"]} then {
		return
	    }
	}
    }
    set tkPriv(selectFilePath) $selectFilePath
    set tkPriv(selectFile) $selectFile
    set tkPriv(selectPath) $selectPath
}
proc tkMotifFDialog_OkCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    tkMotifFDialog_ActivateSEnt $w
}
proc tkMotifFDialog_FilterCmd {w} {
    upvar ::tk::dialog::file::[winfo name $w] data
    tkMotifFDialog_ActivateFEnt $w
}
proc tkMotifFDialog_CancelCmd {w} {
    global tkPriv
    set tkPriv(selectFilePath) ""
    set tkPriv(selectFile) ""
    set tkPriv(selectPath) ""
}
proc tkListBoxKeyAccel_Set {w} {
    bind Listbox <Any-KeyPress> ""
    bind $w <Destroy> [list tkListBoxKeyAccel_Unset $w]
    bind $w <Any-KeyPress> [list tkListBoxKeyAccel_Key $w %A]
}
proc tkListBoxKeyAccel_Unset {w} {
    global tkPriv
    catch {after cancel $tkPriv(lbAccel,$w,afterId)}
    catch {unset tkPriv(lbAccel,$w)}
    catch {unset tkPriv(lbAccel,$w,afterId)}
}
proc tkListBoxKeyAccel_Key {w key} {
    global tkPriv
    append tkPriv(lbAccel,$w) $key
    tkListBoxKeyAccel_Goto $w $tkPriv(lbAccel,$w)
    catch {
	after cancel $tkPriv(lbAccel,$w,afterId)
    }
    set tkPriv(lbAccel,$w,afterId) [after 500 [list tkListBoxKeyAccel_Reset $w]]
}
proc tkListBoxKeyAccel_Goto {w string} {
    global tkPriv
    set string [string tolower $string]
    set end [$w index end]
    set theIndex -1
    for {set i 0} {$i < $end} {incr i} {
	set item [string tolower [$w get $i]]
	if {[string compare $string $item] >= 0} then {
	    set theIndex $i
	}
	if {[string compare $string $item] <= 0} then {
	    set theIndex $i
	    break
	}
    }
    if {$theIndex >= 0} then {
	$w selection clear 0 end
	$w selection set $theIndex $theIndex
	$w activate $theIndex
	$w see $theIndex
    }
}
proc tkListBoxKeyAccel_Reset {w} {
    global tkPriv
    catch {unset tkPriv(lbAccel,$w)}
}
package provide tcltest 1.0
namespace eval tcltest {
    set procList [list test cleanupTests saveState restoreState normalizeMsg makeFile removeFile makeDirectory removeDirectory viewFile bytestring safeFetch threadReap getMatchingFiles loadTestedCommands normalizePath]
    foreach proc $procList {
	namespace export $proc
    }
    if {![info exists verbose]} then {
	variable verbose "b"
    }
    if {![info exists match]} then {
	variable match {}
    }
    if {![info exists skip]} then {
	variable skip {}
    }
    if {![info exists matchFiles]} then {
	variable matchFiles {*.test}
    }
    if {![info exists skipFiles]} then {
	variable skipFiles {}
    }
    if {![info exists preserveCore]} then {
	variable preserveCore 0
    }
    if {![info exists outputChannel]} then {
	variable outputChannel stdout
    }
    if {![info exists errorChannel]} then {
	variable errorChannel stderr
    }
    if {![info exists debug]} then {
	variable debug 0
    }
    if {![info exists parameters]} then {
	variable parameters {}
    }
    if {![info exists numTestFiles]} then {
	variable numTestFiles 0
    }
    if {![info exists testSingleFile]} then {
	variable testSingleFile true
    }
    if {![info exists currentFailure]} then {
	variable currentFailure false
    }
    if {![info exists failFiles]} then {
	variable failFiles {}
    }
    if {![info exists filesMade]} then {
	variable filesMade {}
    }
    if {![info exists filesExisted]} then {
	variable filesExisted {}
    }
    if {![info exists createdNewFiles]} then {
	variable createdNewFiles
	array set ::tcltest::createdNewFiles {}
    }
    if {![info exists numTests]} then {
	variable numTests
	array set ::tcltest::numTests [list Total 0 Passed 0 Skipped 0 Failed 0]
    }
    if {![info exists skippedBecause]} then {
	variable skippedBecause
	array set ::tcltest::skippedBecause {}
    }
    if {![info exists testConstraints]} then {
	variable testConstraints
	array set ::tcltest::testConstraints {}
    }
    if {![info exists limitConstraints]} then {
	variable limitConstraints false
    }
    if {![info exists loadScript]} then {
	variable loadScript {}
    }
    if {![info exists mainThread]} then {
	variable mainThread 1
	if {[info commands thread::id] != {}} then {
	    set mainThread [thread::id]
	} elseif {[info commands testthread] != {}} {
	    set mainThread [testthread id]
	}
    }
    if {![info exists originalEnv]} then {
	variable originalEnv
	array set ::tcltest::originalEnv [array get ::env]
    }
    if {![info exists workingDirectory]} then {
	variable workingDirectory [pwd]
    }
    if {![info exists temporaryDirectory]} then {
	variable temporaryDirectory $workingDirectory
    }
    if {![info exists testsDirectory]} then {
	set oldpwd [pwd]
	catch {cd [file join [file dirname [info script]] .. .. tests]}
	variable testsDirectory [pwd]
	cd $oldpwd
	unset oldpwd
    }
    if {![info exists saveState]} then {
	variable saveState {}
    }
    if {![info exists isoLocale]} then {
	variable isoLocale fr
	switch $tcl_platform(platform) {
	"unix" {
		switch -exact -- $tcl_platform(os) {
		"FreeBSD" {
			set ::tcltest::isoLocale fr_FR.ISO_8859-1
		    }
		HP-UX {
			set ::tcltest::isoLocale fr_FR.iso88591
		    }
		Linux -
		IRIX {
			set ::tcltest::isoLocale fr
		    }
		default {
			#if you want to test those.
			set ::tcltest::isoLocale iso_8859_1
		    }
		}
	    }
	"windows" {
		set ::tcltest::isoLocale French
	    }
	}
    }
    if {![info exists tcltest]} then {
	variable tcltest [info nameofexecutable]
    }
    if {![info exists originalTclPlatform]} then {
	variable originalTclPlatform [array get tcl_platform]
    }
    if {![info exists coreModificationTime]} then {
	if {[file exists [file join $::tcltest::workingDirectory core]]} then {
	    variable coreModificationTime [file mtime [file join $::tcltest::workingDirectory core]]
	}
    }
    if {![info exists version]} then {
	variable version 8.3
    }
    if {![info exists patchLevel]} then {
	variable patchLevel 8.3.0
    }
}
proc ::tcltest::DebugPuts {level string} {
    variable debug
    if {$debug >= $level} then {
	puts $string
    }
}
proc ::tcltest::DebugPArray {level arrayvar} {
    variable debug
    if {$debug >= $level} then {
	catch {upvar $arrayvar $arrayvar}
	parray $arrayvar
    }
}
proc ::tcltest::DebugDo {level script} {
    variable debug
    if {$debug >= $level} then {
	uplevel $script
    }
}
proc ::tcltest::AddToSkippedBecause {constraint} {
    if {[info exists ::tcltest::skippedBecause($constraint)]} then {
	incr ::tcltest::skippedBecause($constraint)
    } else {
	set ::tcltest::skippedBecause($constraint) 1
    }
    return
}
proc ::tcltest::PrintError {errorMsg} {
    set InitialMessage "Error:  "
    set InitialMsgLen [string length $InitialMessage]
    puts -nonewline $::tcltest::errorChannel $InitialMessage
    set endingIndex [string length $errorMsg]
    if {$endingIndex < 80} then {
	puts $::tcltest::errorChannel $errorMsg
    } else {
	set beginningIndex [string last " " [string range $errorMsg 0 [expr {80 - $InitialMsgLen}]]]
	puts $::tcltest::errorChannel [string range $errorMsg 0 $beginningIndex]
	while {$beginningIndex != "end"} {
	    puts -nonewline $::tcltest::errorChannel [string repeat " " $InitialMsgLen]
	    if {[expr {$endingIndex - $beginningIndex}] < 72} then {
		puts $::tcltest::errorChannel [string trim [string range $errorMsg $beginningIndex end]]
		set beginningIndex end
	    } else {
		set newEndingIndex [expr [string last " " [string range $errorMsg $beginningIndex [expr {$beginningIndex + 72}]]] + $beginningIndex]
		if {($newEndingIndex <= 0) ||($newEndingIndex <= $beginningIndex)} then {
		    set newEndingIndex end
		}
		puts $::tcltest::errorChannel [string trim [string range $errorMsg $beginningIndex $newEndingIndex]]
		set beginningIndex $newEndingIndex
	    }
	}
    }
    flush $::tcltest::errorChannel
    return
}
if {[namespace inscope ::tcltest info procs initConstraintsHook] == {}} then {
    proc ::tcltest::initConstraintsHook {} { }
}
proc ::tcltest::initConstraints {} {
    global tcl_platform tcl_interactive tk_version
    trace variable ::tcltest::testConstraints r ::tcltest::safeFetch
    proc ::tcltest::safeFetch {n1 n2 op} {
	if {($n2 != {}) &&([info exists ::tcltest::testConstraints($n2)] == 0)} then {
	    set ::tcltest::testConstraints($n2) 0
	}
    }
    ::tcltest::initConstraintsHook
    set ::tcltest::testConstraints(unixOnly) [string equal $tcl_platform(platform) "unix"]
    set ::tcltest::testConstraints(macOnly) [string equal $tcl_platform(platform) "macintosh"]
    set ::tcltest::testConstraints(pcOnly) [string equal $tcl_platform(platform) "windows"]
    set ::tcltest::testConstraints(unix) $::tcltest::testConstraints(unixOnly)
    set ::tcltest::testConstraints(mac) $::tcltest::testConstraints(macOnly)
    set ::tcltest::testConstraints(pc) $::tcltest::testConstraints(pcOnly)
    set ::tcltest::testConstraints(unixOrPc) [expr {$::tcltest::testConstraints(unix) || $::tcltest::testConstraints(pc)}]
    set ::tcltest::testConstraints(macOrPc) [expr {$::tcltest::testConstraints(mac) || $::tcltest::testConstraints(pc)}]
    set ::tcltest::testConstraints(macOrUnix) [expr {$::tcltest::testConstraints(mac) || $::tcltest::testConstraints(unix)}]
    set ::tcltest::testConstraints(nt) [string equal $tcl_platform(os) "Windows NT"]
    set ::tcltest::testConstraints(95) [string equal $tcl_platform(os) "Windows 95"]
    set ::tcltest::testConstraints(98) [string equal $tcl_platform(os) "Windows 98"]
    set ::tcltest::testConstraints(tempNotPc) [expr {!$::tcltest::testConstraints(pc)}]
    set ::tcltest::testConstraints(tempNotMac) [expr {!$::tcltest::testConstraints(mac)}]
    set ::tcltest::testConstraints(tempNotUnix) [expr {!$::tcltest::testConstraints(unix)}]
    set ::tcltest::testConstraints(pcCrash) [expr {!$::tcltest::testConstraints(pc)}]
    set ::tcltest::testConstraints(macCrash) [expr {!$::tcltest::testConstraints(mac)}]
    set ::tcltest::testConstraints(unixCrash) [expr {!$::tcltest::testConstraints(unix)}]
    set ::tcltest::testConstraints(emptyTest) 0
    set ::tcltest::testConstraints(knownBug) 0
    set ::tcltest::testConstraints(nonPortable) 0
    set ::tcltest::testConstraints(userInteraction) 0
    if {[info exists tcl_interactive]} then {
	set ::tcltest::testConstraints(interactive) $::tcl_interactive
    } else {
	set ::tcltest::testConstraints(interactive) 0
    }
    set ::tcltest::testConstraints(root) 0
    set ::tcltest::testConstraints(notRoot) 1
    set user {}
    if {[string equal $tcl_platform(platform) "unix"]} then {
	catch {set user [exec whoami]}
	if {[string equal $user ""]} then {
	    catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
	}
	if {([string equal $user "root"]) ||([string equal $user ""])} then {
	    set ::tcltest::testConstraints(root) 1
	    set ::tcltest::testConstraints(notRoot) 0
	}
    }
    if {[catch {set f [open defs r]}]} then {
	set ::tcltest::testConstraints(nonBlockFiles) 1
    } else {
	if {[catch {fconfigure $f -blocking off}] == 0} then {
	    set ::tcltest::testConstraints(nonBlockFiles) 1
	} else {
	    set ::tcltest::testConstraints(nonBlockFiles) 0
	}
	close $f
    }
    if {[string equal $tcl_platform(platform) "unix"]} then {
	if {[catch {exec uname -X | fgrep {Release = 3.2v}}] == 0} then {
	    set ::tcltest::testConstraints(asyncPipeClose) 0
	} else {
	    set ::tcltest::testConstraints(asyncPipeClose) 1
	}
    } else {
	set ::tcltest::testConstraints(asyncPipeClose) 1
    }
    set ::tcltest::testConstraints(eformat) 1
    if {![string equal "[format %g 5e-5]" "5e-05"]} then {
	set ::tcltest::testConstraints(eformat) 0
    }
    set ::tcltest::testConstraints(unixExecs) 1
    if {[string equal $tcl_platform(platform) "macintosh"]} then {
	set ::tcltest::testConstraints(unixExecs) 0
    }
    if {($::tcltest::testConstraints(unixExecs) == 1) &&([string equal $tcl_platform(platform) "windows"])} then {
	if {[catch {exec cat defs}] == 1} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec echo hello}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec sh -c echo hello}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec wc defs}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {$::tcltest::testConstraints(unixExecs) == 1} then {
	    exec echo hello > removeMe
	    if {[catch {exec rm removeMe}] == 1} then {
		set ::tcltest::testConstraints(unixExecs) 0
	    }
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec sleep 1}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec fgrep unixExecs defs}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec ps}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec echo abc > removeMe}] == 0) &&([catch {exec chmod 644 removeMe}] == 1) &&([catch {exec rm removeMe}] == 0)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	} else {
	    catch {exec rm -f removeMe}
	}
	if {($::tcltest::testConstraints(unixExecs) == 1) &&([catch {exec mkdir removeMe}] == 1)} then {
	    set ::tcltest::testConstraints(unixExecs) 0
	} else {
	    catch {exec rm -r removeMe}
	}
    }
    if {![info exists tk_version]} then {
	set tcltest [info nameofexecutable]
	if {$tcltest == "{}"} then {
	    set tcltest {}
	}
    }
    set ::tcltest::testConstraints(stdio) 0
    catch {
	catch {file delete -force tmp}
	set f [open tmp w]
	puts $f {
exit
}
	close $f
	set f [open "|[list $tcltest tmp]" r]
	close $f
	set ::tcltest::testConstraints(stdio) 1
    }
    catch {file delete -force tmp}
    catch {socket} msg
    set ::tcltest::testConstraints(socket) [expr {$msg != "sockets are not available on this system"}]
    if {[info commands testlocale] == ""} then {
	set ::tcltest::testConstraints(hasIsoLocale) 0
    } else {
	set ::tcltest::testConstraints(hasIsoLocale) [string length [::tcltest::set_iso8859_1_locale]]
	::tcltest::restore_locale
    }
}
if {[namespace inscope ::tcltest info procs PrintUsageInfoHook] == {}} then {
    proc ::tcltest::PrintUsageInfoHook {} { }
}
proc ::tcltest::PrintUsageInfo {} {
    puts [format "Usage: [file tail [info nameofexecutable]]  script ?-help? ?flag value? ... \n Available flags (and valid input values) are: \n -help          \t Display this usage information. \n -verbose level \t Takes any combination of the values \n \t                 'p', 's' and 'b'.  Test suite will \n \t                 display all passed tests if 'p' is \n \t                 specified, all skipped tests if 's' \n \t                 is specified, and the bodies of \n \t              \
        failed tests if 'b' is specified. \n \t                 The default value is 'b'. \n -constraints list\t Do not skip the listed constraints\n -limitconstraints bool\t Only run tests with the constraints\n \t                 listed in -constraints.\n -match pattern \t Run all tests within the specified \n \t                 files that match the glob pattern \n \t                 given. \n -skip pattern  \t Skip all tests within the set of \n \t                 specified tests (via\
      -match) and \n \t                 files that match the glob pattern \n \t                 given. \n -file pattern  \t Run tests in all test files that \n \t                 match the glob pattern given. \n -notfile pattern\t Skip all test files that match the \n \t                 glob pattern given. \n -preservecore level \t If 2, save any core files produced \n \t                 during testing in the directory \n \t                 specified by -tmpdir. If 1, notify the\n \t          \
            user if core files are created. The default \n \t                 is $::tcltest::preserveCore. \n -tmpdir directory\t Save temporary files in the specified\n \t                 directory.  The default value is \n \t                 $::tcltest::temporaryDirectory. \n -testdir directories\t Search tests in the specified\n \t                 directories.  The default value is \n \t                 $::tcltest::testsDirectory. \n -outfile file    \t Send output from test runs to the \n\
      \t                 specified file.  The default is \n \t                 stdout. \n -errfile file    \t Send errors from test runs to the \n \t                 specified file.  The default is \n \t                 stderr. \n -loadfile file   \t Read the script to load the tested \n \t                 commands from the specified file. \n -load script     \t Specifies the script to load the tested \n \t                 commands. \n -debug level     \t Internal debug flag."]
    ::tcltest::PrintUsageInfoHook
    return
}
proc ::tcltest::CheckDirectory {rw dir errMsg} {
    if {![file isdir $dir]} then {
	::tcltest::PrintError "$errMsg \"$dir\" is not a directory"
	exit 1
    } elseif {([string first w $rw] >= 0) && ![file writable $dir]} {
	::tcltest::PrintError "$errMsg \"$dir\" is not writeable"
	exit 1
    } elseif {([string first r $rw] >= 0) && ![file readable $dir]} {
	::tcltest::PrintError "$errMsg \"$dir\" is not readable"
	exit 1
    }
}
proc ::tcltest::normalizePath {pathVar} {
    upvar $pathVar path
    set oldpwd [pwd]
    catch {cd $path}
    set path [pwd]
    cd $oldpwd
}
proc ::tcltest::MakeAbsolutePath {pathVar {prefix {}}} {
    upvar $pathVar path
    if {![string equal [file pathtype $path] "absolute"]} then {
	if {$prefix == {}} then {
	    set prefix [pwd]
	}
	set path [file join $prefix $path]
    }
}
if {[namespace inscope ::tcltest info procs processCmdLineArgsAddFlagsHook] == {}} then {
    proc ::tcltest::processCmdLineArgsAddFlagsHook {} { }
}
if {[namespace inscope ::tcltest info procs processCmdLineArgsHook] == {}} then {
    proc ::tcltest::processCmdLineArgsHook {flag} { }
}
proc ::tcltest::processCmdLineArgs {} {
    global argv
    if {(![info exists argv]) ||([llength $argv] < 1)} then {
	set flagArray {}
    } else {
	set flagArray $argv
    }
    if {([lsearch -exact $flagArray {-help}] != -1) ||([lsearch -exact $flagArray {-h}] != -1)} then {
	::tcltest::PrintUsageInfo
	exit 1
    }
    if {[catch {array set flag $flagArray}]} then {
	::tcltest::PrintError "odd number of arguments specified on command line: \ 
$argv"
	::tcltest::PrintUsageInfo
	exit 1
    }
    lappend defaultFlags -verbose -match -skip -constraints -outfile -errfile -debug -tmpdir -file -notfile -preservecore -limitconstraints -args -testdir -load -loadfile
    set defaultFlags [concat $defaultFlags [::tcltest::processCmdLineArgsAddFlagsHook]]
    foreach arg $defaultFlags {
	set abbrev [string range $arg 0 1]
	if {([info exists flag($abbrev)]) &&([lsearch -exact $flagArray $arg] < [lsearch -exact $flagArray $abbrev])} then {
	    set flag($arg) $flag($abbrev)
	}
    }
    if {[info exists flag(-args)]} then {
	set ::tcltest::parameters $flag(-args)
    }
    if {[info exists flag(-verbose)]} then {
	set ::tcltest::verbose $flag(-verbose)
    }
    if {[info exists flag(-match)]} then {
	set ::tcltest::match $flag(-match)
    }
    if {[info exists flag(-skip)]} then {
	set ::tcltest::skip $flag(-skip)
    }
    if {[info exists flag(-file)]} then {
	set ::tcltest::matchFiles $flag(-file)
    }
    if {[info exists flag(-notfile)]} then {
	set ::tcltest::skipFiles $flag(-notfile)
    }
    if {[info exists flag(-constraints)]} then {
	foreach elt $flag(-constraints) {
	    set ::tcltest::testConstraints($elt) 1
	}
    }
    if {[info exists flag(-limitconstraints)]} then {
	if {![info exists flag(-constraints)]} then {
	    puts "You can only use the -limitconstraints flag with  -constraints"
	    exit 1
	}
	set ::tcltest::limitConstraints $flag(-limitconstraints)
	foreach elt [array names ::tcltest::testConstraints] {
	    if {[lsearch -exact $flag(-constraints) $elt] == -1} then {
		set ::tcltest::testConstraints($elt) 0
	    }
	}
    }
    set tmpDirError ""
    if {[info exists flag(-tmpdir)]} then {
	set ::tcltest::temporaryDirectory $flag(-tmpdir)
	MakeAbsolutePath ::tcltest::temporaryDirectory
	set tmpDirError "bad argument \"$flag(-tmpdir)\" to -tmpdir: "
    }
    if {[file exists $::tcltest::temporaryDirectory]} then {
	::tcltest::CheckDirectory rw $::tcltest::temporaryDirectory $tmpDirError
    } else {
	file mkdir $::tcltest::temporaryDirectory
    }
    normalizePath ::tcltest::temporaryDirectory
    set testDirError ""
    if {[info exists flag(-testdir)]} then {
	set ::tcltest::testsDirectory $flag(-testdir)
	MakeAbsolutePath ::tcltest::testsDirectory
	set testDirError "bad argument \"$flag(-testdir)\" to -testdir: "
    }
    if {[file exists $::tcltest::testsDirectory]} then {
	::tcltest::CheckDirectory r $::tcltest::testsDirectory $testDirError
    } else {
	::tcltest::PrintError "$testDirError \"$::tcltest::testsDirectory\"  does not exist"
	exit 1
    }
    normalizePath ::tcltest::testsDirectory
    foreach file [glob -nocomplain [file join $::tcltest::temporaryDirectory *]] {
	lappend ::tcltest::filesExisted [file tail $file]
    }
    if {[info exists flag(-outfile)]} then {
	set tmp $flag(-outfile)
	MakeAbsolutePath tmp $::tcltest::temporaryDirectory
	set ::tcltest::outputChannel [open $tmp w]
    }
    if {[info exists flag(-errfile)]} then {
	set tmp $flag(-errfile)
	MakeAbsolutePath tmp $::tcltest::temporaryDirectory
	set ::tcltest::errorChannel [open $tmp w]
    }
    if {[info exists flag(-load)] &&([lsearch -exact $flagArray -load] > [lsearch -exact $flagArray -loadfile])} then {
	set ::tcltest::loadScript $flag(-load)
    }
    if {[info exists flag(-loadfile)] &&([lsearch -exact $flagArray -loadfile] > [lsearch -exact $flagArray -load])} then {
	set tmp $flag(-loadfile)
	MakeAbsolutePath tmp $::tcltest::temporaryDirectory
	set tmp [open $tmp r]
	set ::tcltest::loadScript [read $tmp]
	close $tmp
    }
    if {[info exists flag(-debug)]} then {
	set ::tcltest::debug $flag(-debug)
    }
    if {[info exists flag(-preservecore)]} then {
	set ::tcltest::preserveCore $flag(-preservecore)
    }
    ::tcltest::processCmdLineArgsHook [array get flag]
    DebugPuts 2 "Flags passed into tcltest:"
    DebugPArray 2 flag
    DebugPuts 2 "::tcltest::debug              = $::tcltest::debug"
    DebugPuts 2 "::tcltest::testsDirectory     = $::tcltest::testsDirectory"
    DebugPuts 2 "::tcltest::workingDirectory   = $::tcltest::workingDirectory"
    DebugPuts 2 "::tcltest::temporaryDirectory = $::tcltest::temporaryDirectory"
    DebugPuts 2 "::tcltest::outputChannel      = $::tcltest::outputChannel"
    DebugPuts 2 "::tcltest::errorChannel       = $::tcltest::errorChannel"
    DebugPuts 2 "Original environment (::tcltest::originalEnv):"
    DebugPArray 2 ::tcltest::originalEnv
    DebugPuts 2 "Constraints:"
    DebugPArray 2 ::tcltest::testConstraints
}
proc ::tcltest::loadTestedCommands {} {
    if {$::tcltest::loadScript == {}} then {
	return
    }
    uplevel #0 $::tcltest::loadScript
}
proc ::tcltest::cleanupTests {{calledFromAllFile 0}} {
    set testFileName [file tail [info script]]
    ::tcltest::cleanupTestsHook
    if {!$calledFromAllFile} then {
	foreach file $::tcltest::filesMade {
	    if {[file exists $file]} then {
		catch {file delete -force $file}
	    }
	}
	set currentFiles {}
	foreach file [glob -nocomplain [file join $::tcltest::temporaryDirectory *]] {
	    lappend currentFiles [file tail $file]
	}
	set newFiles {}
	foreach file $currentFiles {
	    if {[lsearch -exact $::tcltest::filesExisted $file] == -1} then {
		lappend newFiles $file
	    }
	}
	set ::tcltest::filesExisted $currentFiles
	if {[llength $newFiles] > 0} then {
	    set ::tcltest::createdNewFiles($testFileName) $newFiles
	}
    }
    if {$calledFromAllFile || $::tcltest::testSingleFile} then {
	puts -nonewline $::tcltest::outputChannel "$testFileName:"
	foreach index [list "Total" "Passed" "Skipped" "Failed"] {
	    puts -nonewline $::tcltest::outputChannel "\t$index\t$::tcltest::numTests($index)"
	}
	puts $::tcltest::outputChannel ""
	if {$calledFromAllFile} then {
	    puts $::tcltest::outputChannel "Sourced $::tcltest::numTestFiles Test Files."
	    set ::tcltest::numTestFiles 0
	    if {[llength $::tcltest::failFiles] > 0} then {
		puts $::tcltest::outputChannel "Files with failing tests: $::tcltest::failFiles"
		set ::tcltest::failFiles {}
	    }
	}
	set constraintList [array names ::tcltest::skippedBecause]
	if {[llength $constraintList] > 0} then {
	    puts $::tcltest::outputChannel "Number of tests skipped for each constraint:"
	    foreach constraint [lsort $constraintList] {
		puts $::tcltest::outputChannel "\t$::tcltest::skippedBecause($constraint)\t$constraint"
		unset ::tcltest::skippedBecause($constraint)
	    }
	}
	set testFilesThatTurded [lsort [array names ::tcltest::createdNewFiles]]
	if {[llength $testFilesThatTurded] > 0} then {
	    puts $::tcltest::outputChannel "Warning: files left behind:"
	    foreach testFile $testFilesThatTurded {
		puts $::tcltest::outputChannel "\t$testFile:\t$::tcltest::createdNewFiles($testFile)"
		unset ::tcltest::createdNewFiles($testFile)
	    }
	}
	set ::tcltest::filesMade {}
	foreach index [list "Total" "Passed" "Skipped" "Failed"] {
	    set ::tcltest::numTests($index) 0
	}
	global tk_version tcl_interactive
	if {[info exists tk_version] && ![info exists tcl_interactive]} then {
	    exit
	}
    } else {
	incr ::tcltest::numTestFiles
	if {($::tcltest::currentFailure) &&([lsearch -exact $::tcltest::failFiles $testFileName] == -1)} then {
	    lappend ::tcltest::failFiles $testFileName
	}
	set ::tcltest::currentFailure false
	set newEnv {}
	set changedEnv {}
	set removedEnv {}
	foreach index [array names ::env] {
	    if {![info exists ::tcltest::originalEnv($index)]} then {
		lappend newEnv $index
		unset ::env($index)
	    } else {
		if {$::env($index) != $::tcltest::originalEnv($index)} then {
		    lappend changedEnv $index
		    set ::env($index) $::tcltest::originalEnv($index)
		}
	    }
	}
	foreach index [array names ::tcltest::originalEnv] {
	    if {![info exists ::env($index)]} then {
		lappend removedEnv $index
		set ::env($index) $::tcltest::originalEnv($index)
	    }
	}
	if {[llength $newEnv] > 0} then {
	    puts $::tcltest::outputChannel "env array elements created:\t$newEnv"
	}
	if {[llength $changedEnv] > 0} then {
	    puts $::tcltest::outputChannel "env array elements changed:\t$changedEnv"
	}
	if {[llength $removedEnv] > 0} then {
	    puts $::tcltest::outputChannel "env array elements removed:\t$removedEnv"
	}
	set changedTclPlatform {}
	foreach index [array names ::tcltest::originalTclPlatform] {
	    if {$::tcl_platform($index) != $::tcltest::originalTclPlatform($index)} then {
		lappend changedTclPlatform $index
		set ::tcl_platform($index) $::tcltest::originalTclPlatform($index)
	    }
	}
	if {[llength $changedTclPlatform] > 0} then {
	    puts $::tcltest::outputChannel "tcl_platform array elements changed:\t$changedTclPlatform"
	}
	if {[file exists [file join $::tcltest::workingDirectory core]]} then {
	    if {$::tcltest::preserveCore > 1} then {
		puts $::tcltest::outputChannel "produced core file!  Moving file to:  [file join $::tcltest::temporaryDirectory core-$name]"
		flush $::tcltest::outputChannel
		catch {file rename -force [file join $::tcltest::workingDirectory core] [file join $::tcltest::temporaryDirectory core-$name]} msg
		if {[string length $msg] > 0} then {
		    ::tcltest::PrintError "Problem renaming file: $msg"
		}
	    } else {
		if {[info exists ::tcltest::coreModificationTime]} then {
		    if {$::tcltest::coreModificationTime != [file mtime [file join $::tcltest::workingDirectory core]]} then {
			puts $::tcltest::outputChannel "A core file was created!"
		    }
		} else {
		    puts $::tcltest::outputChannel "A core file was created!"
		}
	    }
	}
    }
}
if {[namespace inscope ::tcltest info procs cleanupTestsHook] == {}} then {
    proc ::tcltest::cleanupTestsHook {} { }
}
proc ::tcltest::test {name description script expectedAnswer args} {
    DebugPuts 3 "Running $name ($description)"
    incr ::tcltest::numTests(Total)
    foreach pattern $::tcltest::skip {
	if {[string match $pattern $name]} then {
	    incr ::tcltest::numTests(Skipped)
	    DebugDo 1 {::tcltest::AddToSkippedBecause userSpecifiedSkip}
	    return
	}
    }
    if {[llength $::tcltest::match] > 0} then {
	set ok 0
	foreach pattern $::tcltest::match {
	    if {[string match $pattern $name]} then {
		set ok 1
		break
	    }
	}
	if {!$ok} then {
	    incr ::tcltest::numTests(Skipped)
	    DebugDo 1 {::tcltest::AddToSkippedBecause userSpecifiedNonMatch}
	    return
	}
    }
    set i [llength $args]
    if {$i == 0} then {
	set constraints {}
	if {$::tcltest::limitConstraints} then {
	    ::tcltest::AddToSkippedBecause userSpecifiedLimitConstraint
	    incr ::tcltest::numTests(Skipped)
	    return
	}
    } elseif {$i == 1} {
	set constraints $script
	set script $expectedAnswer
	set expectedAnswer [lindex $args 0]
	set doTest 0
	if {[string match {*[$\[]*} $constraints] != 0} then {
	    catch {set doTest [uplevel #0 expr $constraints]}
	} elseif {[regexp {[^.a-zA-Z0-9 ]+} $constraints] != 0} {
	    regsub -all {[.\w]+} $constraints {$::tcltest::testConstraints(&)} c
	    catch {set doTest [eval expr $c]}
	} else {
	    set doTest 1
	    foreach constraint $constraints {
		if {(![info exists ::tcltest::testConstraints($constraint)]) ||(!$::tcltest::testConstraints($constraint))} then {
		    set doTest 0
		    set constraints $constraint
		    break
		}
	    }
	}
	if {$doTest == 0} then {
	    if {[string first s $::tcltest::verbose] != -1} then {
		puts $::tcltest::outputChannel "++++ $name SKIPPED: $constraints"
	    }
	    incr ::tcltest::numTests(Skipped)
	    ::tcltest::AddToSkippedBecause $constraints
	    return
	}
    } else {
	error "wrong # args: must be \"test name description ?constraints? script expectedAnswer\""
    }
    if {$::tcltest::preserveCore} then {
	set currentTclPlatform [array get tcl_platform]
	array set tcl_platform $::tcltest::originalTclPlatform
	if {[file exists [file join $::tcltest::workingDirectory core]]} then {
	    set coreModTime [file mtime [file join $::tcltest::workingDirectory core]]
	}
	array set tcl_platform $currentTclPlatform
    }
    if {[info commands memory] != {}} then {
	memory tag $name
    }
    set code [catch {uplevel $script} actualAnswer]
    if {([string equal $actualAnswer $expectedAnswer]) &&($code == 0)} then {
	incr ::tcltest::numTests(Passed)
	if {[string first p $::tcltest::verbose] != -1} then {
	    puts $::tcltest::outputChannel "++++ $name PASSED"
	}
    } else {
	incr ::tcltest::numTests(Failed)
	set ::tcltest::currentFailure true
	if {[string first b $::tcltest::verbose] == -1} then {
	    set script ""
	}
	puts $::tcltest::outputChannel "\n==== $name $description FAILED"
	if {$script != ""} then {
	    puts $::tcltest::outputChannel "==== Contents of test case:"
	    puts $::tcltest::outputChannel $script
	}
	if {$code != 0} then {
	    if {$code == 1} then {
		puts $::tcltest::outputChannel "==== Test generated error:"
		puts $::tcltest::outputChannel $actualAnswer
	    } elseif {$code == 2} {
		puts $::tcltest::outputChannel "==== Test generated return exception;  result was:"
		puts $::tcltest::outputChannel $actualAnswer
	    } elseif {$code == 3} {
		puts $::tcltest::outputChannel "==== Test generated break exception"
	    } elseif {$code == 4} {
		puts $::tcltest::outputChannel "==== Test generated continue exception"
	    } else {
		puts $::tcltest::outputChannel "==== Test generated exception $code;  message was:"
		puts $::tcltest::outputChannel $actualAnswer
	    }
	} else {
	    puts $::tcltest::outputChannel "---- Result was:\n$actualAnswer"
	}
	puts $::tcltest::outputChannel "---- Result should have been:\n$expectedAnswer"
	puts $::tcltest::outputChannel "==== $name FAILED\n"
    }
    if {$::tcltest::preserveCore} then {
	set currentTclPlatform [array get tcl_platform]
	if {[file exists [file join $::tcltest::workingDirectory core]]} then {
	    if {$::tcltest::preserveCore > 1} then {
		puts $::tcltest::outputChannel "==== $name produced core file!  Moving file to:  [file join $::tcltest::temporaryDirectory core-$name]"
		catch {file rename -force [file join $::tcltest::workingDirectory core] [file join $::tcltest::temporaryDirectory core-$name]} msg
		if {[string length $msg] > 0} then {
		    ::tcltest::PrintError "Problem renaming file: $msg"
		}
	    } else {
		if {[info exists coreModTime]} then {
		    if {$coreModTime != [file mtime [file join $::tcltest::workingDirectory core]]} then {
			puts $::tcltest::outputChannel "==== $name produced core file!"
		    }
		} else {
		    puts $::tcltest::outputChannel "==== $name produced core file!"
		}
	    }
	}
	array set tcl_platform $currentTclPlatform
    }
}
proc ::tcltest::getMatchingFiles {args} {
    set matchingFiles {}
    if {[llength $args]} then {
	set searchDirectory $args
    } else {
	set searchDirectory [list $::tcltest::testsDirectory]
    }
    foreach directory $searchDirectory {
	set matchFileList {}
	foreach match $::tcltest::matchFiles {
	    set matchFileList [concat $matchFileList [glob -nocomplain [file join $directory $match]]]
	}
	if {[string compare {} $::tcltest::skipFiles]} then {
	    set skipFileList {}
	    foreach skip $::tcltest::skipFiles {
		set skipFileList [concat $skipFileList [glob -nocomplain [file join $directory $skip]]]
	    }
	    foreach file $matchFileList {
		if {([lsearch -exact $skipFileList $file] == -1) &&(![string match l.*.test [file tail $file]])} then {
		    lappend matchingFiles $file
		}
	    }
	} else {
	    set matchingFiles [concat $matchingFiles $matchFileList]
	}
    }
    if {[string equal $matchingFiles {}]} then {
	::tcltest::PrintError "No test files remain after applying  your match and skip patterns!"
    }
    return $matchingFiles
}
proc ::tcltest::openfiles {} {
    if {[catch {testchannel open} result]} then {
	return {}
    }
    return $result
}
proc ::tcltest::leakfiles {old} {
    if {[catch {testchannel open} new]} then {
	return {}
    }
    set leak {}
    foreach p $new {
	if {[lsearch $old $p] < 0} then {
	    lappend leak $p
	}
    }
    return $leak
}
proc ::tcltest::saveState {} {
    uplevel #0 {set ::tcltest::saveState [list [info procs] [info vars]]}
    DebugPuts 2 "::tcltest::saveState: $::tcltest::saveState"
}
proc ::tcltest::restoreState {} {
    foreach p [info procs] {
	if {([lsearch [lindex $::tcltest::saveState 0] $p] < 0) &&(![string equal ::tcltest::$p [namespace origin $p]])} then {
	    DebugPuts 3 "::tcltest::restoreState: Removing proc $p"
	    rename $p {}
	}
    }
    foreach p [uplevel #0 {info vars}] {
	if {[lsearch [lindex $::tcltest::saveState 1] $p] < 0} then {
	    DebugPuts 3 "::tcltest::restoreState: Removing variable $p"
	    uplevel #0 "catch {unset $p}"
	}
    }
}
proc ::tcltest::normalizeMsg {msg} {
    regsub "\n$" [string tolower $msg] "" msg
    regsub -all "\n\n" $msg "\n" msg
    regsub -all "\n\}" $msg "\}" msg
    return $msg
}
proc ::tcltest::makeFile {contents name} {
    global tcl_platform
    DebugPuts 3 "::tcltest::makeFile: putting $contents into $name"
    set fullName [file join $::tcltest::temporaryDirectory $name]
    set fd [open $fullName w]
    fconfigure $fd -translation lf
    if {[string equal [string index $contents end] "\n"]} then {
	puts -nonewline $fd $contents
    } else {
	puts $fd $contents
    }
    close $fd
    if {[lsearch -exact $::tcltest::filesMade $fullName] == -1} then {
	lappend ::tcltest::filesMade $fullName
    }
    return $fullName
}
proc ::tcltest::removeFile {name} {
    DebugPuts 3 "::tcltest::removeFile: removing $name"
    file delete [file join $::tcltest::temporaryDirectory $name]
}
proc ::tcltest::makeDirectory {name} {
    file mkdir $name
    set fullName [file join [pwd] $name]
    if {[lsearch -exact $::tcltest::filesMade $fullName] == -1} then {
	lappend ::tcltest::filesMade $fullName
    }
}
proc ::tcltest::removeDirectory {name} {
    file delete -force $name
}
proc ::tcltest::viewFile {name} {
    global tcl_platform
    if {([string equal $tcl_platform(platform) "macintosh"]) ||($::tcltest::testConstraints(unixExecs) == 0)} then {
	set f [open [file join $::tcltest::temporaryDirectory $name]]
	set data [read -nonewline $f]
	close $f
	return $data
    } else {
	exec cat [file join $::tcltest::temporaryDirectory $name]
    }
}
proc ::tcltest::grep {expression searchList} {
    foreach element $searchList {
	if {[regsub -all CURRENT_ELEMENT $expression $element newExpression] == 0} then {
	    set newExpression "$expression {$element}"
	}
	if {[eval $newExpression] == 1} then {
	    lappend returnList $element
	}
    }
    if {[info exists returnList]} then {
	return $returnList
    }
    return
}
proc ::tcltest::bytestring {string} {
    encoding convertfrom identity $string
}
proc ::tcltest::set_iso8859_1_locale {} {
    if {[info commands testlocale] != ""} then {
	set ::tcltest::previousLocale [testlocale ctype]
	testlocale ctype $::tcltest::isoLocale
    }
    return
}
proc ::tcltest::restore_locale {} {
    if {[info commands testlocale] != ""} then {
	testlocale ctype $::tcltest::previousLocale
    }
    return
}
proc ::tcltest::threadReap {} {
    if {[info commands testthread] != {}} then {
	testthread errorproc ThreadNullError
	while {[llength [testthread names]] > 1} {
	    foreach tid [testthread names] {
		if {$tid != $::tcltest::mainThread} then {
		    catch {testthread send -async $tid {testthread exit}}
		}
	    }
	    after 1
	}
	testthread errorproc ThreadError
	return [llength [testthread names]]
    } elseif {[info commands thread::id] != {}} {
	thread::errorproc ThreadNullError
	while {[llength [thread::names]] > 1} {
	    foreach tid [thread::names] {
		if {$tid != $::tcltest::mainThread} then {
		    catch {thread::send -async $tid {thread::exit}}
		}
	    }
	    after 1
	}
	thread::errorproc ThreadError
	return [llength [thread::names]]
    } else {
	return 1
    }
}
namespace eval tcltest {
    set ::auto_path [list [info library]]
    ::tcltest::initConstraints
    if {[namespace children ::tcltest] == {}} then {
	::tcltest::processCmdLineArgs
    }
}
proc cbOnOkSearchBuffer {data format} {
    #dbgBeginProc [info level [info level]]
    if {[string length $data] == 0} then {
	.bufferSearchDbox.f_fr3.l_result configure -text "Invalid entry." -anchor w
    } elseif {$format == "ascii"} {
	if {[string length $data] > 16} then {
	    .bufferSearchDbox.f_fr3.l_result configure -text "Entry too long." -anchor w
	} else {
	    .bufferSearchDbox.f_fr3.l_result configure -text "Searching..." -anchor w
	    update idletasks
	    set stringMatch 1
	    set addrMax [expr [readDeviceArray memorySize] * 1024 - 1]
	    set bufStartLoc $::bufMatchLoc
	    for {set bufIdx $bufStartLoc} {$bufIdx <= [expr $addrMax - [string length $data] + 1]} {incr bufIdx} {
		for {set dataIdx 0} {$dataIdx < [string length $data]} {incr dataIdx} {
		    scan [string index $data $dataIdx] %c V
		    if {[expr $V != 0x[readBuffer [format %06X $bufIdx]]]} then {
			set stringMatch 0
			break
		    } else {
			set stringMatch 1
			incr bufIdx
		    }
		}
		if {$stringMatch} then {
		    set addr [format "%#08X" [expr $bufIdx - [string length $data]]]
		    set ::bufMatchLoc [expr $addr + 1]
		    .bufferSearchDbox.f_fr3.l_result configure -text $addr -anchor w
		    gotoAddress [format %06X $addr] 0
		    break
		} else {
		    set ::bufMatchLoc 0
		    .bufferSearchDbox.f_fr3.l_result configure -text "No match" -anchor w
		}
	    }
	}
    } else {
	if {! [string is xdigit $data]} then {
	    .bufferSearchDbox.f_fr3.l_result configure -text "Invalid entry." -anchor w
	} elseif {[string length $data] > 32} {
	    .bufferSearchDbox.f_fr3.l_result configure -text "Entry too long." -anchor w
	} elseif {[expr [string length $data] % 2] != 0} {
	    .bufferSearchDbox.f_fr3.l_result configure -text "Odd number of chars in entry." -anchor w
	} else {
	    .bufferSearchDbox.f_fr3.l_result configure -text "Searching..." -anchor w
	    update idletasks
	    set data [string toupper $data]
	    set stringMatch 1
	    set addrMax [expr [readDeviceArray memorySize] * 1024 - 1]
	    set bufStartLoc $::bufMatchLoc
	    for {set bufIdx $bufStartLoc} {$bufIdx <= [expr $addrMax - ( [string length $data] / 2 ) + 1]} {incr bufIdx} {
		for {set dataIdx 0} {$dataIdx < [string length $data]} {incr dataIdx 2} {
		    set V [string range $data $dataIdx [expr $dataIdx + 1]]
		    if {$V != [readBuffer [format %06X $bufIdx]]} then {
			set stringMatch 0
			break
		    } else {
			set stringMatch 1
			incr bufIdx
		    }
		}
		if {$stringMatch} then {
		    set addr [format "%#08X" [expr $bufIdx - ( [string length $data] / 2 )]]
		    set ::bufMatchLoc [expr $addr + 1]
		    .bufferSearchDbox.f_fr3.l_result configure -text $addr -anchor w
		    gotoAddress [format %06X $addr] 0
		    break
		} else {
		    set ::bufMatchLoc 0
		    .bufferSearchDbox.f_fr3.l_result configure -text "No match" -anchor w
		}
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc updateBufferChecksum {} {
    #dbgBeginProc [info level [info level]]
    if {[winfo exists .main.f_buffer.f_checkSum.l_cksum]} then {
	.main.f_buffer.f_checkSum.l_cksum configure -text [format %06X [bufferChecksum]]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc deleteBufferText {} {
    #dbgBeginProc [info level [info level]]
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state normal
    .bufferEditWindow.f_editBuffer.f_txt.text delete 1.0 end
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state disabled
    #dbgEndProc [info level [info level]]
    return 1
}
proc buildOneBufferLine {address} {
    global gui
    set txtLine [format %06X $address]
    append txtLine ": "
    set asciiLine " "
    for {set j 0} {$j <= 15} {incr j} {
	set addr [format %06X [expr ($address + $j)]]
	set hexaValue [readBuffer $addr]
	append txtLine $hexaValue
	append txtLine " "
	set char [format %c 0x$hexaValue]
	if {("0x$hexaValue" >= 0x20) &&("0x$hexaValue" <= 0x7F)} then {
	    append asciiLine $char
	} else {
	    append asciiLine "."
	}
    }
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state normal
    append txtLine "$asciiLine\n"
    .bufferEditWindow.f_editBuffer.f_txt.text insert [expr $gui(bottomDisplayedLine) + 1].0 $txtLine
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state disabled
    return 1
}
proc updateBufferSingleAddress {address data} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    if {[isValidHexaInput $address]} then {
	set address [format "%06X" 0x$address]
    } else {
	return 0
    }
    if {"0x$address" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    if {[isValidHexaInput $data]} then {
	set data [format "%02X" 0x$data]
    } else {
	return 0
    }
    if {"0x$data" > 0xFF} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    writeBuffer $address [format "%02X" 0x$data]
    updateBufferChecksum
    set row [lindex [addrToPos $address] 0]
    set col [lindex [addrToPos $address] 1]
    if {($row >= $gui(topDisplayedLine)) &&($row <= [expr $gui(bottomDisplayedLine)+1])} then {
	set topRow $gui(topDisplayedLine)
	if {$row == $gui(topDisplayedLine)} then {
	    incr topRow -1
	}
	if {$gui(topDisplayedLine) == 1} then {
	    set topRow 0
	}
	updateBufferWidget [expr $topRow.0 / $gui(numberOfLines)]
	highlightLocation .bufferEditWindow.f_editBuffer.f_txt.text $row.$col
    } else {
	set topRow [expr $row - 1]
	updateBufferWidget [expr $topRow.0 / $gui(numberOfLines)]
	highlightLocation .bufferEditWindow.f_editBuffer.f_txt.text $row.$col
    }
    set flipStates(bufferInInitialState) 0
    #dbgEndProc [info level [info level]]
    return 1
}
proc copyMoveBuffer {} {
    global buffer gui
    set addrMax [expr [readDeviceArray memorySize] * 1024 - 1]
    if {[isValidHexaInput $buffer(srcStartAddr)]} then {
	set srcStartAddress [format "%06X" 0x$buffer(srcStartAddr)]
    } else {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {[isValidHexaInput $buffer(srcEndAddr)]} then {
	set srcEndAddress [format "%06X" 0x$buffer(srcEndAddr)]
    } else {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {[isValidHexaInput $buffer(dstStartAddr)]} then {
	set dstStartAddress [format "%06X" 0x$buffer(dstStartAddr)]
    } else {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {[expr 0x$srcStartAddress > $addrMax]} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {[expr 0x$srcEndAddress > $addrMax]} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {[expr 0x$dstStartAddress > $addrMax]} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {[expr 0x$srcEndAddress < 0x$srcStartAddress]} then {
	set message "Invalid source address range."
	messageBox "Entry Check" warning $message
	return 0
    }
    set srcRange [expr 0x$srcEndAddress - 0x$srcStartAddress + 1]
    if {[expr 0x$dstStartAddress > ($addrMax - $srcRange + 1)]} then {
	set message "Cannot perform the operation."
	messageBox "Entry Check" warning $message
	return 0
    }
    for {set i 0x$buffer(srcStartAddr)} {[expr $i <= 0x$buffer(srcEndAddr)]} {incr i} {
	set data [readBuffer [format %06X $i]]
	set temp([format %06X $i]) $data
	if {$buffer(movecopy) == "move"} then {
	    writeBuffer [format %06X $i] $gui(blankValue)
	}
    }
    set j 0
    for {set i 0x$buffer(srcStartAddr)} {[expr $i <= 0x$buffer(srcEndAddr)]} {incr i} {
	writeBuffer [format %06X [expr 0x$dstStartAddress + $j]] $temp([format %06X $i])
	incr j
    }
    gotoAddress [format %06X 0x$dstStartAddress] 0
    return
}
proc gotoAddress {address {check 1}} {
    #dbgBeginProc [info level [info level]]
    global gui
    if {$check} then {
	if {[isValidHexaInput $address]} then {
	    set address [format "%06X" 0x$address]
	} else {
	    return 0
	}
	if {"0x$address" > "0x$gui(maxAddr)"} then {
	    set message "Address is out of range."
	    messageBox "Edit Buffer" warning $message
	    return 0
	}
    }
    set formatAddress [format "%#08X" 0x$address]
    set row [lindex [addrToPos $formatAddress] 0]
    set rowSave $row
    set col [lindex [addrToPos $formatAddress] 1]
    if {$row > [expr $gui(numberOfLines) - $gui(numberOfVisibleLines)]} then {
	set row [expr $gui(numberOfLines) - $gui(numberOfVisibleLines)]
    } else {
	incr row -1
    }
    updateBufferWidget [expr $row.0 / $gui(numberOfLines)]
    highlightLocation .bufferEditWindow.f_editBuffer.f_txt.text $rowSave.$col
    #dbgEndProc [info level [info level]]
    return 1
}
proc bufferData {lo hi} {
    #dbgBeginProc [info level [info level]]
    for {set i $lo} {$i <= $hi} {incr i} {
	set j [format %06X $i]
	#dbgShowVar "buffer($j) = [readBuffer $j]"
	update
    }
    #dbgEndProc [info level [info level]]
    return
}
proc guiOptions {} {
    #dbgBeginProc [info level [info level]]
    global gui
    #dbgShowVar "gui(sizeType) = \t\t$gui(sizeType)"
    #dbgShowVar "gui(uDefSizeValue) = \t$gui(uDefSizeValue)"
    #dbgShowVar "gui(dDepSizeValue) = \t$gui(dDepSizeValue)"
    #dbgShowVar "gui(sizeValue) = \t\t$gui(sizeValue)"
    #dbgShowVar "gui(maxAddr) = \t\t$gui(maxAddr)"
    #dbgShowVar "gui(blankValueType) = \t$gui(blankValueType)"
    #dbgShowVar "gui(uDefBlankValue) = \t$gui(uDefBlankValue)"
    #dbgShowVar "gui(dDepBlankValue) = \t$gui(dDepBlankValue)"
    #dbgShowVar "gui(blankValue) = \t\t$gui(blankValue)"
    #dbgShowVar "gui(resetBufferOnLoading) = \t$gui(resetBufferOnLoading)"
    #dbgShowVar "gui(rangeOnDeviceProg) = \t$gui(rangeOnDeviceProg)"
    #dbgShowVar "gui(uDefMinProgAddr) = \t$gui(uDefMinProgAddr)"
    #dbgShowVar "gui(uDefMaxProgAddr) = \t$gui(uDefMaxProgAddr)"
    #dbgShowVar "gui(lastLoadMinProgAddr) = \t$gui(lastLoadMinProgAddr)"
    #dbgShowVar "gui(lastLoadMaxProgAddr) = \t$gui(lastLoadMaxProgAddr)"
    #dbgShowVar "gui(minProgAddr) = \t$gui(minProgAddr)"
    #dbgShowVar "gui(maxProgAddr) = \t$gui(maxProgAddr)"
    #dbgShowVar "gui(maxSize) = \t\t$gui(maxSize)"
    #dbgShowVar "gui(loadingOffset) = \t$gui(loadingOffset)"
    #dbgShowVar "gui(erase) = \t$gui(erase)"
    #dbgShowVar "gui(blankCheck) = \t$gui(blankCheck)"
    #dbgEndProc [info level [info level]]
    return
}
proc bufferOptions {} {
    #dbgBeginProc [info level [info level]]
    global gui
    #dbgShowInfo "Current memory is $::deviceArray(currentMemory)"
    #dbgShowVar "buffer(sizeType) = \t\t[readBuffer sizeType]"
    #dbgShowVar "buffer(uDefSizeValue) = \t\t[readBuffer uDefSizeValue]"
    #dbgShowVar "buffer(dDepSizeValue) = \t\t[readBuffer dDepSizeValue]"
    #dbgShowVar "buffer(sizeValue) = \t\t[readBuffer sizeValue]"
    #dbgShowVar "buffer(maxAddr) = \t\t[readBuffer maxAddr]"
    #dbgShowVar "buffer(blankValueType) = \t\t[readBuffer blankValueType]"
    #dbgShowVar "buffer(uDefBlankValue) = \t\t[readBuffer uDefBlankValue]"
    #dbgShowVar "buffer(dDepBlankValue) = \t\t[readBuffer dDepBlankValue]"
    #dbgShowVar "buffer(blankValue) = \t\t[readBuffer blankValue]"
    #dbgShowVar "buffer(resetBufferOnLoading) = \t[readBuffer resetBufferOnLoading]"
    #dbgShowVar "buffer(rangeOnDeviceProg) = \t[readBuffer rangeOnDeviceProg]"
    #dbgShowVar "buffer(uDefMinProgAddr) = \t\t[readBuffer uDefMinProgAddr]"
    #dbgShowVar "buffer(uDefMaxProgAddr) = \t\t[readBuffer uDefMaxProgAddr]"
    #dbgShowVar "buffer(lastLoadMinProgAddr) = \t[readBuffer lastLoadMinProgAddr]"
    #dbgShowVar "buffer(lastLoadMaxProgAddr) = \t[readBuffer lastLoadMaxProgAddr]"
    #dbgShowVar "buffer(minProgAddr) = \t\t[readBuffer minProgAddr]"
    #dbgShowVar "buffer(maxProgAddr) = \t\t[readBuffer maxProgAddr]"
    #dbgShowVar "buffer(maxSize) = \t\t\t[readBuffer maxSize]"
    #dbgShowVar "buffer(loadingOffset) = \t\t[readBuffer loadingOffset]"
    #dbgShowVar "buffer(erase) = \t$buffer(erase)"
    #dbgShowVar "buffer(blankCheck) = \t$buffer(blankCheck)"
    #dbgEndProc [info level [info level]]
    return
}
proc addrToPos {addr} {
    #dbgBeginProc [info level [info level]]
    if {[existLeading0x $addr]} then {
	set row [expr ($addr + 16) / 16]
	set col [expr 3 * ($addr - 16 * ($row - 1)) + 8]
    } else {
	set row [expr (0x$addr + 16) / 16]
	set col [expr 3 * (0x$addr - 16 * ($row - 1)) + 8]
    }
    switch $col {
    8 {
	    set asciiCol 57
	}
    11 {
	    set asciiCol 58
	}
    14 {
	    set asciiCol 59
	}
    17 {
	    set asciiCol 60
	}
    20 {
	    set asciiCol 61
	}
    23 {
	    set asciiCol 62
	}
    26 {
	    set asciiCol 63
	}
    29 {
	    set asciiCol 64
	}
    32 {
	    set asciiCol 65
	}
    35 {
	    set asciiCol 66
	}
    38 {
	    set asciiCol 67
	}
    41 {
	    set asciiCol 68
	}
    44 {
	    set asciiCol 69
	}
    47 {
	    set asciiCol 70
	}
    50 {
	    set asciiCol 71
	}
    53 {
	    set asciiCol 72
	}
    default {
	    log_message "col value: $col unknown"
	    return 0
	}
    }
    set rowCol [list $row $col $asciiCol]
    #dbgEndProc [info level [info level]]
    return $rowCol
}
proc posToAddr {rcPos} {
    #dbgBeginProc [info level [info level]]
    set dotPos [string first "." $rcPos]
    set row [string range $rcPos 0 [expr $dotPos - 1]]
    set col [string range $rcPos [expr $dotPos + 1] end]
    switch $col {
    8 -
    11 -
    14 -
    17 -
    20 -
    23 -
    26 -
    29 -
    32 -
    35 -
    38 -
    41 -
    44 -
    47 -
    50 -
    53 {
	    set addr [format %06X [expr ($col - 8)/3 + 16*($row - 1)]]
	}
    default {
	    set addr -1
	}
    }
    #dbgEndProc [info level [info level]]
    return $addr
}
proc resetBuffer {} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    for {set i 0} {$i <= "0x$gui(maxAddr)"} {incr i} {
	writeBuffer [format %06X $i] $gui(blankValue)
    }
    if {[winfo exists .bufferEditWindow]} then {
	updateBufferWidget 0.0
    }
    updateBufferChecksum
    set flipStates(bufferInInitialState) 1
    #dbgEndProc [info level [info level]]
    return 0
}
proc checkBuffer {addrLo addrHi data} {
    #dbgBeginProc [info level [info level]]
    if {[winfo exists .bufferFillDBox]} then {
	focus .bufferFillDBox
    } else {
	focus .
    }
    for {set addr "0x$addrLo"} {$addr <= "0x$addrHi"} {incr addr} {
	if {[readBuffer [format %06X $addr]] != $data} then {
	    return [format %06X $addr]
	}
    }
    #dbgEndProc [info level [info level]]
    return 1
}
proc fillBuffer {addrLo addrHi data} {
    #dbgBeginProc [info level [info level]]
    if {[winfo exists .bufferFillDBox]} then {
	focus .bufferFillDBox
    } else {
	focus .
    }
    for {set addr "0x$addrLo"} {$addr <= "0x$addrHi"} {incr addr} {
	writeBuffer [format %06X $addr] $data
    }
    #dbgEndProc [info level [info level]]
    return $data
}
proc cbOnOkGotoAddress {gotoAddress} {
    #dbgBeginProc [info level [info level]]
    if {[gotoAddress $gotoAddress]} then {
	wm withdraw .bufferGotoDbox
	update
    }
    #dbgEndProc [info level [info level]]
    return
}
proc cbOnOkModifyBuffer {} {
    #dbgBeginProc [info level [info level]]
    global gui
    if {[updateBufferSingleAddress $gui(modifyAddress) $gui(modifyData)]} then {
	wm withdraw .bufferModifyDbox
	focus .bufferEditWindow
    }
    #dbgEndProc [info level [info level]]
    return
}
proc cbOnBufferOptions {} {
    #dbgBeginProc [info level [info level]]
    global gui
    cbDboxWakeUp .bufferOptionsWindow
    #dbgEndProc [info level [info level]]
    return
}
proc cbOnCancelBufferOptions {} {
    #dbgBeginProc [info level [info level]]
    global gui
    wm withdraw .bufferOptionsWindow
    #dbgEndProc [info level [info level]]
    return
}
proc cbOnApplyBufferOptions {} {
    #dbgBeginProc [info level [info level]]
    global gui
    if {$gui(sizeType) == "userDefined"} then {
	if {![isValidIntegerInput $gui(uDefSizeValue)]} then {
	    return 0
	}
	if {($gui(uDefSizeValue) <= 0) ||($gui(uDefSizeValue) > $gui(dDepSizeValue))} then {
	    set message "Size is out of range."
	    messageBox "Entry Check" warning $message
	    return 0
	}
	if {$gui(rangeOnDeviceProg) != "userDefined"} then {
	    set gui(uDefMinProgAddr) [format %04X 0]
	    set gui(uDefMaxProgAddr) [format %04X [expr $gui(uDefSizeValue) * 1024 - 1]]
	}
	writeBuffer uDefSizeValue $gui(uDefSizeValue)
	writeBuffer sizeValue $gui(uDefSizeValue)
	writeBuffer maxSize $gui(uDefSizeValue)
	set gui(sizeValue) $gui(uDefSizeValue)
	set gui(maxSize) $gui(uDefSizeValue)
    } else {
	if {$gui(rangeOnDeviceProg) != "userDefined"} then {
	    set gui(uDefMinProgAddr) [format %04X 0]
	    set gui(uDefMaxProgAddr) [format %04X [expr $gui(dDepSizeValue) * 1024 - 1]]
	}
	writeBuffer sizeValue [readDeviceArray memorySize]
    }
    if {$gui(blankValueType) == "userDefined"} then {
	if {![isValidHexaInput $gui(uDefBlankValue)]} then {
	    return 0
	}
	if {"0x$gui(uDefBlankValue)" > 0xFF} then {
	    set message "Input is not valid."
	    messageBox "Entry Check" warning $message
	    return 0
	}
	writeBuffer uDefBlankValue $gui(uDefBlankValue)
	writeBuffer blankValue $gui(uDefBlankValue)
	set gui(blankValue) [format %02X 0x$gui(uDefBlankValue)]
    } else {
	writeBuffer blankValue $gui(dDepBlankValue)
    }
    if {$gui(rangeOnDeviceProg) == "userDefined"} then {
	writeBuffer rangeOnDeviceProg "userDefined"
	if {![isValidHexaInput $gui(uDefMinProgAddr)]} then {
	    return 0
	}
	if {"0x$gui(uDefMinProgAddr)" > "0x$gui(uDefMaxProgAddr)"} then {
	    set message "Address is out of range."
	    messageBox "Edit Buffer" warning $message
	    return 0
	}
	if {"0x$gui(uDefMinProgAddr)" > "0x$gui(maxAddr)"} then {
	    set message "Address is out of range."
	    messageBox "Edit Buffer" warning $message
	    return 0
	}
	set gui(uDefMinProgAddr) [format $gui(infoFormat) 0x$gui(uDefMinProgAddr)]
	set gui(minProgAddr) $gui(uDefMinProgAddr)
	if {![isValidHexaInput $gui(uDefMaxProgAddr)]} then {
	    return 0
	}
	if {"0x$gui(uDefMaxProgAddr)" > "0x$gui(maxAddr)"} then {
	    set message "Address is out of range."
	    messageBox "Edit Buffer" warning $message
	    return 0
	}
	set gui(uDefMaxProgAddr) [format $gui(infoFormat) 0x$gui(uDefMaxProgAddr)]
	set gui(maxProgAddr) $gui(uDefMaxProgAddr)
	writeBuffer uDefMinProgAddr $gui(uDefMinProgAddr)
	writeBuffer uDefMaxProgAddr $gui(uDefMaxProgAddr)
    } elseif {$gui(rangeOnDeviceProg) == "whole"} {
	writeBuffer rangeOnDeviceProg "whole"
	writeBuffer maxAddr $gui(maxAddr)
	set gui(minProgAddr) 0
	set gui(maxProgAddr) [format $gui(infoFormat) [expr $gui(sizeValue) * 1024 - 1]]
	writeBuffer maxProgAddr $gui(maxProgAddr)
    } else {
	set gui(minProgAddr) $gui(lastLoadMinProgAddr)
	set gui(maxProgAddr) $gui(lastLoadMaxProgAddr)
	writeBuffer rangeOnDeviceProg "lastLoad"
    }
    writeBuffer minProgAddr $gui(minProgAddr)
    writeBuffer maxProgAddr $gui(maxProgAddr)
    if {![isValidHexaInput $gui(loadingOffset)]} then {
	return 0
    }
    if {"0x$gui(loadingOffset)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(loadingOffset) [format $gui(infoFormat) 0x$gui(loadingOffset)]
    focus .bufferOptionsWindow
    writeBuffer sizeType $gui(sizeType)
    writeBuffer blankValueType $gui(blankValueType)
    writeBuffer resetBufferOnLoading $gui(resetBufferOnLoading)
    writeBuffer loadingOffset $gui(loadingOffset)
    .main.f_buffer.l_bufferSize configure -text "Size:\t$gui(sizeValue) Kbytes"
    .main.f_buffer.l_bufferBlank configure -text "Blank:\t$gui(blankValue)"
    .main.f_buffer.l_range configure -text "Range:\t[format $gui(infoFormat) 0x$gui(minProgAddr)] - [format $gui(infoFormat) 0x$gui(maxProgAddr)]"
    if {$gui(resetBufferOnLoading) == "yes"} then {
	.main.f_buffer.l_bufferReset configure -text "Reset Before Loading"
    } else {
	.main.f_buffer.l_bufferReset configure -text "No Reset Before Loading"
    }
    .main.f_buffer.l_offset configure -text "Offset:\t[format $gui(infoFormat) 0x$gui(loadingOffset)]"
    updateBufferChecksum
    update
    #dbgEndProc [info level [info level]]
    return 1
}
proc cbOnOkBufferOptions {} {
    #dbgBeginProc [info level [info level]]
    if {! [cbOnApplyBufferOptions]} then {
	return 0
    }
    wm withdraw .bufferOptionsWindow
    #dbgEndProc [info level [info level]]
    return 1
}
proc cbFillBuffer {} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    set buttonList [split [winfo children .bufferFillDBox.f_buttons]]
    if {![isValidHexaInput $gui(startFillAddr)]} then {
	return 0
    }
    if {"0x$gui(startFillAddr)" > "0x$gui(endFillAddr)"} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {"0x$gui(startFillAddr)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(startFillAddr) [format %06X 0x$gui(startFillAddr)]
    if {![isValidHexaInput $gui(endFillAddr)]} then {
	return 0
    }
    if {"0x$gui(endFillAddr)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(endFillAddr) [format %06X 0x$gui(endFillAddr)]
    if {![isValidHexaInput $gui(fillValue)]} then {
	return 0
    }
    if {"0x$gui(fillValue)" > 0xFF} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    set gui(fillValue) [format %02X 0x$gui(fillValue)]
    foreach button $buttonList {
	$button configure -state disabled
    }
    update
    fillBuffer $gui(startFillAddr) $gui(endFillAddr) $gui(fillValue)
    set lResults .bufferFillDBox.f_results.l_results
    $lResults configure -text "no check"
    set row [lindex [addrToPos $gui(startFillAddr)] 0]
    incr row -1
    updateBufferWidget [expr $row.0 / $gui(numberOfLines)]
    updateBufferChecksum
    foreach button $buttonList {
	$button configure -state normal
    }
    #dbgEndProc [info level [info level]]
    set flipStates(bufferInInitialState) 0
    return
}
proc cbCheckBuffer {} {
    #dbgBeginProc [info level [info level]]
    global gui
    if {![isValidHexaInput $gui(startFillAddr)]} then {
	return 0
    }
    if {"0x$gui(startFillAddr)" > "0x$gui(endFillAddr)"} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    if {"0x$gui(startFillAddr)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(startFillAddr) [format %06X 0x$gui(startFillAddr)]
    if {![isValidHexaInput $gui(endFillAddr)]} then {
	return 0
    }
    if {"0x$gui(endFillAddr)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(endFillAddr) [format %06X 0x$gui(endFillAddr)]
    if {![isValidHexaInput $gui(fillValue)]} then {
	return 0
    }
    if {"0x$gui(fillValue)" > 0xFF} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	return 0
    }
    set gui(fillValue) [format %02X 0x$gui(fillValue)]
    set buttonList [split [winfo children .bufferFillDBox.f_buttons]]
    foreach button $buttonList {
	$button configure -state disabled
    }
    update
    set state [checkBuffer $gui(startFillAddr) $gui(endFillAddr) $gui(fillValue)]
    set lResults .bufferFillDBox.f_results.l_results
    if {$state == 1} then {
	$lResults configure -text "Pass"
    } else {
	$lResults configure -text "Fail at address $state"
    }
    foreach button $buttonList {
	$button configure -state normal
    }
    #dbgEndProc [info level [info level]]
    return
}
proc randomizeBuffer {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    set maxAddr [expr [readDeviceArray memorySize] * 1024]
    randomizeBuffer_C $maxAddr
    updateBufferWidget 0.0
    updateBufferChecksum
    set flipStates(bufferInInitialState) 0
    #dbgEndProc [info level [info level]]
    return
}
proc displayHexFileSize {addMin addMax} {
    set S [expr 0x$addMax - 0x$addMin + 1]
    if {$S < 1024} then {
	return "$S bytes"
    } else {
	if {[expr $S % 1024] == 0} then {
	    set fSize [expr $S / 1024]
	    return "$fSize Kbytes"
	} else {
	    set fSize [expr $S / 1024.0]
	    set S [string range $fSize 0 [expr [string first "." $fSize] + 1]]
	    return "$S Kbytes"
	}
    }
}
proc highlightLocation {w rcPos} {
    #dbgBeginProc [info level [info level]]
    set addr [posToAddr $rcPos]
    if {$addr != -1} then {
	$w tag delete hlght
	$w tag add hlght "$rcPos wordstart" "$rcPos wordend"
	$w tag configure hlght -background yellow
    } else {
	$w tag delete hlght
    }
    #dbgEndProc [info level [info level]]
    return
}
proc drawSearchBufferDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont flipStates
    set ::bufMatchLoc 0
    set w .bufferSearchDbox
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Buffer Search"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr1 $w.f_fr1
    frame $fr1 -relief groove -bd 2 -width 400
    set fr2 $w.f_fr2
    frame $fr2 -relief groove -bd 2 -width 400
    set fr3 $w.f_fr3
    frame $fr3 -width 400
    set fr4 $w.f_fr4
    frame $fr4 -width 400
    radiobutton $fr1.b_ascii -text "ASCII" -variable flipStates(searchFormat) -value ascii -anchor w -font $flipFont
    radiobutton $fr1.b_hexa -text "HEXA" -variable flipStates(searchFormat) -value hexa -anchor w -font $flipFont
    label $fr2.l_data -text "Searched Data:" -font $flipFont -anchor e -width 16
    entry $fr2.e_data -textvariable flipStates(searchedData) -width 32 -font $flipFont -justify left
    setBalloon $fr2.e_data "Example: ABCD (16 characters max.) or\n41424344 (32 characters max.)"
    label $fr3.l_title -text "Search Result: " -font $flipFont -anchor e -width 16
    label $fr3.l_result -text "" -font $flipFont -anchor e -width 32
    button $fr4.b_ok -text "Search" -font $flipFont -bd 3 -command {cbOnOkSearchBuffer $flipStates(searchedData) $flipStates(searchFormat)}
    setBalloon $fr4.b_ok "Click Search again to find next match."
    button $fr4.b_cancel -text "Close" -font $flipFont -bd 2 -command {wm withdraw .bufferSearchDbox}
    pack $fr1.b_ascii $fr1.b_hexa -side top
    pack $fr2.l_data $fr2.e_data -side left -pady 10 -padx 10
    pack $fr3.l_title $fr3.l_result -side left -padx 10
    pack $fr4.b_ok $fr4.b_cancel -side left -padx 30
    pack $fr1 $fr2 $fr3 $fr4 -side top -pady 10 -padx 10
    focus $fr2.e_data
    bind $fr2.e_data <Return> {cbOnOkSearchBuffer $flipStates(searchedData) $flipStates(searchFormat)}
    #dbgEndProc [info level [info level]]
    return
}
proc drawGotoBufferDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont
    set w .bufferGotoDbox
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Goto Address"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr $w.f_address
    frame $fr -relief groove -bd 2 -width 400
    label $fr.l_address -text "Address:" -font $flipFont -anchor e -width 10
    setBalloon $fr.l_address "Address from which buffer should be displayed"
    entry $fr.e_address -textvariable gotoAddress -width 7 -font $flipFont -justify left
    setBalloon $fr.e_address "Actual address value"
    label $fr.l_dummy1 -text "    " -width 10 -font $flipFont
    grid config $fr.l_address -row 0 -col 0 -pady 5
    grid config $fr.e_address -row 0 -col 1 -pady 5 -padx 5
    grid config $fr.l_dummy1 -row 0 -col 2 -pady 5 -padx 5
    set fr_b $w.f_buttons
    frame $fr_b -relief flat
    button $fr_b.b_ok -text "OK" -font $flipFont -bd 3 -command {cbOnOkGotoAddress $gotoAddress}
    setBalloon $fr_b.b_ok "Goes to specified address\nand closes dialog box"
    button $fr_b.b_apply -text "Apply" -font $flipFont -bd 3 -command {gotoAddress $gotoAddress}
    setBalloon $fr_b.b_apply "Goes to specified address"
    button $fr_b.b_cancel -text "Cancel" -font $flipFont -bd 2 -command {wm withdraw .bufferGotoDbox}
    setBalloon $fr_b.b_cancel "Closes dialog box\nwithout applying options"
    pack config $fr_b.b_cancel $fr_b.b_apply $fr_b.b_ok -side right -padx 5 -fill x
    pack config $fr $fr_b -side top -padx 5 -pady 10 -fill x
    update
    focus $fr.e_address
    bind $fr.e_address <Return> {cbOnOkGotoAddress $gotoAddress}
    #dbgEndProc [info level [info level]]
    return
}
proc drawModifyBufferDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont gui
    set w .bufferModifyDbox
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Modify Buffer"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr $w.f_addressData
    frame $fr -relief groove -bd 2 -width 400
    label $fr.l_address -text "Address:" -font $flipFont -anchor e -width 10
    setBalloon $fr.l_address "Address where data should be modified"
    entry $fr.e_address -textvariable gui(modifyAddress) -width 7 -font $flipFont -justify left
    setBalloon $fr.e_address "Actual address value"
    label $fr.l_dummy1 -text "    " -width 10 -font $flipFont
    grid config $fr.l_address -row 0 -col 0 -pady 5
    grid config $fr.e_address -row 0 -col 1 -pady 5 -padx 5
    grid config $fr.l_dummy1 -row 0 -col 2 -pady 5 -padx 5
    label $fr.l_data -text "Data:" -font $flipFont -anchor e -width 10
    setBalloon $fr.l_data "New data to be written at specified address"
    entry $fr.e_data -textvariable gui(modifyData) -width 7 -font $flipFont -justify left
    setBalloon $fr.e_data "Actual data value"
    label $fr.l_dummy2 -text "    " -width 10 -font $flipFont
    grid config $fr.l_data -row 1 -col 0 -pady 5
    grid config $fr.e_data -row 1 -col 1 -pady 5 -padx 5
    grid config $fr.l_dummy2 -row 1 -col 2 -pady 5 -padx 5
    set fr_b $w.f_buttons
    frame $fr_b -relief flat
    button $fr_b.b_ok -text "OK" -font $flipFont -bd 3 -command {cbOnOkModifyBuffer}
    setBalloon $fr_b.b_ok "Applies specified modification\nand closes dialog box"
    button $fr_b.b_apply -text "Apply" -font $flipFont -bd 3 -command {updateBufferSingleAddress $gui(modifyAddress) $gui(modifyData)}
    setBalloon $fr_b.b_apply "Applies specified modification"
    button $fr_b.b_cancel -text "Cancel" -font $flipFont -bd 2 -command {wm withdraw .bufferModifyDbox
	focus .bufferEditWindow}
    setBalloon $fr_b.b_cancel "Closes dialog box\nwithout applying options"
    pack config $fr_b.b_cancel $fr_b.b_apply $fr_b.b_ok -side right -padx 5 -fill x
    pack config $fr $fr_b -side top -padx 5 -pady 10 -fill x
    focus $fr.e_data
    bind $fr.e_data <Return> {cbOnOkModifyBuffer}
    bind $fr.e_address <Return> {cbOnOkModifyBuffer}
    update
    #dbgEndProc [info level [info level]]
    return
}
proc drawBufferOptionsWindow {} {
    #dbgBeginProc [info level [info level]]
    global flipStates flipFont gui
    set w .bufferOptionsWindow
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Buffer Options"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr $w.f_bufferSize
    frame $fr -relief groove -bd 2
    set frValue $fr.f_bufferSizeValue
    frame $frValue
    label $fr.l_bufferSizeTitle -text "Buffer Size Setting (Kbytes):" -font $flipFont
    radiobutton $frValue.b_userDefined -command {updateGUI onBufferSizeTypeChange} -text "User Defined:" -variable gui(sizeType) -value userDefined -anchor w -font $flipFont
    setBalloon $frValue.b_userDefined "User defined buffer size"
    entry $frValue.e_bufferSizeValue -textvariable gui(uDefSizeValue) -width 5 -font $flipFont
    setBalloon $frValue.e_bufferSizeValue "User defined buffer size value"
    radiobutton $frValue.b_deviceDependent -command {updateGUI onBufferSizeTypeChange} -text "Device Dependent" -variable gui(sizeType) -value deviceDependent -state $flipStates(deviceSelection) -anchor w -font $flipFont
    setBalloon $frValue.b_deviceDependent "Device dependent buffer size"
    bind $frValue.e_bufferSizeValue <Return> {cbOnOkBufferOptions}
    pack config $fr.l_bufferSizeTitle -side top -anchor w -padx 5
    pack config $frValue.b_userDefined $frValue.e_bufferSizeValue $frValue.b_deviceDependent -side left -padx 10
    pack config $frValue -side top -fill x
    pack $fr -side top -padx 5 -pady 5 -fill x
    set fr $w.f_bufferInit
    frame $fr -relief groove -bd 2
    set frValue $fr.f_bufferContentsValue
    frame $frValue
    label $fr.l_bufferBlankValueTitle -text "Initial Buffer Contents:" -font $flipFont
    radiobutton $frValue.b_userDefined -command {updateGUI onInitialBufferContentsChange} -text "User Defined:" -variable gui(blankValueType) -value userDefined -font $flipFont
    setBalloon $frValue.b_userDefined "User defined initial buffer content"
    entry $frValue.e_bufferBlankValue -textvariable gui(uDefBlankValue) -width 5 -font $flipFont
    setBalloon $frValue.e_bufferBlankValue "User defined initial buffer content value"
    radiobutton $frValue.b_deviceDependent -command {updateGUI onInitialBufferContentsChange} -text "Device Blank Value" -variable gui(blankValueType) -value deviceDependent -state $flipStates(deviceSelection) -font $flipFont
    setBalloon $frValue.b_deviceDependent "Device initial buffer content\n(blank value)"
    label $fr.l_bufferReset -text "Reset Buffer Before Loading ?" -font $flipFont
    setBalloon $fr.l_bufferReset "Reset/no buffer reset before file load"
    radiobutton $fr.b_bufferResetYes -text "Yes" -variable gui(resetBufferOnLoading) -value yes -font $flipFont
    setBalloon $fr.b_bufferResetYes "Reset buffer with specified\n initial buffer content before file load"
    radiobutton $fr.b_bufferResetNo -text "No" -variable gui(resetBufferOnLoading) -value no -font $flipFont
    setBalloon $fr.b_bufferResetNo "No buffer reset before file load"
    bind $frValue.e_bufferBlankValue <Return> {cbOnOkBufferOptions}
    pack config $fr.l_bufferBlankValueTitle -side top -padx 5 -anchor w
    pack config $frValue.b_userDefined $frValue.e_bufferBlankValue $frValue.b_deviceDependent -side left -padx 10
    pack config $frValue -side top -fill x
    pack $fr.l_bufferReset -side top -anchor w -padx 5
    pack $fr.b_bufferResetYes $fr.b_bufferResetNo -side top -anchor w -padx 10
    pack $fr -side top -fill x -expand 1 -padx 5 -pady 5
    set gui(uDefMinProgAddr) [format $gui(infoFormat) 0x$gui(uDefMinProgAddr)]
    set gui(uDefMaxProgAddr) [format $gui(infoFormat) 0x$gui(uDefMaxProgAddr)]
    set fr $w.f_bufferRange
    frame $fr -relief groove -bd 2 -width 400
    label $fr.l_bufferReset -text "Address Programming Range:" -font $flipFont
    setBalloon $fr.l_bufferReset "Device memory programming range selection"
    radiobutton $fr.b_bufferRangeLastLoad -command {updateGUI onAddrProgRangeChange} -text "Address Range From Last Buffer Load" -variable gui(rangeOnDeviceProg) -value lastLoad -anchor w -font $flipFont
    setBalloon $fr.b_bufferRangeLastLoad "Address range from last buffer load"
    radiobutton $fr.b_bufferRangeWhole -command {updateGUI onAddrProgRangeChange} -text "Whole Buffer" -variable gui(rangeOnDeviceProg) -value whole -font $flipFont
    setBalloon $fr.b_bufferRangeWhole "Address range from whole buffer size"
    set frUdef $fr.f_uDefined
    frame $frUdef
    radiobutton $frUdef.b_bufferRangeUserDefined -command {updateGUI onAddrProgRangeChange} -text "User Defined Address Range" -variable gui(rangeOnDeviceProg) -value userDefined -font $flipFont
    setBalloon $frUdef.b_bufferRangeUserDefined "User defined programming range"
    label $frUdef.l_bufferRangeMin -text "Min:" -font $flipFont
    setBalloon $frUdef.l_bufferRangeMin "Min programming address (included)"
    entry $frUdef.e_bufferRangeMin -textvariable gui(uDefMinProgAddr) -width 7 -font $flipFont -state disabled
    setBalloon $frUdef.e_bufferRangeMin "Min programming address value"
    label $frUdef.l_bufferRangeMax -text "Max:" -font $flipFont
    setBalloon $frUdef.l_bufferRangeMax "Max programming address (included)"
    entry $frUdef.e_bufferRangeMax -textvariable gui(uDefMaxProgAddr) -width 7 -font $flipFont -state disabled
    setBalloon $frUdef.e_bufferRangeMax "Max programming address value"
    if {$gui(rangeOnDeviceProg) == "userDefined"} then {
	$frUdef.e_bufferRangeMin configure -state normal
	$frUdef.e_bufferRangeMax configure -state normal
    }
    bind $frUdef.e_bufferRangeMin <Return> {cbOnOkBufferOptions}
    bind $frUdef.e_bufferRangeMax <Return> {cbOnOkBufferOptions}
    pack configure $fr.l_bufferReset -side top -anchor w -padx 5
    pack configure $fr.b_bufferRangeLastLoad -side top -anchor w -padx 10
    pack configure $fr.b_bufferRangeWhole -side top -anchor w -padx 10
    pack configure $frUdef.b_bufferRangeUserDefined $frUdef.l_bufferRangeMin $frUdef.e_bufferRangeMin $frUdef.l_bufferRangeMax $frUdef.e_bufferRangeMax -side left -padx 5
    pack configure $frUdef -side top -anchor w -padx 5
    pack configure $fr -side top -padx 5 -pady 5 -fill x
    set gui(loadingOffset) [format $gui(infoFormat) 0x$gui(loadingOffset)]
    set fr $w.f_loadingAddressOffset
    frame $fr -relief groove -bd 2
    label $fr.l_loadingOffset -text "Loading Address Offset:" -font $flipFont
    setBalloon $fr.l_loadingOffset "Offset applied to read addresses on file load"
    entry $fr.e_loadingOffset -textvariable gui(loadingOffset) -width 7 -font $flipFont
    setBalloon $fr.e_loadingOffset "Loading address offset value"
    pack $fr.l_loadingOffset $fr.e_loadingOffset -side left -padx 5
    pack $fr -side top -padx 5 -pady 5 -ipady 10 -fill x
    bind $fr.e_loadingOffset <Return> {cbOnOkBufferOptions}
    set fr $w.f_buttons
    frame $fr -relief flat
    button $fr.b_okButton -text "OK" -command {log_message "Please load a HEX file..."
	cbOnOkBufferOptions} -font $flipFont -bd 3
    setBalloon $fr.b_okButton "Applies selected options\n and closes dialog box"
    button $fr.b_applyButton -text "Apply" -command {log_message "Please load a HEX file..."
	cbOnApplyBufferOptions} -font $flipFont -bd 3
    setBalloon $fr.b_applyButton "Applies selected options"
    button $fr.b_cancelButton -text "Cancel" -command {cbOnCancelBufferOptions} -font $flipFont -bd 2
    setBalloon $fr.b_cancelButton "Closes dialog box\nwithout applying options"
    pack config $fr.b_cancelButton $fr.b_applyButton $fr.b_okButton -side right -padx 3 -ipadx 18
    pack config $fr -side top -pady 10 -fill x -padx 5
    #dbgEndProc [info level [info level]]
    return
}
proc drawBufferEditWindow {} {
    #dbgBeginProc [info level [info level]]
    global flipStates flipFont gui
    set w .bufferEditWindow
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Edit Buffer"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    menu $w.menubar -type menubar -relief groove -bd 1
    $w configure -menu $w.menubar
    $w.menubar add cascade -label "File" -menu $w.menubar.file -underline 0 -font $flipFont
    $w.menubar add cascade -label "Edit" -menu $w.menubar.edit -underline 0 -font $flipFont
    $w.menubar add cascade -label "Device" -menu $w.menubar.device -underline 0 -font $flipFont
    $w.menubar add command -label "Options..." -command {cbOnBufferOptions} -underline 0 -font $flipFont
    $w.menubar add cascade -label "Help" -menu $w.menubar.help -underline 0 -font $flipFont
    set f "file"
    menu $w.menubar.$f -tearoff no
    $w.menubar.$f add command -label "Load..." -command {cbParseHexFile} -underline 0 -font $flipFont
    $w.menubar.$f add command -label "Save As..." -command {cbWriteHexFile} -underline 0 -font $flipFont
    set e "edit"
    menu $w.menubar.$e -tearoff no
    $w.menubar.$e add command -label "Modify..." -command {set eData .bufferModifyDbox.f_addressData.e_data
	$eData icursor end
	focus $eData
	cbDboxWakeUp .bufferModifyDbox} -underline 0 -font $flipFont
    $w.menubar.$e add command -label "Goto..." -command {set eData .bufferGotoDbox.f_address.e_address
	focus $eData
	cbDboxWakeUp .bufferGotoDbox} -underline 0 -font $flipFont
    $w.menubar.$e add command -label "Fill..." -command {set eValue .bufferFillDBox.f_addresses.f_value.e_value
	$eValue icursor end
	focus $eValue
	cbDboxWakeUp .bufferFillDBox} -underline 0 -font $flipFont
    $w.menubar.$e add command -label "Randomize" -command {randomizeBuffer} -underline 0 -font $flipFont
    $w.menubar.$e add command -label "Search..." -command {cbDboxWakeUp .bufferSearchDbox} -underline 0 -font $flipFont
    $w.menubar.$e add command -label "Copy / Move..." -command {cbDboxWakeUp .bufferCopyMoveDbox} -underline 0 -font $flipFont
    $w.menubar.$e add separator
    $w.menubar.$e add command -label "Reset" -command {resetBuffer} -underline 0 -font $flipFont
    set d "device"
    menu $w.menubar.$d -tearoff no
    $w.menubar.$d add command -label "Read" -command {cbDboxWakeUp .deviceReadDBox} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    $w.menubar.$d add command -label "Program" -command {cmdsDeviceProgram} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    $w.menubar.$d add command -label "Verify" -command {cmdsDeviceVerify} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    set h "help"
    menu $w.menubar.$h -tearoff no
    $w.menubar.$h add command -label "Contents..." -command {htmlView "Help" ./doc/flip_um.htm} -underline 0 -font $flipFont
    $w.menubar.$h add separator
    $w.menubar.$h add command -label "About Flip..." -command {displayAbout} -underline 0 -font $flipFont
    set editBufferTopFrame $w.f_editBuffer
    frame $editBufferTopFrame -relief sunken -bd 1
    createBufferToolBar $editBufferTopFrame
    set legendLabel $editBufferTopFrame.l_legend
    label $legendLabel -text "  Addr  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF" -font courierb
    set txtFrame $editBufferTopFrame.f_txt
    frame $txtFrame -relief flat
    text $txtFrame.text -yscrollcommand "$txtFrame.scroll set" -insertofftime 0 -setgrid 1
    scrollbar $txtFrame.scroll -command "$txtFrame.text yview"
    button $editBufferTopFrame.b_ok -text "OK" -command "wm withdraw $w" -bd 3 -font $flipFont
    setBalloon $editBufferTopFrame.b_ok "Closes Edit Buffer window"
    pack configure $txtFrame.scroll -side right -fill y
    pack configure $txtFrame.text -side left -fill x -expand yes
    pack configure $editBufferTopFrame.toolbar -side top -pady 2 -anchor w
    pack configure $legendLabel -side top -anchor w
    pack configure $txtFrame -side top -fill x -expand yes
    pack configure $editBufferTopFrame.b_ok -side top -pady 5
    pack configure $editBufferTopFrame -side top -fill x -expand yes
    $w.f_editBuffer.f_txt.text configure -state normal -font courierb -spacing3 1 -cursor crosshair -width 74 -height [expr $gui(numberOfVisibleLines) - 0] -background #88a67d
    #dbgEndProc [info level [info level]]
    return
}
proc updateBufferAddressWindow {} {
    global flipStates flipFont gui
    return
}
proc setEditBufferBindings {} {
    #dbgBeginProc [info level [info level]]
    global flipFont gui
    set w .bufferEditWindow.f_editBuffer.f_txt.text
    bind $w <Double-Button-1> {
	set rcPos [.bufferEditWindow.f_editBuffer.f_txt.text index "@%x,%y wordstart"]
	set addr [posToAddr $rcPos]
	if {$addr != -1} then {
	    set gui(modifyAddress) $addr
	    set gui(modifyData) [readBuffer $addr]
	    cbDboxWakeUp .bufferModifyDbox
	    set eData .bufferModifyDbox.f_addressData.e_data
	    $eData icursor end
	    focus $eData
	}
    }
    bind $w <Motion> {
	set rcPos [.bufferEditWindow.f_editBuffer.f_txt.text index "@%x,%y wordstart"]
	highlightLocation .bufferEditWindow.f_editBuffer.f_txt.text $rcPos
    }
    bind .bufferEditWindow <Home> {
	updateBufferWidget 0.0
    }
    bind .bufferEditWindow <End> {
	set fracTop [expr ($gui(numberOfLines).0 - $gui(numberOfVisibleLines).0 + 1.0) / $gui(numberOfLines).0]
	updateBufferWidget $fracTop
	.bufferEditWindow.f_editBuffer.f_txt.text yview scroll -1 units
    }
    bind .bufferEditWindow <Up> {
	set lineFraction [expr 1.0 / $gui(numberOfLines)]
	set sliderList [.bufferEditWindow.f_editBuffer.f_txt.scroll get]
	set newTop [expr [lindex $sliderList 0] - $lineFraction]
	updateBufferWidget $newTop
    }
    bind .bufferEditWindow <Down> {
	set sliderList [.bufferEditWindow.f_editBuffer.f_txt.scroll get]
	set lineFraction [expr 1.0 / $gui(numberOfLines)]
	if {$gui(bottomDisplayedLine) < 4096} then {
	    set newTop [expr [lindex $sliderList 0] + $lineFraction]
	    updateBufferWidget $newTop
	}
    }
    bind .bufferEditWindow <Prior> {
	if {$gui(topDisplayedLine) < $gui(numberOfVisibleLines)} then {
	    updateBufferWidget 0.0
	} else {
	    set sliderList [.bufferEditWindow.f_editBuffer.f_txt.scroll get]
	    set pageFraction [expr $gui(numberOfVisibleLines).0 / $gui(numberOfLines)]
	    set newTop [expr [lindex $sliderList 0] - $pageFraction]
	    updateBufferWidget $newTop
	}
    }
    bind .bufferEditWindow <Next> {
	if {$gui(bottomDisplayedLine) > [expr $gui(numberOfLines).0 - $gui(numberOfVisibleLines)]} then {
	    set fracTop [expr ($gui(numberOfLines).0 - $gui(numberOfVisibleLines).0 + 1.0) / $gui(numberOfLines).0]
	    updateBufferWidget $fracTop
	    .bufferEditWindow.f_editBuffer.f_txt.text yview scroll -1 units
	} else {
	    set sliderList [.bufferEditWindow.f_editBuffer.f_txt.scroll get]
	    set pageFraction [expr $gui(numberOfVisibleLines).0 / $gui(numberOfLines)]
	    set newTop [expr [lindex $sliderList 0] + $pageFraction]
	    updateBufferWidget $newTop
	}
    }
    bind .bufferEditWindow.f_editBuffer.f_txt.scroll <ButtonRelease-1> {
	updateBufferWidget [lindex [.bufferEditWindow.f_editBuffer.f_txt.scroll get] 0]
    }
    bind .bufferEditWindow.f_editBuffer.f_txt.scroll <ButtonPress-1> {
	bind .bufferEditWindow.f_editBuffer.f_txt.scroll <Motion> {
	    updateBufferWidget [lindex [.bufferEditWindow.f_editBuffer.f_txt.scroll get] 0]
	}
    }
    bind .bufferEditWindow.f_editBuffer.f_txt <MouseWheel> {
	#dbgShowInfo "salut"
    }
    #dbgEndProc [info level [info level]]
    return
}
proc updateBufferWidget {sliderTop} {
    #dbgBeginProc [info level [info level]]
    global flipFont gui
    set gui(topDisplayedLine) [expr round($sliderTop * $gui(numberOfLines))]
    if {$gui(topDisplayedLine) < 0} then {
	return
    }
    if {$gui(topDisplayedLine) == 0} then {
	set gui(topDisplayedLine) 1
    }
    set gui(bottomDisplayedLine) [expr $gui(topDisplayedLine) + $gui(numberOfVisibleLines) - 1]
    deleteBufferText
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state normal
    for {set i 1} {$i < $gui(topDisplayedLine)} {incr i} {
	.bufferEditWindow.f_editBuffer.f_txt.text insert end "\n"
    }
    set nextLineAddr [expr ($gui(topDisplayedLine) - 1) * 16]
    for {set i $nextLineAddr; set j 1} {$j <= [expr $gui(numberOfVisibleLines)+1]} {incr j 1; incr i 16} {
	if {$i <= [expr "0x$gui(maxAddr)" - 15]} then {
	    buildOneBufferLine $i
	}
    }
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state normal
    for {set i [expr $gui(bottomDisplayedLine) + 1]} {$i < $gui(numberOfLines)} {incr i} {
	.bufferEditWindow.f_editBuffer.f_txt.text insert end "\n"
    }
    .bufferEditWindow.f_editBuffer.f_txt.text yview moveto $sliderTop
    .bufferEditWindow.f_editBuffer.f_txt.text configure -state disabled
    #dbgEndProc [info level [info level]]
    return
}
proc drawBufferFillDBox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont gui
    set w .bufferFillDBox
    if {[winfo exists $w]} then {
	destroy $w
    }
    toplevel $w -class Dialog
    wm title $w "Buffer Fill/Check"
    wm geometry $w 190x210
    wm resizable $w 0 0
    wm withdraw $w
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    set gui(startFillAddr) [format $gui(infoFormat) 0x$gui(startFillAddr)]
    set gui(endFillAddr) [format $gui(infoFormat) 0x$gui(endFillAddr)]
    set fAddr $w.f_addresses
    frame $fAddr -bd 2 -relief groove
    set fStart $fAddr.f_start
    frame $fStart -relief flat
    set lStart $fStart.l_start
    label $lStart -text "Start address:" -font $flipFont -anchor w -width 15
    setBalloon $lStart "Start address (included)\nfor buffer fill/check"
    set eStart $fStart.e_start
    entry $eStart -textvariable gui(startFillAddr) -width 6 -font $flipFont
    setBalloon $eStart "Start address value"
    pack $lStart $eStart -side left
    set fEnd $fAddr.f_end
    frame $fEnd -relief flat
    set lEnd $fEnd.l_end
    label $lEnd -text "End address:" -font $flipFont -anchor w -width 15
    setBalloon $lEnd "End address (included)\nfor buffer fill/check"
    set eEnd $fEnd.e_end
    entry $eEnd -textvariable gui(endFillAddr) -width 6 -font $flipFont
    setBalloon $eEnd "End address value"
    pack $lEnd $eEnd -side left
    set fValue $fAddr.f_value
    frame $fValue -relief flat
    set lValue $fValue.l_value
    label $lValue -text "Value:" -font $flipFont -anchor w -width 18
    setBalloon $lValue "Value with which buffer should be filled/checked"
    set eValue $fValue.e_value
    entry $eValue -textvariable gui(fillValue) -width 3 -font $flipFont
    setBalloon $eValue "Actual fill/check value"
    pack $lValue $eValue -side left
    pack $fStart $fEnd $fValue -side top -pady 5
    set fResults $w.f_results
    frame $fResults -bd 2 -relief groove
    setBalloon $fResults "Buffer check status:\n no check, pass, fail"
    set lTitle $fResults.l_title
    label $lTitle -text "Buffer Check Status:" -font $flipFont
    set lResults $fResults.l_results
    label $lResults -text "no check" -font $flipFont
    pack $lTitle $lResults -side top
    set fbuttons $w.f_buttons
    frame $fbuttons -relief flat
    button $fbuttons.b_fill -bd 3 -text "Fill" -command {cbFillBuffer} -font $flipFont
    setBalloon $fbuttons.b_fill "Fills buffer with specified value\n between (and including) specified addresses"
    button $fbuttons.b_check -bd 3 -text "Check" -command {cbCheckBuffer} -font $flipFont
    setBalloon $fbuttons.b_check "Checks buffer contents against specified value\n between (and including) specified addresses"
    button $fbuttons.b_close -bd 2 -text "Close" -command {wm withdraw .bufferFillDBox} -font $flipFont
    setBalloon $fbuttons.b_close "Closes dialog box\nwithout applying options"
    pack $fbuttons.b_fill $fbuttons.b_check $fbuttons.b_close -side left -padx 5
    pack $fAddr -side top -fill both -expand true -padx 10 -pady 10
    pack $fResults -side top -fill both -expand true -padx 10
    pack $fbuttons -side top -fill both -expand true -padx 10 -pady 10
    focus $eValue
    $eValue icursor end
    bind $eStart <Return> {cbFillBuffer}
    bind $eEnd <Return> {cbFillBuffer}
    bind $eValue <Return> {cbFillBuffer}
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsZeroxPrefix {data} {
    if {([string first "0X" $data] == -1) &&([string first "0x" $data] == -1)} then {
	set data 0X$data
    }
    return $data
}
proc cmdsComputeBufferChecksum_OBSOLETE {} {
    global temp flipStates
    if {! $flipStates(simul)} then {
	set min [readBuffer minProgAddr]
	set max [readBuffer maxProgAddr]
	return [computeBufferChecksum_C $min $max]
    } else {
	return "0xDEADBEEF"
    }
}
proc parseConfigFile {cfgFile {action read}} {
    #dbgBeginProc [info level [info level]]
    global port baud flipStates blankCheckAddr cfgFileId
    updateGUI onConfigFileLoaded
    if {[file exists $cfgFile]} then {
	set flipStates(lastloadedCfgFile) $cfgFile
	source $cfgFile
	if {$action == "execute"} then {
	    runOperations
	}
	.menubar.file entryconfigure 4 -state normal
	.menubar.file entryconfigure 5 -state normal
    } else {
	set parentWindow [focus]
	tk_messageBox -icon warning -message "You must load a configuration file, first." -title "Flip message" -type ok -parent $parentWindow
    }
    #dbgEndProc [info level [info level]]
    return
}
proc incSn {} {
    global serialize sn
    for {set i 0} {$i < [expr $serialize(nBytes) * 8]} {incr i} {
	if {$::sn($i) == 0} then {
	    set ::sn($i) 1
	    break

	} else {
	    set ::sn($i) 0
	}
    }
}
proc decSn {} {
    global serialize sn
    for {set i 0} {$i < [expr $serialize(nBytes) * 8]} {incr i} {
	if {$::sn($i) == 0} then {
	    set ::sn($i) 1
	} else {
	    set ::sn($i) 0
	    break

	}
    }
}
proc cmdsBuildDeviceList {filesList} {
    #dbgBeginProc [info level [info level]]
    global deviceList projDir
    set initialDir [pwd]
    set deviceList ""
    set notReadable 0
    foreach fileName $filesList {
	if {[file readable $projDir/tcl/devices/$fileName]} then {
	    set fileId [open $projDir/tcl/devices/$fileName "r"]
	    while {[gets $fileId line] >= 0} {
		if {[string first "set ::deviceArray(name)" $line] != -1} then {
		    lappend deviceList [lindex $line 2]
		    break
		}
	    }
	    close $fileId
	} else {
	    set notReadable 1
	    #dbgShowWarning "  Device file = $initialDir/devices/$fileName"
	    set message "Device file is not readable."
	    messageBox "Device Selection" warning $message
	    break
	}
    }
    if {$notReadable} then {
	#dbgEndProc [info level [info level]]
	return 0
    } else {
	#dbgEndProc [info level [info level]]
	return $deviceList
    }
}
proc buildTestLogFileHeader logFileId {
    #dbgBeginProc [info level [info level]]
    global version baud tcl_platform protcl
    set secs [clock seconds]
    puts $logFileId "#######################################################################"
    puts $logFileId "# Device : $::deviceArray(name) - Bootloader version : $::deviceArray(bootlVer)"
    set date [clock format $secs -format %c]
    puts $logFileId "# Tested with FLIP version : $version on $date"
    puts $logFileId "# Tested protocol : $protcl"
    if {[info exists baud]} then {
	puts $logFileId "# Baudrate : $baud"
    }
    puts $logFileId "# Platform : $tcl_platform(os) $tcl_platform(osVersion)"
    puts $logFileId "#######################################################################\n\n"
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsRunTests {} {
    #dbgBeginProc [info level [info level]]
    global testArray libDir projDir tclTestDir prot protcl
    global flipStates
    set flipStates(bufferInInitialState) 0
    log_message ""
    if {$testArray(nonRegress) &&([checkFilePathname $testArray(logFile)] != 1)} then {
	return 0
    }
    if {$testArray(protocol) &&([checkFilePathname $testArray(logFile)] != 1)} then {
	return 0
    }
    if {($testArray(nonRegress) != 1) &&($testArray(protocol) != 1)} then {
	wm withdraw .testSelectionDbox
	return 0
    }
    set logFileId [open $testArray(logFile) "w+"]
    buildTestLogFileHeader $logFileId
    if {[lsearch [namespace children] ::tcltest] == -1} then {
	package require tcltest
	namespace import ::tcltest::*
    }
    set ::tcltest::outputChannel $logFileId
    set ::tcltest::errorChannel $logFileId
    modifyWidgetOption .main.f_flow state disabled
    modifyWidgetOption .main.f_device state disabled
    update
    set fore yellow
    set back red
    .main.f_flow.l_flow configure -state normal -bg $back
    .main.f_flow.l_flow configure -text "TESTING" -bg red -fg yellow
    working_start .main.f_flow.l_flow yellow red
    if {$testArray(nonRegress)} then {
	#dbgShowInfo "Running $projDir/tcl/tests/noregr_test.tcl"
	source $projDir/tcl/tests/noregr_test.tcl
    }
    if {$testArray(protocol)} then {
	if {$protcl == "RS232Standard"} then {
	    #dbgShowInfo "Running $projDir/tcl/tests/rs232std_test.tcl"
	    source $projDir/tcl/tests/rs232std_test.tcl
	} elseif {($protcl == "CANStandard") ||($protcl == "canview") ||($protcl == "usbcan")} {
	    #dbgShowInfo "Running $projDir/tcl/tests/canstd_test.tcl"
	    source $projDir/tcl/tests/canstd_test.tcl
	    #david eseo
	} elseif {$protcl == "rs232can"} {
	    #dbgShowInfo "Running $projDir/tcl/tests/rs232can_test.tcl"
	    source $projDir/tcl/tests/rs232can_test.tcl
	    #fin david eseo
	} elseif {$protcl == "USB_DFU"} {
	    #dbgShowInfo "Running $projDir/tcl/tests/usb_dfu_test.tcl"
	    source $projDir/tcl/tests/usb_dfu_test.tcl
	} else {
	    log_message "Protocol tests file does not exist."
	    working_stop .main.f_flow.l_flow black [.main cget -background]
	    .main.f_flow.l_flow configure -text "Operations Flow"
	    close $logFileId
	    return 0
	}
    }
    working_stop .main.f_flow.l_flow black [.main cget -background]
    .main.f_flow.l_flow configure -text "Operations Flow"
    close $logFileId
    updateGUI onAnyCommunicationOn
    devcUpdateDeviceFrame
    set testArray(nonRegress) 0
    set testArray(protocol) 0
    set logFileId [open $testArray(logFile) "r"]
    while {[gets $logFileId line] >= 0} {
	if {[string first "Total" $line] != -1} then {
	    set first [string wordstart $line end]
	    set nFail [string range $line $first end]
	    break
	}
    }
    close $logFileId
    if {$nFail == 0} then {
	set message "Tests PASS."
	messageBox "Tests Information" info $message
    } else {
	set message "Tests FAIL."
	messageBox "Tests Information" warning $message
    }
    update
    #dbgEndProc [info level [info level]]
    return 1
}
proc notImplemented {} {
    #dbgBeginProc [info level [info level]]
    set parentWindow [focus]
    tk_messageBox -icon warning -message "This function is not implemented, yet!" -title "Flip message" -type ok -parent $parentWindow
    #dbgEndProc [info level [info level]]
    return
}
proc existLeading0x {addr} {
    #dbgBeginProc [info level [info level]]
    if {([string first "0x" $addr] == -1) &&([string first "0X" $addr] == -1)} then {
	#dbgEndProc [info level [info level]]
	return 0
    } else {
	#dbgEndProc [info level [info level]]
	return 1
    }
}
proc isValidHexaInput {data} {
    if {[existLeading0x $data]} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	set status 0
    } elseif {! [string is xdigit -strict $data]} {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	set status 0
    } else {
	set status 1
    }
    return $status
}
proc isValidIntegerInput {data} {
    #dbgBeginProc [info level [info level]]
    if {! [string is integer -strict $data]} then {
	set message "Input is not valid."
	messageBox "Entry Check" warning $message
	set status 0
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc checkFilePathname {path} {
    #dbgBeginProc [info level [info level]]
    if {$path == ""} then {
	set message "No file specified."
	messageBox "Entry Check" warning $message
	set status 0
    } else {
	if {[glob -nocomplain [file dirname $path]] == ""} then {
	    set message "Pathname does not exist."
	    messageBox "Entry Check" warning $message
	    set status -1
	} else {
	    set status 1
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc startExtraTimeOutCounter {timeOut} {
    global extraTimeOutId extraTimeOut
    set extraTimeOut 1
    set extraTimeOutId [after $timeOut "set extraTimeOut -1"]
    update
    return
}
proc stopExtraTimeOutCounter {} {
    global extraTimeOutId extraTimeOut
    catch [after cancel $extraTimeOutId]
    set extraTimeOut 0
    update
    return
}
proc cbParseHexFile {} {
    #dbgBeginProc [info level [info level]]
    global buffer progBar
    set progBar(cancel) 0
    set hexFile [fileOpenGet "Open File" "hex"]
    if {$hexFile == 0} then {
	#dbgEndProc [info level [info level]]
	return -1
    } else {
	log_message "HEX file [lindex [file split $hexFile] end] selected..."
	#dbgEndProc [info level [info level]]
	return [parseHexFile $hexFile]
    }
}
proc extractData {address hexLine maxAddr} {
    #dbgBeginProc [info level [info level]]
    global buffer temp
    #dbgEndProc [info level [info level]]
    return [extractData_C [format %d $address] $hexLine [format %d $maxAddr]]
}
proc parseHexFile {hexFile} {
    #dbgBeginProc [info level [info level]]
    global gui progBar loadConfig flipStates
    set flipStates(hexFileName) $hexFile
    set hexFileSize [file size $hexFile]
    set numberOfLines [expr ($hexFileSize / 45) + 1]
    if {[catch {set hexFileId [open $hexFile "r"]}]} then {
	set message "Cannot open the HEX file."
	messageBox "Entry Check" error $message
	log_message "HEX file not opened"
	return 0
    }
    .f_status.pb configure -percent 0 -shape 3D -color blue
    set prevLastLoadMinProgAddr $gui(lastLoadMinProgAddr)
    set prevLastLoadMaxProgAddr $gui(lastLoadMaxProgAddr)
    set gui(lastLoadMinProgAddr) $gui(maxAddr)
    set gui(lastLoadMaxProgAddr) 000000
    if {$gui(resetBufferOnLoading) == "yes"} then {
	resetBuffer
    }
    set gui(hexFileAddrOffset) "0000"
    set lineIndex 1
    set percent 0
    set refPercent 5
    set progBar(cancel) 0
    log_message "Loading HEX file [lindex [file split $hexFile] end]..."
    .f_status.pb configure -percent 0 -shape 3D -color blue
    bind . <Escape> {set progBar(cancel) 1}
    update
    while {([gets $hexFileId hexLine] > 0) &&(! $progBar(cancel))} {
	set percent [expr ($lineIndex * 100) / $numberOfLines]
	if {$percent >= $refPercent} then {
	    .f_status.pb configure -percent $percent
	    incr refPercent +5
	    update
	}
	set recordLength 0X[string range $hexLine 1 2]
	if {$recordLength != 0} then {
	    set address 0x[string range $hexLine 3 6]
	    set address [expr 0x$gui(loadingOffset) + $address]
	    if {$address < "0x$gui(lastLoadMinProgAddr)"} then {
		set gui(lastLoadMinProgAddr) [format %06X $address]
	    }
	    if {[expr $address + $recordLength - 1] > "0x$gui(lastLoadMaxProgAddr)"} then {
		set gui(lastLoadMaxProgAddr) [format %06X [expr $address + $recordLength - 1]]
	    }
	    set addressError [extractData $address $hexLine "0x$gui(maxAddr)"]
	    if {$addressError >= 1} then {
		break
	    }
	    incr lineIndex
	} else {
	    if {$hexLine == ":00000001FF"} then {
		break
	    }
	}
    }
    close $hexFileId
    cmdsResetProgressBar
    if {$progBar(cancel) == 1} then {
	log_message "HEX file [lindex [file split $hexFile] end] loading canceled"
	set status 0
    } elseif {$addressError == 1} {
	log_message "Buffer Overflow"
	set message "Address error. Buffer overflow."
	messageBox "Buffer Check" error $message
	set status 0
    } elseif {$addressError == 2} {
	log_message "HEX file checksum error at line $lineIndex."
	set message "HEX file checksum error."
	messageBox "Information" error $message
	set status 0
    } else {
	writeBuffer lastLoadMinProgAddr $gui(lastLoadMinProgAddr)
	writeBuffer lastLoadMaxProgAddr $gui(lastLoadMaxProgAddr)
	if {[readBuffer rangeOnDeviceProg] == "lastLoad"} then {
	    writeBuffer minProgAddr $gui(lastLoadMinProgAddr)
	    writeBuffer maxProgAddr $gui(lastLoadMaxProgAddr)
	}
	log_message "HEX file [lindex [file split $hexFile] end] loading done"
	actionsLog_message "HEX file [lindex [file split $hexFile] end] loading done"
	set gui(fileLoaded) "yes"
	set flipStates(hexFileMtime) [file mtime $hexFile]
	#dbgShowVar "flipStates(hexFileMtime) = $flipStates(hexFileMtime)"
	set loadConfig(parseHex) "parseHexFile \"$hexFile\""
	writeBuffer hexFileName [file tail $hexFile]
	writeBuffer hexFileSize [displayHexFileSize $gui(lastLoadMinProgAddr) $gui(lastLoadMaxProgAddr)]
	updateGuiParameters
	if (0) then {
	    .main.f_buffer.f_hexFile.l_fileS configure -text [displayHexFileSize $gui(lastLoadMinProgAddr) $gui(lastLoadMaxProgAddr)] -fg blue
	}
	#dbgEndProc [info level [info level]]
	set status 1
	set flipStates(bufferInInitialState) 0
    }
    return $status
}
proc cmdsLoadConfig {} {
    #dbgBeginProc [info level [info level]]
    set cfgFile [fileOpenGet "Open Configuration File" "cfg"]
    if {$cfgFile == 0} then {
	#dbgEndProc [info level [info level]]
	return -1
    } else {
	parseConfigFile $cfgFile
	#dbgEndProc [info level [info level]]
	return 1
    }
}
proc runLastLoadedConfigFile {} {
    global flipStates
    parseConfigFile $flipStates(lastloadedCfgFile) execute
    return
}
proc cbSaveConfig {} {
    #dbgBeginProc [info level [info level]]
    global env initialDir
    set cfgFile [fileSaveGet "Save Configuration File" "cfg"]
    if {($cfgFile == 0) ||($cfgFile == "")} then {
	#dbgEndProc [info level [info level]]
	return -1
    } else {
	#dbgEndProc [info level [info level]]
	return [openCfgFile $cfgFile]
    }
}
proc openCfgFile f {
    #dbgBeginProc [info level [info level]]
    set configFileId [open $f "w"]
    writeActionsToCfgFile $configFileId
    close $configFileId
    #dbgEndProc [info level [info level]]
    return
}
proc writeActionsToCfgFile cfgFile {
    global loadConfig
    set operationValid 0
    if {[info exists ::deviceArray(name)]} then {
	puts $cfgFile "selectDevice $::deviceArray(name)"
    }
    if {$loadConfig(port) != ""} then {
	puts $cfgFile $loadConfig(port)
    }
    if {$loadConfig(baud) != ""} then {
	puts $cfgFile $loadConfig(baud)
    }
    if {[info exists loadConfig(protocol)]} then {
	if {$loadConfig(protocol) != ""} then {
	    puts $cfgFile $loadConfig(protocol)
	}
    }
    if {$loadConfig(initComm) != ""} then {
	puts $cfgFile $loadConfig(initComm)
    }
    if {$loadConfig(parseHex) != ""} then {
	puts $cfgFile $loadConfig(parseHex)
	set operationValid 1
	#dbgShowInfo "operationValid set by parseHex"
    }
    if {$loadConfig(fullChipErase) != ""} then {
	puts $cfgFile $loadConfig(fullChipErase)
	set operationValid 1
	#dbgShowInfo "operationValid set by fullChipErase"
    }
    for {set i 0} {$i <=4} {incr i} {
	if {$loadConfig(eraseBlock$i) != ""} then {
	    puts $cfgFile $loadConfig(eraseBlock$i)
	    set operationValid 1
	    #dbgShowInfo "operationValid set by eraseBlock$i"
	}
    }
    if {$loadConfig(blankCheck) != ""} then {
	puts $cfgFile $loadConfig(blankCheck)
	set operationValid 1
	#dbgShowInfo "operationValid set by blankCheck"
    }
    if {$loadConfig(blankCheckStart) != ""} then {
	puts $cfgFile $loadConfig(blankCheckStart)
    }
    if {$loadConfig(blankCheckEnd) != ""} then {
	puts $cfgFile $loadConfig(blankCheckEnd)
    }
    if {$loadConfig(programDevice) != ""} then {
	puts $cfgFile $loadConfig(programDevice)
	set operationValid 1
	#dbgShowInfo "operationValid set by programDevice"
    }
    if {$loadConfig(verifyDevice) != ""} then {
	puts $cfgFile $loadConfig(verifyDevice)
	set operationValid 1
	#dbgShowInfo "operationValid set by verifyDevice"
    }
    if {$loadConfig(setSbv) != ""} then {
	puts $cfgFile $loadConfig(setSbv)
	set operationValid 1
	#dbgShowInfo "operationValid set by setSbv"
    }
    if {$loadConfig(setBsb) != ""} then {
	puts $cfgFile $loadConfig(setBsb)
	set operationValid 1
	#dbgShowInfo "operationValid set by setBsb"
    }
    if {$loadConfig(setOscFuse) != ""} then {
	puts $cfgFile $loadConfig(setOscFuse)
	set operationValid 1
	#dbgShowInfo "operationValid set by setOscFuse"
    }
    if {$loadConfig(setBljbFuse) != ""} then {
	puts $cfgFile $loadConfig(setBljbFuse)
	set operationValid 1
	#dbgShowInfo "operationValid set by setBljbFuse"
    }
    if {$loadConfig(setX2Fuse) != ""} then {
	puts $cfgFile $loadConfig(setX2Fuse)
	set operationValid 1
	#dbgShowInfo "operationValid set by setX2Fuse"
    }
    if {$loadConfig(setSsb) != ""} then {
	puts $cfgFile $loadConfig(setSsb)
	set operationValid 1
	#dbgShowInfo "operationValid set by setSsb"
    }
    if {$operationValid} then {
    }
    return
}
proc createConfigFile {{f "deflt"}} {
    global workingDir loadConfig env
    if {([info exists ::deviceArray(name)]) &&($::deviceArray(name) != "dummy")} then {
	if {$f == "deflt"} then {
	    if {[file writable $workingDir]} then {
		set configFileId [open $workingDir/flip.cfg "w"]
	    } else {
		set parentWindow [focus]
		tk_messageBox -icon warning -message "No write permission to \n $workingDir" -title "Configuration File" -type ok -parent $parentWindow
	    }
	} else {
	    set path [file dirname $f]
	    if {[file writable $path]} then {
		set configFileId [open $f "w"]
	    } else {
		set parentWindow [focus]
		tk_messageBox -icon warning -message "No write permission to \n $path" -title "Configuration File" -type ok -parent $parentWindow
	    }
	}
	writeActionsToCfgFile $configFileId
	close $configFileId
    }
    return
}
proc setupFullEraseDevice {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set gui(flowErase) 1
    writeBuffer flowErase 1
    set gui(eraseType) "full"
    #dbgEndProc [info level [info level]]
    return
}
proc setupEraseBlock0 {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set gui(flowErase) 1
    writeBuffer flowErase 1
    set gui(eraseType) "blocks"
    set gui(eraseBlock0) 1
    writeBuffer eraseBlock0 1
    #dbgEndProc [info level [info level]]
    return
}
proc setupEraseBlock1 {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set gui(flowErase) 1
    writeBuffer flowErase 1
    set gui(eraseType) "blocks"
    set gui(eraseBlock1) 1
    writeBuffer eraseBlock1 1
    #dbgEndProc [info level [info level]]
    return
}
proc setupEraseBlock2 {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set gui(flowErase) 1
    writeBuffer flowErase 1
    set gui(eraseType) "blocks"
    set gui(eraseBlock2) 1
    writeBuffer eraseBlock2 1
    #dbgEndProc [info level [info level]]
    return
}
proc setupEraseBlock3 {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set gui(flowErase) 1
    writeBuffer flowErase 1
    set gui(eraseType) "blocks"
    set gui(eraseBlock3) 1
    writeBuffer eraseBlock3 1
    #dbgEndProc [info level [info level]]
    return
}
proc setupEraseBlock4 {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set gui(flowErase) 1
    writeBuffer flowErase 1
    set gui(eraseType) "blocks"
    set gui(eraseBlock4) 1
    writeBuffer eraseBlock4 1
    #dbgEndProc [info level [info level]]
    return
}
proc setupBlankCheckDevice {} {
    global gui
    set gui(flowBlankCheck) 1
    writeBuffer flowBlankCheck 1
    return
}
proc setupProgramDevice {} {
    global gui
    set gui(flowProgram) 1
    writeBuffer flowProgram 1
    return
}
proc setupVerifyDevice {} {
    global gui
    set gui(flowVerify) 1
    writeBuffer flowVerify 1
    return
}
proc setupStartAppli {reset} {
    global gui
    set gui(flowStartAppli) 1
    writeBuffer flowStartAppli 1
    set gui(flowWithReset) $reset
    writeBuffer flowWithReset $reset
    return
}
proc setupSBV {sbvValue} {
    global gui
    set gui(flowSpecialBytes) 1
    writeBuffer flowSpecialBytes 1
    set ::deviceArray(sbv) $sbvValue
    return
}
proc setupBSB {bsbValue} {
    global gui
    set gui(flowSpecialBytes) 1
    writeBuffer flowSpecialBytes 1
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) $bsbValue
    }
    return
}
proc setupOscFuse {oscFuseValue} {
    global gui
    set gui(flowSpecialBytes) 1
    writeBuffer flowSpecialBytes 1
    set ::deviceArray(oscFuse) $oscFuseValue
    return
}
proc setupBljbFuse {bljbFuseValue} {
    global gui
    set gui(flowSpecialBytes) 1
    writeBuffer flowSpecialBytes 1
    set ::deviceArray(bljbFuse) $bljbFuseValue
    return
}
proc setupX2Fuse {x2FuseValue} {
    global gui
    set gui(flowSpecialBytes) 1
    writeBuffer flowSpecialBytes 1
    set ::deviceArray(x2Fuse) $x2FuseValue
    return
}
proc setupSecurityLevel {sLevel} {
    global gui
    set gui(flowSpecialBytes) 1
    writeBuffer flowSpecialBytes 1
    set ::deviceArray(level) $sLevel
    return
}
proc cbWriteHexFile {} {
    #dbgBeginProc [info level [info level]]
    global gui progBar
    set progBar(cancel) 0
    set hexFile [fileSaveGet "Save File" "hex"]
    if {($hexFile == 0) ||($hexFile == "")} then {
	#dbgEndProc [info level [info level]]
	return -1
    } else {
	log_message "HEX file [lindex [file split $hexFile] end] selected..."
	#dbgEndProc [info level [info level]]
	return [writeHexFile $hexFile]
    }
}
proc writeHexFile {hexFile} {
    #dbgBeginProc [info level [info level]]
    global gui progBar
    set hexFileId [open $hexFile "w"]
    set addrLo [format %06X 0x$gui(minProgAddr)]
    set addrHi [format %06X 0x$gui(maxProgAddr)]
    set nbData [expr 0x$addrHi - 0x$addrLo + 1]
    set nbFullLines [expr $nbData / 16]
    if {$nbFullLines != 0} then {
	set lineIndex 1
	set percent 0
	set refPercent 5
	set progBar(cancel) 0
	log_message "Writing HEX file [lindex [file split $hexFile] end]..."
	.f_status.pb configure -percent 0 -shape 3D -color blue
	bind . <Escape> {set progBar(cancel) 1}
	update
	while {($lineIndex <= $nbFullLines) &&(! $progBar(cancel))} {
	    set percent [expr ($lineIndex * 100) / $nbFullLines]
	    if {$percent >= $refPercent} then {
		.f_status.pb configure -percent $percent
		incr refPercent +5
		update
	    }
	    set addrHi [format %06X [expr 0x$addrLo + 15]]
	    puts $hexFileId [buildIntelFrame 0x$addrLo 0x$addrHi]
	    set addrLo [format %06X [expr 0x$addrHi + 1]]
	    incr lineIndex
	}
    }
    cmdsResetProgressBar
    if {! $progBar(cancel)} then {
	if {$addrLo <= [format %06X 0x$gui(maxProgAddr)]} then {
	    set addrHi [format %06X 0x$gui(maxProgAddr)]
	    puts $hexFileId [buildIntelFrame 0x$addrLo 0x$addrHi]
	}
	set hexLine ":00000001FF"
	puts $hexFileId $hexLine
	close $hexFileId
	log_message "HEX file [lindex [file split $hexFile] end] written"
	actionsLog_message "HEX file [lindex [file split $hexFile] end] written"
    } else {
	close $hexFileId
	file delete $hexFile
	log_message "HEX file [lindex [file split $hexFile] end] deleted"
    }
    #dbgEndProc [info level [info level]]
    return 1
}
proc checkSum {argsList} {
    #dbgBeginProc [info level [info level]]
    set sum 0x00
    foreach i $argsList {
	set sum [format "%#04X" [expr $sum + 0x$i]]
    }
    #dbgEndProc [info level [info level]]
    return [format %02X [expr [format "%#04X" [expr ~$sum + 0x01]] & 0xFF]]
}
proc buildIntelFrame {addrLo addrHi} {
    #dbgBeginProc [info level [info level]]
    set recLen [format "%02X" [expr $addrHi - $addrLo + 1]]
    set address [format "%04X" $addrLo]
    set recType "00"
    for {set addr $addrLo} {$addr <= $addrHi} {incr addr} {
	set dataList [lappend dataList [readBuffer [format %06X $addr]]]
    }
    set hexLine [join $dataList ""]
    set hexLine [append hexLine [checkSum [concat $recLen [string range $address 0 1] [string range $address 2 3] $recType $dataList]]]
    set hexLine [join [linsert $hexLine 0 ":" $recLen $address $recType] ""]
    #dbgEndProc [info level [info level]]
    return $hexLine
}
proc cmdsReadAddrRange {{addrLo "000000"} {addrHi $gui(maxAddr)}} {
    #dbgBeginProc [info level [info level]]
    global gui progBar deviceArray testArray flipStates
    set addrLo [subst $addrLo]
    set addrHi [subst $addrHi]
    set addrLo [cmdsZeroxPrefix $addrLo]
    set addrHi [cmdsZeroxPrefix $addrHi]
    .f_status.pb configure -percent 0 -shape 3D -color blue
    clearStatusMessage
    set numberOfBlocks [expr (($addrHi - $addrLo) / $flipStates(readBlockSize)) + 1]
    set progBar(cancel) 0
    set percent 0
    set refPercent 5
    if {! $testArray(protocol)} then {
	log_message "Reading $::deviceArray(name) memory..."
    }
    .f_status.pb configure -percent 0 -shape 3D -color blue
    bind . <Escape> {set progBar(cancel) 1}
    if {[winfo exists .deviceReadDBox]} then {
	bind .deviceReadDBox <Escape> {set progBar(cancel) 1}
    }
    update
    set status 1
    set blockIndex 0
    for {set addr $addrLo} {$addr <= $addrHi} {set addr [expr $addr + $flipStates(readBlockSize)]; incr blockIndex} {
	set percent [expr ($blockIndex * 100) / $numberOfBlocks]
	if {$percent >= $refPercent} then {
	    .f_status.pb configure -percent $percent
	    incr refPercent +5
	    update
	}
	set hiBound [expr $addr + $flipStates(readBlockSize) - 0x1]
	if {[expr $hiBound >= $addrHi]} then {
	    set status [ptclReadBlock [format "%#04X" $addr] [format "%#04X" $addrHi] [readDeviceArray displayData]]
	    break
	} else {
	    set status [ptclReadBlock [format "%#04X" $addr] [format "%#04X" $hiBound] [readDeviceArray displayData]]
	}
	if {! $status} then {
	    break
	} elseif {$progBar(cancel)} {
	    set status 0
	    log_message "Device verification canceled."
	    break
	}
    }
    cmdsResetProgressBar
    if {[winfo exists .deviceReadDBox]} then {
	bind .deviceReadDBox <Escape> {}
    }
    update
    if {! $testArray(protocol)} then {
	if {$status} then {
	    log_message "$::deviceArray(name) memory reading pass"
	} else {
	    log_message "$::deviceArray(name) memory reading aborted"
	}
    }
    set flipStates(bufferInInitialState) 0
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsDeviceErase {} {
    #dbgBeginProc [info level [info level]]
    global loadConfig gui testArray
    updateGUI onDeviceActionStart
    if {$gui(eraseType) == "full"} then {
	set loadConfig(fullChipErase) "setupFullEraseDevice"
	if {! $testArray(protocol)} then {
	    log_message "Erasing the device..."
	}
	set status [ptclFullChipErase]
	if {$status} then {
	    if {! $testArray(protocol)} then {
		log_message "Full Chip Erase done"
	    }
	    actionsLog_message "Full Chip Erase done"
	    devcUpdateDeviceFrame
	} else {
	    if {! $testArray(protocol)} then {
		log_message "Full Chip Erase fail"
	    }
	}
    } else {
	set status 1
	if {!$gui(eraseBlock0) && !$gui(eraseBlock1) && !$gui(eraseBlock2) && !$gui(eraseBlock3) && !$gui(eraseBlock4)} then {
	    log_message "Please select a block to be erased..."
	    set status 0
	}
	if {$gui(eraseBlock0)} then {
	    set loadConfig(eraseBlock0) "setupEraseBlock0"
	    set status [ptclEraseBlock0]
	    if {$status} then {
		if {! $testArray(protocol)} then {
		    log_message "Block 0 erasing done"
		    actionsLog_message "Block 0 erasing done"
		}
	    } else {
		if {! $testArray(protocol)} then {
		    log_message "Block 0 erasing fail"
		}
	    }
	}
	if {$gui(eraseBlock1) &&($status)} then {
	    set loadConfig(eraseBlock1) "setupEraseBlock1"
	    set status [ptclEraseBlock1]
	    if {$status} then {
		if {! $testArray(protocol)} then {
		    log_message "Block 1 erasing done"
		    actionsLog_message "Block 1 erasing done"
		}
	    } else {
		if {! $testArray(protocol)} then {
		    log_message "Block 1 erasing fail."
		}
	    }
	}
	if {$gui(eraseBlock2) &&($status)} then {
	    set loadConfig(eraseBlock2) "setupEraseBlock2"
	    set status [ptclEraseBlock2]
	    if {$status} then {
		if {! $testArray(protocol)} then {
		    log_message "Block 2 erasing done"
		    actionsLog_message "Block 2 erasing done"
		}
	    } else {
		if {! $testArray(protocol)} then {
		    log_message "Block 2 erasing fail"
		}
	    }
	}
	if {$gui(eraseBlock3) &&($status)} then {
	    set loadConfig(eraseBlock3) "setupEraseBlock3"
	    set status [ptclEraseBlock3]
	    if {$status} then {
		if {! $testArray(protocol)} then {
		    log_message "Block 3 erasing done"
		    actionsLog_message "Block 3 erasing done"
		}
	    } else {
		if {! $testArray(protocol)} then {
		    log_message "Block 3 erasing fail"
		}
	    }
	}
	if {$gui(eraseBlock4) &&($status)} then {
	    set loadConfig(eraseBlock4) "setupEraseBlock4"
	    set status [ptclEraseBlock4]
	    if {$status} then {
		if {! $testArray(protocol)} then {
		    log_message "Block 4 erasing done"
		    actionsLog_message "Block 4 erasing done"
		}
	    } else {
		if {! $testArray(protocol)} then {
		    log_message "Block 4 erasing fail"
		}
	    }
	}
    }
    updateGUI onDeviceActionStop
    #dbgEndProc [info level [info level]]
    return $status
}
proc fileOpenGet {title {fileType "none"}} {
    #dbgBeginProc [info level [info level]]
    global initialDir
    if {$fileType == "cfg"} then {
	set file_types {
{ "Config. Files"   { .cfg .CFG .Cfg } }
{ "Hex Files"   { .hex .HEX .Hex } }
{ "Text Files"  { .txt .TXT } }
{ "All Files"   * }
}
    } else {
	set file_types {
{ "Hex Files"   { .hex .HEX .Hex } }
{ "Config. Files"   { .cfg .CFG .Cfg } }
{ "Text Files"  { .txt .TXT } }
{ "All Files"   * }
}
    }
    set filename [tk_getOpenFile -initialdir $initialDir -filetypes $file_types -title "$title" -parent .]
    if {($filename != "") &&([file exists $filename])} then {
	set initialDir [file dirname $filename]
	#dbgEndProc [info level [info level]]
	return $filename
    } else {
	#dbgEndProc [info level [info level]]
	return 0
    }
}
proc fileSaveGet {title {fileType "none"}} {
    #dbgBeginProc [info level [info level]]
    global initialDir
    if {$fileType == "cfg"} then {
	set file_types {
{ "Config. Files"   { .cfg .CFG .Cfg } }
}
	set defaultExt "cfg"
    } elseif {$fileType == "hex"} {
	set file_types {
{ "Hex Files"   { .hex .HEX .Hex } }
}
	set defaultExt "hex"
    } else {
	set file_types {
{ "Text Files"  { .txt .TXT } }
{ "All Files"   * }
}
	set defaultExt "txt"
    }
    set filename [tk_getSaveFile -initialdir $initialDir -filetypes $file_types -defaultextension $defaultExt -title "$title" -parent .]
    if {$filename != ""} then {
	set initialDir [file dirname $filename]
    }
    #dbgEndProc [info level [info level]]
    return $filename
}
proc clearStatusMessage {} {
    #dbgBeginProc [info level [info level]]
    global testArray
    if {! $testArray(protocol)} then {
	set w .f_status.l_message
	$w configure -text ""
    }
    #dbgEndProc [info level [info level]]
    return
}
proc setProgBarMessage {msg} {
    #dbgBeginProc [info level [info level]]
    set w .progressBarDbox.l_actionOnGoing
    if {[winfo exists $w]} then {
	$w configure -text $msg
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc closeProgBarWindow {} {
    #dbgBeginProc [info level [info level]]
    set w .progressBarDbox
    if {[winfo exists $w]} then {
	destroy $w
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc connectRS232 {prot} {
    #dbgBeginProc [info level [info level]]
    global protcl projDir flipStates gui device
    global cfgFileId deviceArray
    set prot "Standard"
    cmdsImportCurrentMemoryNameSpace [lindex $::deviceArray(memoryList) 0]
    catch [ptclCancelRs232Comm]
    if {$flipStates(canNode) == "open"} then {
	ptclSelectNode
    }
    if {$flipStates(canComm) == "on"} then {
	ptclCancelCANComm
    }
    set protcl RS232$prot
    if {[ptclInitRs232Comm] != 1} then {
	#dbgEndProc [info level [info level]]
	if {[info exists cfgFileId]} then {
	    set returnCode "break"
	} else {
	    set returnCode "ok"
	}
    } else {
	set returnCode "ok"
    }
    #dbgEndProc [info level [info level]]
    return -code $returnCode
}
proc startNewCommandLine txt {
    #dbgBeginProc [info level [info level]]
    global PROMPT
    $txt insert insert $PROMPT
    $txt mark set boundary insert
    #dbgEndProc [info level [info level]]
    return
}
proc doCommand txt {
    #dbgBeginProc [info level [info level]]
    set CommandLine [$txt get boundary end]
    if {[info complete $CommandLine]} then {
	catch {interact eval $CommandLine} CatchBak
	if {"$CatchBak" != ""} then {
	    $txt insert insert \n$CatchBak
	}
	$txt insert insert \n
	startNewCommandLine $txt
	$txt see {insert linestart}
	$txt see insert
    } else {
	$txt insert insert \n
	$txt see insert
    }
    #dbgEndProc [info level [info level]]
    return
}
proc selectDevice {device} {
    #dbgBeginProc [info level [info level]]
    global flipStates gui projDir protocol tclTestDir
    catch [unset protocol]
    catch [unset protcl]
    wm withdraw .deviceSelectDbox
    update
    cancelEveryLink
    destroy .deviceErase
    drawDeviceEraseDbox
    catch [rename ptclProgramData ""]
    catch [rename ptclWriteSBV ""]
    catch [rename ptclWriteBSB ""]
    init
    source $projDir/tcl/devices/${device}.tcl
    updateGUI onAnyCommunicationOff
    updateGUI onDeviceSelection
    log_message "Settings > Communication..."
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsForgetEraseOptions {} {
    global gui
    set gui(eraseType) [readBuffer eraseType]
    set gui(erasePossibleBlocks) [readBuffer erasePossibleBlocks]
    set gui(erasePossibleBlock0) [readBuffer erasePossibleBlock0]
    set gui(eraseBlock0) [readBuffer eraseBlock0]
    set gui(erasePossibleBlock1) [readBuffer erasePossibleBlock1]
    set gui(eraseBlock1) [readBuffer eraseBlock1]
    set gui(erasePossibleBlock2) [readBuffer erasePossibleBlock2]
    set gui(eraseBlock2) [readBuffer eraseBlock2]
    set gui(erasePossibleBlock3) [readBuffer erasePossibleBlock3]
    set gui(eraseBlock3) [readBuffer eraseBlock3]
    set gui(erasePossibleBlock4) [readBuffer erasePossibleBlock4]
    set gui(eraseBlock4) [readBuffer eraseBlock4]
    return
}
proc cmdsForgetReadOptions {} {
    global gui
    set gui(startReadAddr) [readBuffer startReadAddr]
    set gui(endReadAddr) [readBuffer endReadAddr]
    return
}
proc cbOnResetBlankCheck {} {
    #dbgBeginProc [info level [info level]]
    global blankCheckAddr gui flipFont
    focus .blankCheckDBox
    set gui(blankCheckMin) [format $gui(infoFormat) 0x$gui(minProgAddr)]
    set gui(blankCheckMax) [format $gui(infoFormat) 0x$gui(maxProgAddr)]
    updateGUI onBlankCheckOptionsChange
    .blankCheckDBox.f_results.l_results configure -text "no check" -font $flipFont
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsEraseSBVBSB {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclEraseSBVBSB]
    if {$status} then {
	ptclReadSBV
	ptclReadBSB
	focus .
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc cbOnResetReadDBox {} {
    #dbgBeginProc [info level [info level]]
    global gui
    focus .deviceReadDBox
    set gui(startReadAddr) [format $gui(infoFormat) 0x000000]
    set gui(endReadAddr) [format $gui(infoFormat) 0x$gui(maxProgAddr)]
    .deviceReadDBox.f_results.l_results configure -text "no reading"
    #dbgEndProc [info level [info level]]  
    return
}
proc cmdsReadDevice {} {
    #dbgBeginProc [info level [info level]]
    global gui progBar
    if {![isValidHexaInput $gui(startReadAddr)]} then {
	return 0
    }
    if {"0x$gui(startReadAddr)" > "0x$gui(endReadAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    if {"0x$gui(startReadAddr)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(startReadAddr) [format $gui(infoFormat) 0x$gui(startReadAddr)]
    if {![isValidHexaInput $gui(endReadAddr)]} then {
	return 0
    }
    if {"0x$gui(endReadAddr)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(endReadAddr) [format $gui(infoFormat) 0x$gui(endReadAddr)]
    if {[winfo exists .deviceReadDBox]} then {
	focus .deviceReadDBox
    } else {
	focus .
    }
    updateGUI onDeviceActionStart
    set status [cmdsReadAddrRange $gui(startReadAddr) $gui(endReadAddr)]
    updateGUI onDeviceActionStop
    if {$status} then {
	gotoAddress $gui(startReadAddr)
    }
    updateBufferChecksum
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsClearOperations {state} {
    #dbgBeginProc [info level [info level]]
    global saveArray gui color
    set flowList { \
	    flowErase \
	    flowBlankCheck \
	    flowProgram \
	    flowVerify \
	    flowSpecialBytes \
	}
    set bErase .main.f_flow.f_operations.b_erase
    set bBlankCheck .main.f_flow.f_operations.b_blankCheck
    set bProgram .main.f_flow.f_operations.b_program
    set bVerify .main.f_flow.f_operations.b_verify
    set bSpecialBytes .main.f_flow.f_operations.b_specialBytes
    set buttons_List [list $bErase $bBlankCheck $bProgram $bVerify $bSpecialBytes]
    if {$state == 0} then {
	foreach i $flowList {
	    set gui($i) 0
	    writeBuffer $i 0
	}
    }
    foreach button $buttons_List {
	$button configure -selectcolor $color(systemWindow)
    }
    foreach i $flowList {
	set gui(${i}Color) $color(systemWindow)
	writeBuffer ${i}Color $color(systemWindow)
    }
    #dbgEndProc [info level [info level]]
    return
}
proc cbOnOkTimersDbox {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    if {![isValidIntegerInput $waitTime(standard)]} then {
	return 0
    }
    if {![isValidIntegerInput $waitTime(extended)]} then {
	return 0
    }
    wm withdraw .timersDBox
    focus .
    update
    #dbgEndProc [info level [info level]]
    return 1
}
proc cbCheckCANOptions {} {
    #dbgBeginProc [info level [info level]]
    set w .canOptions
    wm withdraw $w
    #dbgEndProc [info level [info level]]
    return
}
proc runOperations {} {
    cmdsRunOperations
    return
}
proc setupSerialize {memory initVal nBytes step lsbAddr} {
    #dbgBeginProc [info level [info level]]
    global serialize
    if {[lsearch $::::deviceArray(memoryList) $memory] == -1} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid memory selection." -foreground red
	return
    }
    if {[expr [string length $initVal] % 2] != 0} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid initial value." -foreground red
	return
    }
    if {! [string is xdigit $initVal]} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid initial value." -foreground red
	return
    }
    if {! [expr ($nBytes >= 1) && ($nBytes <= 8)]} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid number of bytes." -foreground red
	return
    }
    if {$step == 0} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid step value." -foreground red
	return
    }
    cmdsImportCurrentMemoryNameSpace $memory
    set addrMax [expr [readDeviceArray memorySize] * 1024 - 1]
    if {[expr $lsbAddr > $addrMax]} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid storage address." -foreground red
	return
    }
    if {[expr $lsbAddr < ($nBytes - 1)]} then {
	.main.f_buffer.f_serialNum.l_number configure -text "Invalid storage address." -foreground red
	return
    }
    .main.f_buffer.f_serialNum.l_number configure -text ""
    set serialize(memory) $memory
    set serialize(initVal) $initVal
    set serialize(nBytes) $nBytes
    set serialize(step) $step
    set serialize(lsbAddr) $lsbAddr
    set serialize(do_it) 1
    cmdsImportCurrentMemoryNameSpace FLASH
    #dbgEndProc [info level [info level]]
    return
}
proc serializePart {} {
    #dbgBeginProc [info level [info level]]
    global serialize
    if {! $serialize(execute)} then {
	set j 0
	for {set i [expr [string length $serialize(initVal)] - 1]} {$i >= 0} {incr i -1} {
	    set nibble 0x[string index $serialize(initVal) $i]
	    for {set X 1} {$X <= 8} {set X [expr $X * 2]} {
		if {$nibble & $X} then {
		    set ::sn($j) 1
		} else {
		    set ::sn($j) 0
		}
		incr j 1
	    }
	}
    }
    cmdsImportCurrentMemoryNameSpace $serialize(memory)
    set snStrg ""
    for {set i [expr $serialize(nBytes) * 8 - 1]} {$i >= 0} {incr i -4} {
	set nibble 0
	for {set j 0} {$j <= 3} {incr j} {
	    set nibble [expr $nibble + $::sn([expr $i - 3 + $j]) * int(pow(2,$j))]
	}
	append snStrg [format %X $nibble]
    }
    .main.f_buffer.f_serialNum.l_number configure -text $snStrg -foreground red
    for {set i 0} {$i < $serialize(nBytes)} {incr i} {
	set byte [string range $snStrg [expr $i * 2] [expr $i * 2 + 1]]
	writeBuffer [format %06X [expr $serialize(lsbAddr) - $serialize(nBytes) + 1 + $i]] $byte
    }
    if {[winfo exists .bufferEditWindow]} then {
	updateBufferWidget 0.0
    }
    set ::flipStates(bufferInInitialState) 0
    cmdsDeviceProgram [format %06X [expr $serialize(lsbAddr) - $serialize(nBytes) + 1]] [format %06X $serialize(lsbAddr)]
    if {$serialize(step) > 0} then {
	for {set i 0} {$i < $serialize(step)} {incr i} {
	    incSn
	}
    } elseif {$serialize(step) < 0} {
	for {set i 0} {$i > $serialize(step)} {incr i -1} {
	    decSn
	}
    }
    cmdsImportCurrentMemoryNameSpace FLASH
    set serialize(execute) 1
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsRunOperations {} {
    #dbgBeginProc [info level [info level]]
    global saveArray gui serialize
    updateGUI onRunOperations
    set ff .main.f_flow
    set bRun $ff.f_buttons.b_run
    set bClear $ff.f_buttons.b_clear
    set bErase $ff.f_operations.b_erase
    set bBlankCheck $ff.f_operations.b_blankCheck
    set bProgram $ff.f_operations.b_program
    set bVerify $ff.f_operations.b_verify
    set bSpecialBytes $ff.f_operations.b_specialBytes
    set saveArray(flowErase) $gui(flowErase)
    set saveArray(flowBlankCheck) $gui(flowBlankCheck)
    set saveArray(flowProgram) $gui(flowProgram)
    set saveArray(flowVerify) $gui(flowVerify)
    set saveArray(flowSpecialBytes) $gui(flowSpecialBytes)
    if {(($gui(flowErase) == 0) ||([$bErase cget -state] == "disabled")) &&(($gui(flowBlankCheck) == 0) ||([$bBlankCheck cget -state] == "disabled")) &&(($gui(flowProgram) == 0) ||([$bProgram cget -state] == "disabled")) &&(($gui(flowVerify) == 0) ||([$bVerify cget -state] == "disabled")) &&(($gui(flowSpecialBytes) == 0) ||([$bSpecialBytes cget -state] == "disabled"))} then {
	log_message "Please select operations..."
	updateGUI onRunOperationsCompleted
	#dbgEndProc [info level [info level]]
	return "ok"
    }
    set status 1
    if {[info exists ::deviceArray(sbv)]} then {
	set sbv $::deviceArray(sbv)
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set bsb $::deviceArray(bsb)
    }
    if {[info exists ::deviceArray(eb)]} then {
	set eb $::deviceArray(eb)
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ssb $::deviceArray(ssb)
    }
    if {[info exists ::deviceArray(level)]} then {
	set level $::deviceArray(level)
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	#dbgShowInfo "::deviceArray(oscFuse) exists"
	set oscFuse $::deviceArray(oscFuse)
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set bljbFuse $::deviceArray(bljbFuse)
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set x2Fuse $::deviceArray(x2Fuse)
    }
    if {($saveArray(flowErase) == 1) &&([.main.f_flow.f_operations.b_erase cget -state] == "normal")} then {
	set status [cmdsDeviceErase]
	$bErase configure -state normal
	if {$status} then {
	    writeBuffer flowEraseColor green
	    $bErase configure -selectcolor green
	} else {
	    writeBuffer flowEraseColor red
	    $bErase configure -selectcolor red
	}
	update
    }
    if {($saveArray(flowBlankCheck) == 1) &&($status) &&([.main.f_flow.f_operations.b_blankCheck cget -state] == "normal")} then {
	set status [cmdsBlankCheck]
	if {$status == -1} then {
	    writeBuffer flowBlankCheckColor green
	    $bBlankCheck configure -selectcolor green
	    set status 1
	} else {
	    writeBuffer flowBlankCheckColor red
	    $bBlankCheck configure -selectcolor red
	    set status 0
	}
	update
    }
    if {($saveArray(flowProgram) == 1) &&($status)} then {
	$bProgram configure -state normal
	update
	set status [cmdsDeviceProgram]
	if {$status} then {
	    writeBuffer flowProgramColor green
	    $bProgram configure -selectcolor green
	} else {
	    writeBuffer flowProgramColor red
	    $bProgram configure -selectcolor red
	}
	update
    }
    if {($saveArray(flowVerify) == 1) &&($status)} then {
	$bVerify configure -state normal
	update
	set status [cmdsDeviceVerify]
	#dbgShowVar "verify state: $status"
	if {$status} then {
	    #dbgShowInfo "verify PASS"
	    writeBuffer flowVerifyColor green
	    $bVerify configure -selectcolor green
	} else {
	    #dbgShowInfo "verify FAIL"
	    writeBuffer flowVerifyColor red
	    $bVerify configure -selectcolor red
	}
	update
    }
    if {($saveArray(flowSpecialBytes) == 1) &&($status)} then {
	if {$gui(flowErase) == 1} then {
	    if {[info exists sbv]} then {
		set ::deviceArray(sbv) $sbv
	    }
	    if {[info exists bsb]} then {
		if {[info exists ::deviceArray(bsb)]} then {
		    set ::deviceArray(bsb) $bsb
		}
	    }
	    if {[info exists eb]} then {
		set ::deviceArray(eb) $eb
	    }
	    if {[info exists level]} then {
		set ::deviceArray(level) $level
	    }
	    if {[info exists oscFuse]} then {
		#dbgShowInfo "oscFuse exists"
		set ::deviceArray(oscFuse) $oscFuse
	    }
	    if {[info exists bljbFuse]} then {
		set ::deviceArray(bljbFuse) $bljbFuse
	    }
	    if {[info exists x2Fuse]} then {
		set ::deviceArray(x2Fuse) $x2Fuse
	    }
	}
	if {$saveArray(flowProgram) == 1} then {
	    if {[info exists ::deviceArray(bsb)]} then {
		set ::deviceArray(bsb) $bsb
	    }
	}
	$bSpecialBytes configure -state normal
	update
	set status [devcSetDeviceSpecialBytes]
	if {$status} then {
	    writeBuffer flowSpecialBytesColor green
	    $bSpecialBytes configure -selectcolor green
	} else {
	    writeBuffer flowSpecialBytesColor red
	    $bSpecialBytes configure -selectcolor red
	}
	update
    }
    if {[lsearch [buildSkipProcList] ptclReadSSB] == -1} then {
	if {! $status} then {
	    restoreSSB $ssb
	} else {
	    ptclReadSSB
	}
    }
    if {$gui(flowStartAppli)} then {
	ptclStartAppli $gui(flowWithReset)
    }
    if {$serialize(do_it)} then {
	serializePart
    }
    updateGUI onRunOperationsCompleted
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsBlankCheck {} {
    #dbgBeginProc [info level [info level]]
    global blankCheckAddr gui loadConfig flipFont testArray
    set lResults .blankCheckDBox.f_results.l_results
    if {![winfo exists $lResults]} then {
	drawBlankCheckDbox
    }
    if {![isValidHexaInput $gui(blankCheckMin)]} then {
	return 0
    }
    if {"0x$gui(blankCheckMin)" > "0x$gui(blankCheckMax)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    if {"0x$gui(blankCheckMin)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(blankCheckMin) [format $gui(infoFormat) 0x$gui(blankCheckMin)]
    set loadConfig(blankCheckStart) "set gui(blankCheckMin) $gui(blankCheckMin)"
    if {![isValidHexaInput $gui(blankCheckMax)]} then {
	return 0
    }
    if {"0x$gui(blankCheckMax)" > "0x$gui(maxAddr)"} then {
	set message "Address is out of range."
	messageBox "Edit Buffer" warning $message
	return 0
    }
    set gui(blankCheckMax) [format $gui(infoFormat) 0x$gui(blankCheckMax)]
    set loadConfig(blankCheckEnd) "set gui(blankCheckMax) $gui(blankCheckMax)"
    if {[winfo exists .blankCheckDBox]} then {
	focus .blankCheckDBox
    } else {
	focus .
    }
    updateGUI onDeviceActionStart
    set status [ptclBlankCheck $gui(blankCheckMin) $gui(blankCheckMax)]
    if {$status == "-1"} then {
	$lResults configure -text "Pass" -font $flipFont
	if {! $testArray(protocol)} then {
	    actionsLog_message "Blank Check Pass"
	    log_message "Blank Check Pass"
	}
    } elseif {$status != "-2"} {
	set status 0x$status
	$lResults configure -text "Fail at $status" -font $flipFont
	if {! $testArray(protocol)} then {
	    actionsLog_message "Blank Check Fail at $status"
	    log_message "Blank Check Fail at $status"
	}
    }
    updateGUI onDeviceActionStop
    set loadConfig(blankCheck) "setupBlankCheckDevice"
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsDeviceVerify {{minProgAddr $gui(minProgAddr)} {maxProgAddr $gui(maxProgAddr)}} {
    #dbgBeginProc [info level [info level]]
    global gui deviceArray progBar loadConfig testArray flipStates
    set minProgAddr [subst $minProgAddr]
    set maxProgAddr [subst $maxProgAddr]
    #dbgShowVar "addrMin = $minProgAddr"
    #dbgShowVar "addrMax = $maxProgAddr"
    if {! $testArray(protocol)} then {
	log_message "Verifying $::deviceArray(name) Memory..."
    }
    set status 0
    .f_status.pb configure -percent 0 -shape 3D -color blue
    set addrLo 0x$minProgAddr
    set addrHi 0x$maxProgAddr
    set numberOfBlocks [expr (($addrHi - $addrLo) / $flipStates(readBlockSize)) + 1]
    set progBar(cancel) 0
    set percent 0
    set refPercent 5
    bind . <Escape> {set progBar(cancel) 1}
    update
    set blockIndex 0
    for {set addr $addrLo} {$addr <= $addrHi} {set addr [expr $addr + $flipStates(readBlockSize)]; incr blockIndex} {
	set percent [expr ($blockIndex * 100) / $numberOfBlocks]
	if {$percent >= $refPercent} then {
	    .f_status.pb configure -percent $percent
	    incr refPercent +5
	    update
	}
	set hiBound [expr $addr + $flipStates(readBlockSize) - 0x1]
	if {[expr $hiBound >= $addrHi]} then {
	    set status [ptclReadBlock [format "%#04X" $addr] [format "%#04X" $addrHi] [readDeviceArray displayData] "compare"]
	    break
	} else {
	    set status [ptclReadBlock [format "%#04X" $addr] [format "%#04X" $hiBound] [readDeviceArray displayData] "compare"]
	}
	if {! $status} then {
	    break
	} elseif {$progBar(cancel)} {
	    set status 0
	    log_message "Device verification canceled."
	    break
	}
    }
    cmdsResetProgressBar
    if {$status == 1} then {
	if {! $testArray(protocol)} then {
	    log_message "Memory Verify Pass"
	    actionsLog_message "Memory Verify Pass"
	}
    }
    set loadConfig(verifyDevice) "setupVerifyDevice"
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsReloadHexFileIfChanged {} {
    global flipStates
    set status 1
    if {[file exists $flipStates(hexFileName)]} then {
	if {[file mtime $flipStates(hexFileName)] != $flipStates(hexFileMtime)} then {
	    set w .main.f_buffer.f_hexFile.l_fileN
	    if {[winfo exists $w]} then {
		$w configure -fg red
		set answer [tk_messageBox -icon question -message "The HEX file has been changed on disk.\n\nReload it ?" -title "Flip HEX file message" -type yesno]
		if {$answer == "yes"} then {
		    set status [parseHexFile $flipStates(hexFileName)]
		    .main.f_buffer.f_hexFile.l_fileN configure -fg black
		}
	    }
	}
    }
    return $status
}
proc cmdsWarningBufferNotProgrammed {} {
    global flipStates
    set answer [tk_messageBox -message "The buffer initial contents has not been  modified. Do you wish to continue programming ?" -title "Programming Information" -type yesno -icon question]
    if {$answer == "yes"} then {
	return 1
    } else {
	return 0
    }
}
proc cmdsDeviceProgram {{minProgAddr $gui(minProgAddr)} {maxProgAddr $gui(maxProgAddr)}} {
    #dbgBeginProc [info level [info level]]
    global protocol gui deviceArray progBar waitTime projDir loadConfig
    global flipStates testArray protcl
    if {$flipStates(bufferInInitialState)} then {
	if {! [cmdsWarningBufferNotProgrammed]} then {
	    clearStatusMessage
	    log_message "Device programming aborted."
	    return 0
	}
    }
    if {! [cmdsReloadHexFileIfChanged]} then {
	clearStatusMessage
	log_message "Device programming aborted."
	return 0
    }
    if {[info exists ::deviceArray(bootloaderId)]} then {
	if {$::deviceArray(bootloaderId) == "0001"} then {
	    storeSSBinBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
	    log_message "Computing CRC..."
	    storeCRCinBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
	    log_message "Done."
	    set minProgAddr 0
	    set maxProgAddr [format "%X" [expr [readDeviceArray memorySize] * 1024 - 1]]
	}
	if {$::deviceArray(bootloaderId) == "0002"} then {
	    storeCRCinBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
	    set minProgAddr 0
	    set maxProgAddr [format "%X" [expr [readDeviceArray memorySize] * 1024 - 1]]
	}
    }
    set minProgAddr [subst $minProgAddr]
    set maxProgAddr [subst $maxProgAddr]
    clearStatusMessage
    if {! $testArray(protocol)} then {
	log_message "Programming $::deviceArray(name)..."
    }
    set progBar(cancel) 0
    set numberOfFrames [expr ((0x$maxProgAddr - 0x$minProgAddr) / $protocol(frameLengthW)) + 1]
    set percent 0
    set refPercent 5
    set frameIndex 1
    .f_status.pb configure -percent 0 -shape 3D -color blue
    bind . <Escape> {set progBar(cancel) 1}
    update
    set address "0x$minProgAddr"
    set startT [clock clicks -milliseconds]
    set p "ptclSendIdProgStart"
    if {[info procs $p] == $p} then {
	set status [$p $minProgAddr $maxProgAddr [readDeviceArray progStart]]
	if {! $status} then {
	    return $status
	}
    }
    updateGUI onDeviceActionStart
    while {! $progBar(cancel)} {
	set percent [expr ($frameIndex * 100) / $numberOfFrames]
	if {$percent >= $refPercent} then {
	    .f_status.pb configure -percent $percent
	    incr refPercent +5
	}
	set distanceToFrameBoundary [expr $protocol(frameLengthW) - ($address % $protocol(frameLengthW)) - 1]
	set distanceToAddrMax [expr 0x$maxProgAddr - $address]
	if {$distanceToAddrMax <= $distanceToFrameBoundary} then {
	    set hiBound 0x$maxProgAddr
	    set breakOnNext 1
	} else {
	    set hiBound [expr $address + $distanceToFrameBoundary]
	    set breakOnNext 0
	}
	#dbgShowVar "breakOnNext = $breakOnNext"
	set status [ptclProgramData $address $hiBound [readDeviceArray programData]]
	#dbgShowVar "status = $status"
	set address [expr $address + $distanceToFrameBoundary + 1]
	if {$flipStates(canComm) == "on"} then {
	    if {$status == 0} then {
		break
	    }
	    if {($status == 1) &&(! $breakOnNext)} then {
		set message "FLIP has more data to send \n  but the bootloader cannot accept them."
		messageBox "Programming Information" error $message
		break
	    }
	    if {$breakOnNext} then {
		if {$status == 2} then {
		    set message "The bootloader expected more data from FLIP"
		    messageBox "Programming Information" error $message
		    break
		} else {
		    set status 1
		    break
		}
	    }
	} elseif {$flipStates(rs232Comm) == "on"} {
	    #david eseo
	    if {($protocol(name) == "rs232can") ||($protocol(name) == "canview")} then {
		if {$status == 0} then {
		    break
		}
		if {($status == 1) &&(! $breakOnNext)} then {
		    set message "FLIP has more data to send \n  but the bootloader cannot accept them."
		    messageBox "Programming Information" error $message
		    break
		}
		if {$breakOnNext} then {
		    if {$status == 2} then {
			set message "The bootloader expected more data from FLIP"
			messageBox "Programming Information" error $message
			break
		    } else {
			set status 1
			break
		    }
		}
	    } elseif {$breakOnNext ||($status != 1)} {
		break
	    }
	    #fin david eseo
	} elseif {$flipStates(usbComm) == "on"} {
	    if {$breakOnNext ||($status != 1)} then {
		break
	    }
	}
	incr frameIndex
	update
    }
    after 100
    update
    updateGUI onDeviceActionStop
    set stopT [clock clicks -milliseconds]
    cmdsResetProgressBar
    if {$progBar(cancel)} then {
	set mssg "$::deviceArray(name) programming canceled."
	log_message $mssg
	set status 0
    } elseif {$status == 1} {
	set mssg "$frameIndex frames sent in [expr ($stopT - $startT)/1000.0]sec. "
	if {! $testArray(protocol)} then {
	    log_message $mssg
	    actionsLog_message "$::deviceArray(name) programmed"
	}
    }
    if {([info exists ::deviceArray(bsb)]) &&(!$progBar(cancel)) &&($status == 1)} then {
	cmdsSetBsbToZero
    }
    if {[info exists ::deviceArray(bootloaderId)]} then {
	#dbgShowVar "::deviceArray(bootloaderId) = $::deviceArray(bootloaderId)"
	if {$::deviceArray(bootloaderId) == "0001"} then {
	    set status [readBootloaderCrcCheck]
	}
	if {$::deviceArray(bootloaderId) == "0002"} then {
	    #dbgShowVar "protcl = $protcl"
	    if {$protcl != "USB_DFU"} then {
		set status [readBootloaderCrcCheck]
	    }
	}
    } else {
	set status 0
    }
    set loadConfig(programDevice) "setupProgramDevice"
    #dbgShowVar "status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsResetProgressBar {} {
    .f_status.pb configure -color [.main cget -background] -shape flat -percent 0
    bind . <Escape> {}
    update
}
proc cmdsSetBsbToZero {} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(bsb) 00
    set p "ptclWriteBSB"
    set status 1
    if {[info procs $p] == $p} then {
	set status [$p $::deviceArray(bsb)]
    }
    if {$status} then {
	set p "ptclReadBSB"
	if {[info procs $p] == $p} then {
	    $p
	}
    } else {
	log_message "Could not program BSB."
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc cmdsToggleMemory {} {
    #dbgBeginProc [info level [info level]]
    set index [lsearch $::deviceArray(memoryList) $::deviceArray(currentMemory)]
    if {$index < [expr [llength $::deviceArray(memoryList)] - 1]} then {
	set ::deviceArray(currentMemory) [lindex $::deviceArray(memoryList) [expr $index + 1]]
	set ::deviceArray(currentMemoryButton) [lindex $::deviceArray(memoryButtonList) [expr $index + 1]]
	incr index 2
    } else {
	set ::deviceArray(currentMemory) [lindex $::deviceArray(memoryList) 0]
	set ::deviceArray(currentMemoryButton) [lindex $::deviceArray(memoryButtonList) 0]
	set index 1
    }
    cmdsImportCurrentMemoryNameSpace $::deviceArray(currentMemory)
    updateGuiParameters
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsImportCurrentMemoryNameSpace {memory} {
    #dbgBeginProc [info level [info level]]
    foreach m $::deviceArray(memoryList) {
	namespace forget ::${m}::*
    }
    namespace import ::${memory}::*
    #dbgShowVar "$memory selected"
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsOnEraseOptionsChange {} {
    #dbgBeginProc [info level [info level]]
    global gui
    writeBuffer eraseType $gui(eraseType)
    writeBuffer erasePossibleBlocks $gui(erasePossibleBlocks)
    writeBuffer erasePossibleBlock0 $gui(erasePossibleBlock0)
    writeBuffer eraseBlock0 $gui(eraseBlock0)
    writeBuffer erasePossibleBlock1 $gui(erasePossibleBlock1)
    writeBuffer eraseBlock1 $gui(eraseBlock1)
    writeBuffer erasePossibleBlock2 $gui(erasePossibleBlock2)
    writeBuffer eraseBlock2 $gui(eraseBlock2)
    writeBuffer erasePossibleBlock3 $gui(erasePossibleBlock3)
    writeBuffer eraseBlock3 $gui(eraseBlock3)
    writeBuffer erasePossibleBlock4 $gui(erasePossibleBlock4)
    writeBuffer eraseBlock4 $gui(eraseBlock4)
    if {$gui(eraseType) == "full"} then {
	set gui(blankCheckMin) [format $gui(infoFormat) 0]
	set gui(blankCheckMax) [format $gui(infoFormat) 0x[readBuffer maxAddr]]
    } else {
	set lMin [list]
	set lMax [list]
	foreach i {0 1 2 3 4} min {0x0 0x2000 0x4000 0x8000 0xC000} max {0x1FFF 0x3FFF 0x7FFF 0xBFFF 0xFFFF} {
	    if {$gui(eraseBlock${i})} then {
		lappend lMin $min
		lappend lMax $max
	    }
	}
	set min 0xFFFF
	set max 0x0000
	if {[llength $lMin] != 0} then {
	    foreach i $lMin {
		if {$i < $min} then {
		    set min $i
		}
	    }
	    foreach i $lMax {
		if {$i > $max} then {
		    set max $i
		}
	    }
	    set gui(blankCheckMin) [format $gui(infoFormat) $min]
	    set gui(blankCheckMax) [format $gui(infoFormat) $max]
	} else {
	    set gui(blankCheckMin) [format $gui(infoFormat) 0]
	    set gui(blankCheckMax) [format $gui(infoFormat) 0x[readBuffer maxAddr]]
	}
    }
    writeBuffer blankCheckMin $gui(blankCheckMin)
    writeBuffer blankCheckMax $gui(blankCheckMax)
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsOnReadOptionsChange {} {
    global gui
    writeBuffer startReadAddr $gui(startReadAddr)
    writeBuffer endReadAddr $gui(endReadAddr)
    return
}
proc cmdsSetMemoryParameters {} {
    #dbgBeginProc [info level [info level]]
    global gui
    writeBuffer uDefSizeValue [readDeviceArray memorySize]
    writeBuffer dDepSizeValue [readDeviceArray memorySize]
    writeBuffer sizeValue [readBuffer dDepSizeValue]
    writeBuffer rangeOnDeviceProg lastLoad
    writeBuffer fileLoaded "no"
    writeBuffer sizeType deviceDependent
    writeBuffer maxAddr [format "%06X" [expr ([readBuffer sizeValue] * 1024) - 1]]
    writeBuffer blankValueType deviceDependent
    writeBuffer uDefBlankValue FF
    writeBuffer dDepBlankValue [readDeviceArray blankValue]
    writeBuffer blankValue [readBuffer dDepBlankValue]
    writeBuffer resetBufferOnLoading no
    writeBuffer uDefMinProgAddr 000000
    writeBuffer uDefMaxProgAddr [readBuffer maxAddr]
    writeBuffer lastLoadMinProgAddr 000000
    writeBuffer lastLoadMaxProgAddr [readBuffer maxAddr]
    writeBuffer minProgAddr 0
    writeBuffer maxProgAddr [readBuffer maxAddr]
    writeBuffer loadingOffset "0000"
    writeBuffer hexFileAddrOffset "0000"
    writeBuffer hexFileName ""
    writeBuffer hexFileSize ""
    writeBuffer modifyAddress ""
    writeBuffer modifyData ""
    writeBuffer numberOfVisibleLines 24
    writeBuffer topDisplayedLine 1
    writeBuffer bottomDisplayedLine [readBuffer numberOfVisibleLines]
    writeBuffer numberOfLines [expr ("0x[readBuffer maxAddr]" + 1) / 16]
    writeBuffer startFillAddr [format $gui(infoFormat) 0x[readBuffer minProgAddr]]
    writeBuffer endFillAddr [format $gui(infoFormat) 0x[readBuffer maxProgAddr]]
    writeBuffer fillValue [readBuffer blankValue]
    writeBuffer maxSize [readDeviceArray memorySize]
    writeBuffer blankCheckMin [format $gui(infoFormat) 0]
    writeBuffer blankCheckMax [format $gui(infoFormat) [expr ([readBuffer sizeValue] * 1024) - 1]]
    writeBuffer startReadAddr [format $gui(infoFormat) 0]
    writeBuffer endReadAddr [format $gui(infoFormat) 0x[readBuffer maxAddr]]
    writeBuffer flowErase $gui(flowErase)
    writeBuffer flowBlankCheck $gui(flowBlankCheck)
    writeBuffer flowProgram $gui(flowProgram)
    writeBuffer flowVerify $gui(flowVerify)
    writeBuffer flowSpecialBytes $gui(flowSpecialBytes)
    writeBuffer flowEraseColor $gui(flowEraseColor)
    writeBuffer flowBlankCheckColor $gui(flowBlankCheckColor)
    writeBuffer flowProgramColor $gui(flowProgramColor)
    writeBuffer flowVerifyColor $gui(flowVerifyColor)
    writeBuffer flowSpecialBytesColor $gui(flowSpecialBytesColor)
    #dbgEndProc [info level [info level]]
    return
}
proc cmdsReadSpecialBytes {} {
    global deviceArrayBackup
    devcUpdateDeviceFrame
    foreach Byte [array names deviceArray] {
	set deviceArrayBackup($Byte) $::deviceArray($Byte)
    }
    return
}
proc cmdsRestoreSpecialBytes {} {
    global deviceArrayBackup
    foreach Byte [array names deviceArrayBackup] {
	set ::deviceArray($Byte) $deviceArrayBackup($Byte)
    }
    devcSetDeviceSpecialBytes
    return
}
proc ta {Name Index Op} {
    upvar $Name X
    #dbgShowInfo "- ARRAY TRACING - $Name $Index $Op $X([subst $Index])"
}
proc tv {Name Index Op} {
    upvar $Name X
    #dbgShowInfo "- VARIABLE TRACING - $Name $Index $Op $X"
}
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c5115 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates bootloaderVerDependent
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C5115"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    set bootloaderVerDependent(eeprom) 1
    set bootloaderVerDependent(eb) 1
    set bootloaderVerDependent(startAppli) 1
    set bootloaderVerDependent(p1p3p4_config) 1
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    namespace eval ::FLASH:: {
	variable buffer
	variable deviceArray
	set deviceArray(memorySize) 16
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable buffer
	variable deviceArray
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "01"
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable buffer
	    global flipStates
	    variable deviceArray
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set ::deviceArray(nnbConnect) "FF"
    set ::deviceArray(nnbProg) "XX"
    set ::deviceArray(crisConnect) "00"
    set ::deviceArray(crisProg) "XX"
    set ::deviceArray(btc1) "XX"
    set ::deviceArray(btc2) "XX"
    set ::deviceArray(btc3) "XX"
    set ::deviceArray(p1_config) "XX"
    set ::deviceArray(p3_config) "XX"
    set ::deviceArray(p4_config) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    if {0} then {
	set bBLJB $fFuses.b_bljb
	checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
	setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    }
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    set bConfigPorts $fFuses.b_cfgp
    button $bConfigPorts -bd 3 -text "Configure HW" -font $flipFont -command {cbDboxWakeUp .configP1P3P4Window} -state disabled -width 13
    setBalloon $bConfigPorts "Configure Hardware Conditions"
    pack config $bConfigPorts $bX2 -side left -padx 5 -pady 5 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite $bCanConfig -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    if {$protocol == "RS232Standard"} then {
	set ::deviceArray(skipList) "  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.4  checksum-5.5  checksum-5.6  checksum-5.13  checksum-5.14 "
    } elseif {($protocol == "CANStandard") ||($protocol == "rs232can")} {
	set ::deviceArray(skipList) "  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30 "
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
drawP1P3P4ConfigDbox
t89c5115
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc AT89C5131 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates bootloaderVerDependent
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C5131"
    set ::deviceArray(communicationList) "USB RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    set ::deviceArray(usb_dfu_default_product_id) 0x2FFD
    set ::deviceArray(startAppliTest) {43 BC 80 43 BC 10 75 83 00 75 82 1C 74 \
	    F4 75 D1 08 F0 75 D1 00 43 A2 20 12 FF F3 02 00 00}
    set ::deviceArray(startAppliFailAddr) 0X001C
    set bootloaderVerDependent(p1p3p4_config) 1
    set bootloaderVerDependent(eb) 1
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 1
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "01"
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard"
    set ::deviceArray(p1_config) "XX"
    set ::deviceArray(p3_config) "XX"
    set ::deviceArray(p4_config) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) D7
    set expAnsw(readDevId2) F7
    set expAnsw(readDevId3) DF
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "F4"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set ::deviceArray(oscCtrl) 3
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    set bConfigPorts $fFuses.b_cfgp
    button $bConfigPorts -bd 3 -text "LPC" -font $flipFont -command {cbDboxWakeUp .configP1P3P4Window} -state disabled
    setBalloon $bConfigPorts "Configure Hardware Conditions\n Low Pin Count devices only"
    set bConfigOsc $fFuses.b_cfgOsc
    button $bConfigOsc -bd 3 -text "OSC" -font $flipFont -command {cbDboxWakeUp .configOscWindow} -state disabled
    setBalloon $bConfigOsc "Configure Oscillator"
    pack config $bBLJB $bX2 $bConfigPorts $bConfigOsc -side left -padx 2 -pady 5 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "BSB / EB / SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte / Extra Byte / Software Boot Vector"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    set e_SBV $f_BSB.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    pack config $l_BSB $e_BSB $e_EB $e_SBV -padx 1 -pady 5 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    switch $protocol {
    USB_DFU {
	    set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30 "
	}
    RS232Standard {
	    set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30 "
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
drawP1P3P4ConfigDbox
AT89C5131
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51snd1 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C5132"
    set ::deviceArray(communicationList) "RS232 USB"
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(usb_dfu_default_product_id) 0x2FFF
    set ::deviceArray(startAppliFailAddr) 0X001C
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set ::deviceArray(nnbConnect) "FF"
    set ::deviceArray(nnbProg) "XX"
    set ::deviceArray(crisConnect) "00"
    set ::deviceArray(crisProg) "XX"
    set ::deviceArray(btc1) "XX"
    set ::deviceArray(btc2) "XX"
    set ::deviceArray(btc3) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 1
    set testFlag(eraseBlock4) 1
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "F0"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    setBalloon $bBlock3 "Erase memory between 8000 and BFFF"
    setBalloon $bBlock4 "Erase memory between C000 and FFFF"
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 128
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -padx 10 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    if {0} then {
	set bMemorySelect .main.f_buffer.b_memSelect
	if {! [winfo exists $bMemorySelect]} then {
	    button $bMemorySelect -bd 3 -text $::deviceArray(currentMemory) -font $flipFont -command {cmdsToggleMemory} -width 8 -state disabled
	    setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
	}
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    switch $protocol {
    USB_DFU {
	    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.25 "
	}
    RS232Standard {
	    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.25 "
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51snd1
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc at89c51cc03 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51CC03"
    set ::deviceArray(communicationList) "CAN RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "01"
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set ::deviceArray(nnbConnect) "FF"
    set ::deviceArray(nnbProg) "XX"
    set ::deviceArray(crisConnect) "00"
    set ::deviceArray(crisProg) "XX"
    set ::deviceArray(btc1) "XX"
    set ::deviceArray(btc2) "XX"
    set ::deviceArray(btc3) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -padx 10 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite $bCanConfig -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    if {$protocol == "RS232Standard"} then {
	set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    } elseif {($protocol == "CANStandard") ||($protocol == "rs232can") ||($protocol == "usbcan") ||($protocol == "canview")} {
	set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30 "
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
at89c51cc03
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc at89c51ed2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51ED2"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bOsc $fFuses.b_osc
    checkbutton $bOsc -text "Osc. B" -font $flipFont -variable ::deviceArray(oscFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bOsc "Osc. B set : Osc B = 0"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  flash-2.23.1  flash-2.25  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
at89c51ed2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51ic2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51IC2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bOsc $fFuses.b_osc
    checkbutton $bOsc -text "Osc. B" -font $flipFont -variable ::deviceArray(oscFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bOsc "Osc. B set : Osc B = 0"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bOsc $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "
xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51ic2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc at89c51id2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51ID2"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bOsc $fFuses.b_osc
    checkbutton $bOsc -text "Osc. B" -font $flipFont -variable ::deviceArray(oscFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bOsc "Osc. B set : Osc B = 0"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bOsc $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  flash-2.23.1  flash-2.25  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
at89c51id2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51rb2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51RB2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 16
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 0
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.4  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51rb2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51rc2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51RC2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51rc2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc at89c51rd2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51RD2"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bOsc $fFuses.b_osc
    checkbutton $bOsc -text "Osc. B" -font $flipFont -variable ::deviceArray(oscFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bOsc "Osc. B set : Osc B = 0"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  flash-2.23.1  flash-2.25  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
at89c51rd2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51snd1 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "AT89C51SND1"
    set ::deviceArray(communicationList) "RS232 USB"
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(usb_dfu_default_product_id) 0x2FFF
    set ::deviceArray(startAppliFailAddr) 0X001C
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set ::deviceArray(nnbConnect) "FF"
    set ::deviceArray(nnbProg) "XX"
    set ::deviceArray(crisConnect) "00"
    set ::deviceArray(crisProg) "XX"
    set ::deviceArray(btc1) "XX"
    set ::deviceArray(btc2) "XX"
    set ::deviceArray(btc3) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 1
    set testFlag(eraseBlock4) 1
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "F0"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    setBalloon $bBlock3 "Erase memory between 8000 and BFFF"
    setBalloon $bBlock4 "Erase memory between C000 and FFFF"
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 128
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -padx 10 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    if {0} then {
	set bMemorySelect .main.f_buffer.b_memSelect
	if {! [winfo exists $bMemorySelect]} then {
	    button $bMemorySelect -bd 3 -text $::deviceArray(currentMemory) -font $flipFont -command {cmdsToggleMemory} -width 8 -state disabled
	    setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
	}
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    switch $protocol {
    USB_DFU {
	    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.25 "
	}
    RS232Standard {
	    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.25 "
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51snd1
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc at8xc5122 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    #dbgShowInfo [array names ::deviceArray]
    set ::deviceArray(name) "AT8XC5122"
    set ::deviceArray(communicationList) "RS232 USB"
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(usb_dfu_default_product_id) 0x2FFE
    set ::deviceArray(startAppliTest) {43 D1 08 74 F8 75 83 00 75 82 11 F0 53 \
	    D1 F7 75 83 00 75 82 00 E4 73 02 00 00}
    set ::deviceArray(startAppliFailAddr) 0X0011
    namespace eval ::FLASH:: {
	variable buffer
	variable deviceArray
	set deviceArray(memorySize) 32
	set deviceArray(cramSize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable buffer
	    global flipStates
	    variable deviceArray
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 1
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set protocol(frameLengthW) 64
    set protocol(frameLengthR) 64
    set expAnsw(readSSBlev0) [list FF BF 7F 3F]
    set expAnsw(readSSBlev0Test) "0F"
    set expAnsw(readSSBlev1) [list FE BE 7E 3E]
    set expAnsw(readSSBlev1Test) "0E"
    set expAnsw(readSSBlev2) [list FC BC 7C 3C XX]
    set expAnsw(readSSBlev2Test) "0C"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) D7
    set expAnsw(readDevId2) FC
    set expAnsw(readDevId3) FF
    set testFlag(eraseBlock0) 0
    set testFlag(eraseBlock1) 0
    set testFlag(eraseBlock2) 0
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 0
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    setBalloon $bBlock3 "Erase memory between 8000 and BFFF"
    setBalloon $bBlock4 "Erase memory between C000 and FFFF"
    set ::deviceArray(bootlVer) "XX"
    set ::deviceArray(deviceBootId1) "XX"
    set ::deviceArray(deviceBootId2) "XX"
    set ::deviceArray(ssb) "XX"
    set ::deviceArray(level) "X"
    set ::deviceArray(eraseType) "full"
    set ::deviceArray(crc) "XXXX"
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050703EF"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 5 -fill both
    pack configure $fReadOnly -side top -padx 5 -pady 5 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fCRC .main.f_device.f_crc
    frame $fCRC -relief groove -bd 1
    set bCRC $fCRC.b_crc
    button $bCRC -bd 3 -text "CRC" -font $flipFont -command {storeAndDisplayCRC [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]} -state normal
    setBalloon $bCRC "Launches a CRC calculation"
    set eCRC $fCRC.e_crc
    entry $eCRC -textvariable ::deviceArray(crc) -width 5 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eCRC "CRC actual value"
    pack configure $bCRC $eCRC -side left -padx 10
    pack configure $fCRC -side top -padx 5 -pady 5 -ipady 5 -fill both
    frame .main.f_device.f_dummy -height 220
    pack .main.f_device.f_dummy
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bExec $fButtons.b_exec
    button $bExec -bd 3 -text "Start Application" -font $flipFont -command {ptclStartAppli 0} -state disabled
    setBalloon $bExec "Starts application at address 0x0000"
    pack config $bExec -side left -padx 5
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 10 -pady 10 -fill both
    pack forget .main.f_flow.f_operations.b_specialBytes
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.*  flash-2.*  fuse-3.*  specific-4.4  specific-4.5  specific-4.6  specific-4.7  specific-4.8  specific-4.9  specific-4.10  specific-4.11  specific-4.12  specific-4.13  specific-4.14  specific-4.15  specific-4.16  specific-4.17  checksum-5.1  checksum-5.1  checksum-5.2  checksum-5.3  checksum-5.4  checksum-5.5  checksum-5.6  checksum-5.7  checksum-5.8  checksum-5.9  checksum-5.10  checksum-5.11  checksum-5.12  checksum-5.13  checksum-5.14  checksum-5.15 \
      checksum-5.16  checksum-5.18  checksum-5.19  checksum-5.20  checksum-5.21  checksum-5.22  checksum-5.23  checksum-5.24  checksum-5.25  checksum-5.27  checksum-5.30  checksum-5.31  eeprom-* "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL [list ptclReadManufId ptclReadDeviceId1 ptclReadDeviceId2 ptclReadDeviceId3 ptclReadHwByte ptclReadSBV ptclReadBSB ptclReadSSB ptclReadEB ptclReadBTC1 ptclReadBTC2 ptclReadBTC3 ptclReadNNB ptclReadCRIS ptclReadPortsConfig updateBypassBitsDisplay]
    return $skipL
}
at8xc5122
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]  #dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc lu2000 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "LU2000"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(usb_dfu_default_product_id) 0x2FFF
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "normal"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "normal"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 1
    set testFlag(eraseBlock4) 1
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "F8"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    setBalloon $bBlock3 "Erase memory between 8000 and BFFF"
    setBalloon $bBlock4 "Erase memory between C000 and FFFF"
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(selBootFuse)]} then {
	set ::deviceArray(selBootFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bSelBoot $fFuses.b_selboot
    checkbutton $bSelBoot -text "SELBOOT" -font $flipFont -variable ::deviceArray(selBootFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bSelBoot "Boot Select Bit \nSet = 0 / Unset = 1"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bSelBoot $bBLJB $bX2 -side left -padx 3 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    if {0} then {
	set bMemorySelect .main.f_buffer.b_memSelect
	if {! [winfo exists $bMemorySelect]} then {
	    button $bMemorySelect -bd 3 -text $::deviceArray(currentMemory) -font $flipFont -command {cmdsToggleMemory} -width 8 -state disabled
	    setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
	}
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    switch $protocol {
    USB_DFU {
	    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.25 "
	}
    RS232Standard {
	    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.25 "
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
lu2000
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51ac2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51AC2"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM CUSTOM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select CUSTOM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat" "white"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::CUSTOM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 64
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(displayData) "03"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "08"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::CUSTOM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 16
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -padx 10 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
t89c51ac2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51cc01 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51CC01"
    set ::deviceArray(communicationList) "CAN RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "01"
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set ::deviceArray(nnbConnect) "FF"
    set ::deviceArray(nnbProg) "XX"
    set ::deviceArray(crisConnect) "00"
    set ::deviceArray(crisProg) "XX"
    set ::deviceArray(btc1) "XX"
    set ::deviceArray(btc2) "XX"
    set ::deviceArray(btc3) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -padx 10 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite $bCanConfig -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    if {$protocol == "RS232Standard"} then {
	set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    } elseif {($protocol == "CANStandard") ||($protocol == "rs232can") ||($protocol == "usbcan") ||($protocol == "canview")} {
	set ::deviceArray(skipList) "  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30 "
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
t89c51cc01
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51cc02 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits flipFont rs232standard canstandard expAnsw testFlag buffer flowButtons flipStates
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    set ::deviceArray(name) "T89C51CC02"
    set ::deviceArray(communicationList) "CAN RS232"
    set ::deviceArray(memoryList) [list FLASH EEPROM]
    set ::deviceArray(memoryButtonList) [list "Select EEPROM" "Select FLASH"]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    set ::deviceArray(currentMemoryButton) "Select EEPROM"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 16
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    namespace eval ::EEPROM:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 2
	set deviceArray(blankValue) "FF"
	set buffer(erase) "disabled"
	set buffer(blankCheck) "disabled"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "01"
	set deviceArray(displayData) "02"
	set deviceArray(blankCheck) "XX"
	set deviceArray(programData) "07"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
    }
    proc ::FLASH::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xCAFEFADE
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    proc ::EEPROM::bufferChecksum {} {
	variable buffer
	global flipStates
	set min $buffer(minProgAddr)
	set max $buffer(maxProgAddr)
	if {$flipStates(simul)} then {
	    return 0xDEADBEEF
	} else {
	    return [computeBufferChecksum_C $min $max]
	}
    }
    set ::deviceArray(jumpAdd) "0000"
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set ::deviceArray(CANProtocolsList) "Standard Enhanced"
    set ::deviceArray(nnbConnect) "FF"
    set ::deviceArray(nnbProg) "XX"
    set ::deviceArray(crisConnect) "00"
    set ::deviceArray(crisProg) "XX"
    set ::deviceArray(btc1) "XX"
    set ::deviceArray(btc2) "XX"
    set ::deviceArray(btc3) "XX"
    set ::deviceArray(p1_config) "XX"
    set ::deviceArray(p3_config) "XX"
    set ::deviceArray(p4_config) "XX"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2Test) "FC"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    $bBlock3 configure -state disabled
    $bBlock4 configure -state disabled
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer code value"
    pack config $lManufId $eManufId -padx 1 -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Family code value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Device name code"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Device revision number"
    pack config $lDeviceIds $eDeviceId1 $eDeviceId2 $eDeviceId3 -padx 1 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 $eDeviceBootId2 -padx 1 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Security Byte value"
    pack config $lHSB $eHSB -padx 1 -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -padx 1 -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    if {0} then {
	set bBLJB $fFuses.b_bljb
	checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
	setBalloon $bBLJB "Boot Loader Jump Bit \nSet = 0 / Unset = 1"
    }
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    set bConfigPorts $fFuses.b_cfgp
    button $bConfigPorts -bd 3 -text "Configure HW" -font $flipFont -command {cbDboxWakeUp .configP1P3P4Window} -state disabled -width 13
    setBalloon $bConfigPorts "Configure Hardware Conditions"
    pack config $bConfigPorts $bX2 -side left -padx 5 -pady 5 -anchor w
    pack configure $fFuses -side top -padx 5 -pady 5 -fill x
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB & EB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte & Extra Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    set e_EB $f_BSB.e_eb
    entry $e_EB -textvariable ::deviceArray(eb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_EB "Actual EB value"
    pack config $l_BSB $e_BSB $e_EB -padx 1 -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -padx 1 -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -padx 1 -side left
    pack config $fInfo -side top
    set fLevel $fSSB.f_level
    frame $fLevel -relief flat
    set bLevel0 $fLevel.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set bLevel1 $fLevel.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set bLevel2 $fLevel.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: neither reading nor writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 2 -fill both
    pack configure $fLevel -side top -anchor w -pady 5 -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fStartApp .main.f_device.f_startApp
    frame $fStartApp -relief groove -borderwidth 1
    button $fStartApp.b_start -text "Start Application" -bd 3 -font $flipFont -state disabled -command {ptclStartAppli $flipStates(withReset)}
    setBalloon $fStartApp.b_start "Starts application at address 0x0000"
    checkbutton $fStartApp.b_reset -text "With Reset" -font $flipFont -variable flipStates(withReset) -indicatoron true -state disabled
    setBalloon $fStartApp.b_reset "If set, generates a hardware reset pulse\n  when the Start Application button is pressed."
    pack configure $fStartApp.b_start $fStartApp.b_reset -side left -padx 5 -pady 5
    pack configure $fStartApp -padx 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    pack configure $fButtons -side top
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bCanConfig $fButtons.b_canconfig
    button $bCanConfig -bd 3 -text "CAN" -font $flipFont -command {cbDboxWakeUp .canNodeConfigDbox} -state disabled
    setBalloon $bCanConfig "Sets a CAN node parameters"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {! [winfo exists $bMemorySelect]} then {
	button $bMemorySelect -bd 3 -text $::deviceArray(currentMemoryButton) -font $flipFont -command {cmdsToggleMemory} -width 14 -state disabled
	setBalloon $bMemorySelect "FLIP will perform all operations\n on the selected memory"
    }
    pack config $bUpdate $bWrite $bCanConfig -side left -padx 15
    pack configure $fButtons -side top -padx 5 -pady 15 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    if {$protocol == "RS232Standard"} then {
	set ::deviceArray(skipList) "  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.4  checksum-5.5  checksum-5.6  checksum-5.13  checksum-5.14 "
    } elseif {($protocol == "CANStandard") ||($protocol == "rs232can")} {
	set ::deviceArray(skipList) "  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30 "
    }
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
drawCanNodeConfigDbox
drawP1P3P4ConfigDbox
t89c51cc02
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51ib2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51IB2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 16
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 0
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bOsc $fFuses.b_osc
    checkbutton $bOsc -text "Osc. B" -font $flipFont -variable ::deviceArray(oscFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bOsc "Osc. B set : Osc B = 0"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bOsc $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte (SSB)"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.4  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51ib2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51ic2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51IC2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bOsc $fFuses.b_osc
    checkbutton $bOsc -text "Osc. B" -font $flipFont -variable ::deviceArray(oscFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bOsc "Osc. B set : Osc B = 0"
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bOsc $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "
xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51ic2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51rb2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51RB2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 16
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 0
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.4  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51rb2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51rc2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51RC2"
    set ::deviceArray(communicationList) RS232
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 32
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "normal"
	set buffer(erasePossibleBlock0) "normal"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "normal"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "normal"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list FE]
    set expAnsw(readSSBlev1Test) "FE"
    set expAnsw(readSSBlev2) [list FC XX]
    set expAnsw(readSSBlev2Test) [list FC]
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) XX
    set expAnsw(readDevId2) XX
    set expAnsw(readDevId3) XX
    set testFlag(eraseBlock0) 1
    set testFlag(eraseBlock1) 1
    set testFlag(eraseBlock2) 1
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 1
    set testFlag(readDevBootId2) 1
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 1
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    if {[info exists ::deviceArray(sbv)]} then {
	set ::deviceArray(sbv) "XX"
    }
    if {[info exists ::deviceArray(bsb)]} then {
	set ::deviceArray(bsb) "XX"
    }
    if {[info exists ::deviceArray(ssb)]} then {
	set ::deviceArray(ssb) "XX"
    }
    if {[info exists ::deviceArray(hsb)]} then {
	set ::deviceArray(hsb) "XX"
    }
    if {[info exists ::deviceArray(eb)]} then {
	set ::deviceArray(eb) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId1)]} then {
	set ::deviceArray(deviceBootId1) "XX"
    }
    if {[info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(deviceBootId2) "XX"
    }
    if {[info exists ::deviceArray(oscFuse)]} then {
	set ::deviceArray(oscFuse) 1
    }
    if {[info exists ::deviceArray(bljbFuse)]} then {
	set ::deviceArray(bljbFuse) 1
    }
    if {[info exists ::deviceArray(x2Fuse)]} then {
	set ::deviceArray(x2Fuse) 1
    }
    if {[info exists ::deviceArray(level)]} then {
	set ::deviceArray(level) X
    }
    if {[info exists ::deviceArray(eraseType)]} then {
	set ::deviceArray(eraseType) "full"
    }
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050B00EE"
    set rs232standard(readBootlVer) ":020000050F00EA"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    .deviceErase.f_erase.f_blocks.b_blockErase configure -state normal
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceIds $fReadOnly.f_deviceIds
    frame $fDeviceIds -relief flat
    set lDeviceIds $fDeviceIds.l_deviceIds
    label $lDeviceIds -text "Device Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceIds "Ids 1, 2, 3: read-only"
    set eDeviceId1 $fDeviceIds.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    set eDeviceId2 $fDeviceIds.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    set eDeviceId3 $fDeviceIds.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceIds $eDeviceId1 -side left
    pack config $eDeviceId2 -padx 2 -side left
    pack config $eDeviceId3 -side left
    pack config $fDeviceIds -side top -ipady 1 -fill both
    set fDeviceBootIds $fReadOnly.f_deviceBootIds
    frame $fDeviceBootIds -relief flat
    set lDeviceBootIds $fDeviceBootIds.l_deviceBootIds
    label $lDeviceBootIds -text "Device Boot Ids" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceBootIds "Boot Ids 1, 2: read-only"
    set eDeviceBootId1 $fDeviceBootIds.e_deviceBootId1
    entry $eDeviceBootId1 -textvariable ::deviceArray(deviceBootId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId1 "Boot Id 1 value"
    set eDeviceBootId2 $fDeviceBootIds.e_deviceBootId2
    entry $eDeviceBootId2 -textvariable ::deviceArray(deviceBootId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceBootId2 "Boot Id 2 value"
    pack config $lDeviceBootIds $eDeviceBootId1 -side left
    pack config $eDeviceBootId2 -padx 2 -side left
    pack config $fDeviceBootIds -side top -ipady 1 -fill both
    set fHSB $fReadOnly.f_hsb
    frame $fHSB -relief flat
    set lHSB $fHSB.l_hsb
    label $lHSB -text "HSB" -font $flipFont -anchor w -width 16
    setBalloon $lHSB "Hardware Security Byte: read-only"
    set eHSB $fHSB.e_hsb
    entry $eHSB -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHSB "Hardware Byte value"
    pack config $lHSB $eHSB -side left
    pack config $fHSB -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -fill both
    set fFuses .main.f_device.f_fuses
    frame $fFuses -relief groove -borderwidth 1
    set bBLJB $fFuses.b_bljb
    checkbutton $bBLJB -text "BLJB" -font $flipFont -variable ::deviceArray(bljbFuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bBLJB "BootLoader Jump Bit set : BLJB = 0"
    set bX2 $fFuses.b_x2
    checkbutton $bX2 -text "X2" -font $flipFont -variable ::deviceArray(x2Fuse) -onvalue 0 -offvalue 1 -indicatoron true -state disabled
    setBalloon $bX2 "X2 fuse bit \nSet = 0 / Unset = 1"
    pack config $bBLJB $bX2 -side left -anchor w
    pack configure $fFuses -side top -padx 5 -pady 1 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 1 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 5 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.23.1  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  checksum-5.5  checksum-5.6 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51rc2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t89c51rd2 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T89C51RD2"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable buffer
	variable deviceArray
	set deviceArray(memorySize) 63
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 0
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set expAnsw(readSSBlev0) [list FF]
    set expAnsw(readSSBlev0Test) "FF"
    set expAnsw(readSSBlev1) [list 10]
    set expAnsw(readSSBlev1Test) "10"
    set expAnsw(readSSBlev2) [list 00 XX]
    set expAnsw(readSSBlev2Test) "00"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) D7
    set expAnsw(readDevId2) FC
    set expAnsw(readDevId3) FF
    set testFlag(eraseBlock0) 0
    set testFlag(eraseBlock1) 0
    set testFlag(eraseBlock2) 0
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 0
    set testFlag(readDevBootId2) 0
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 0
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    setBalloon $bBlock3 "Erase memory between 8000 and BFFF"
    setBalloon $bBlock4 "Erase memory between C000 and FFFF"
    set ::deviceArray(manufId) "XX"
    set ::deviceArray(deviceId1) "XX"
    set ::deviceArray(deviceId2) "XX"
    set ::deviceArray(deviceId3) "XX"
    set ::deviceArray(hsb) "XX"
    set ::deviceArray(bootlVer) "XX"
    set ::deviceArray(sbv) "XX"
    set ::deviceArray(bsb) "XX"
    set ::deviceArray(ssb) "XX"
    set ::deviceArray(level) "X"
    set ::deviceArray(eraseType) "full"
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050703EF"
    set rs232standard(readBootlVer) ":020000050800F1"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fManufId $fReadOnly.f_manufId
    frame $fManufId -relief flat
    set lManufId $fManufId.l_manufId
    label $lManufId -text "Manufact. Id" -font $flipFont -anchor w -width 16
    setBalloon $lManufId "Manufacturer Id: read-only"
    set eManufId $fManufId.e_manufId
    entry $eManufId -textvariable ::deviceArray(manufId) -width 3 -font $flipFont -state disabled
    setBalloon $eManufId "Manufacturer Id value"
    pack config $lManufId $eManufId -side left
    pack config $fManufId -side top -ipady 1 -fill both
    set fDeviceId1 $fReadOnly.f_deviceId1
    frame $fDeviceId1 -relief flat
    set lDeviceId1 $fDeviceId1.l_deviceId1
    label $lDeviceId1 -text "Device Id 1" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceId1 "Id 1: read-only"
    set eDeviceId1 $fDeviceId1.e_deviceId1
    entry $eDeviceId1 -textvariable ::deviceArray(deviceId1) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId1 "Id 1 value"
    pack config $lDeviceId1 $eDeviceId1 -side left
    pack config $fDeviceId1 -side top -ipady 1 -fill both
    set fDeviceId2 $fReadOnly.f_deviceId2
    frame $fDeviceId2 -relief flat
    set lDeviceId2 $fDeviceId2.l_deviceId2
    label $lDeviceId2 -text "Device Id 2" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceId2 "Id 2: read-only"
    set eDeviceId2 $fDeviceId2.e_deviceId2
    entry $eDeviceId2 -textvariable ::deviceArray(deviceId2) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId2 "Id 2 value"
    pack config $lDeviceId2 $eDeviceId2 -side left
    pack config $fDeviceId2 -side top -ipady 1 -fill both
    set fDeviceId3 $fReadOnly.f_deviceId3
    frame $fDeviceId3 -relief flat
    set lDeviceId3 $fDeviceId3.l_deviceId3
    label $lDeviceId3 -text "Device Id 3" -font $flipFont -anchor w -width 16
    setBalloon $lDeviceId3 "Id 3: read-only"
    set eDeviceId3 $fDeviceId3.e_deviceId3
    entry $eDeviceId3 -textvariable ::deviceArray(deviceId3) -width 3 -font $flipFont -state disabled
    setBalloon $eDeviceId3 "Id 3 value"
    pack config $lDeviceId3 $eDeviceId3 -side left
    pack config $fDeviceId3 -side top -ipady 1 -fill both
    set fHwByte $fReadOnly.f_hwByte
    frame $fHwByte -relief flat
    set lHwByte $fHwByte.l_hwByte
    label $lHwByte -text "Hardware Byte" -font $flipFont -anchor w -width 16
    setBalloon $lHwByte "Hardware Security Byte: read-only"
    set eHwByte $fHwByte.e_hwByte
    entry $eHwByte -textvariable ::deviceArray(hsb) -width 3 -font $flipFont -state disabled
    setBalloon $eHwByte "Hardware Byte value"
    pack config $lHwByte $eHwByte -side left
    pack config $fHwByte -side top -ipady 1 -fill both
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 1 -fill both
    pack configure $fReadOnly -side top -padx 5 -pady 5 -fill both
    set f_BSB_SBV .main.f_device.f_bsb_sbv
    frame $f_BSB_SBV -relief groove -borderwidth 1
    set f_BSB $f_BSB_SBV.f_bsb
    frame $f_BSB -relief flat
    set l_BSB $f_BSB.l_bsb
    label $l_BSB -text "Device BSB" -font $flipFont -anchor w -width 16
    setBalloon $l_BSB "Boot Status Byte"
    set e_BSB $f_BSB.e_bsb
    entry $e_BSB -textvariable ::deviceArray(bsb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_BSB "Actual BSB value"
    pack config $l_BSB $e_BSB -side left
    pack config $f_BSB -side top -ipady 1 -fill both
    set f_SBV $f_BSB_SBV.f_sbv
    frame $f_SBV -relief flat
    set l_SBV $f_SBV.l_sbv
    label $l_SBV -text "Device SBV" -font $flipFont -anchor w -width 16
    setBalloon $l_SBV "Software Boot Vector"
    set e_SBV $f_SBV.e_sbv
    entry $e_SBV -textvariable ::deviceArray(sbv) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $e_SBV "Actual SBV value"
    if {0} then {
	set bErase $fSBV.b_erase
	button $bErase -bd 3 -text "Erase" -font $flipFont -command {cmdsEraseSBVBSB} -state disabled -width 5
	setBalloon $bErase "Resets SBV and BSB\nto default values"
    }
    pack config $l_SBV $e_SBV -side left
    pack config $f_SBV -side top -ipady 1 -fill both
    pack configure $f_BSB_SBV -side top -padx 5 -fill both
    bind $e_SBV <Return> {devcSetDeviceSpecialBytes}
    bind $e_BSB <Return> {devcSetDeviceSpecialBytes}
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 1 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    pack config $bUpdate $bWrite -side left -padx 10
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 35 -pady 10 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.20  flash-2.21  flash-2.22  flash-2.23  flash-2.23.1  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  specific-4.2  specific-4.3  specific-4.11  specific-4.12  checksum-5.2  checksum-5.3  checksum-5.4  checksum-5.5  checksum-5.6  checksum-5.13  checksum-5.14  checksum-5.15  checksum-5.28  checksum-5.29 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL {}
    return $skipL
}
t89c51rd2
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global projDir
source $projDir/tcl/devices/devices_common.tcl
proc t8xc5121 {} {
    #dbgBeginProc [info level [info level]]
    global protcl protocol nAddrBits rs232standard canstandard expAnsw testFlag buffer flowButtons flipFont
    set children_List [split [winfo children .main.f_device]]
    foreach item $children_List {
	if {$item != ".main.f_device.f_deviceName"} then {
	    destroy $item
	}
    }
    if {[array exists ::deviceArray]} then {
	array unset ::deviceArray
    }
    set ::deviceArray(name) "T8XC5121"
    set ::deviceArray(communicationList) "RS232"
    set ::deviceArray(memoryList) [list FLASH]
    set ::deviceArray(memoryColor) [list "#88a67d" "wheat"]
    set ::deviceArray(currentMemory) "FLASH"
    namespace eval ::FLASH:: {
	variable deviceArray
	variable buffer
	set deviceArray(memorySize) 16
	set deviceArray(cramSize) 16
	set deviceArray(blankValue) "FF"
	set buffer(erase) "normal"
	set buffer(blankCheck) "normal"
	set buffer(eraseType) "full"
	set buffer(erasePossibleBlocks) "disabled"
	set buffer(erasePossibleBlock0) "disabled"
	set buffer(eraseBlock0) 0
	set buffer(erasePossibleBlock1) "disabled"
	set buffer(eraseBlock1) 0
	set buffer(erasePossibleBlock2) "disabled"
	set buffer(eraseBlock2) 0
	set buffer(erasePossibleBlock3) "disabled"
	set buffer(eraseBlock3) 0
	set buffer(erasePossibleBlock4) "disabled"
	set buffer(eraseBlock4) 0
	set deviceArray(progStart) "00"
	set deviceArray(displayData) "00"
	set deviceArray(blankCheck) "01"
	set deviceArray(programData) "00"
	namespace export writeBuffer readBuffer readDeviceArray initBuffer bufferChecksum
    }
    foreach M $::deviceArray(memoryList) {
	proc ::${M}::writeBuffer {index data} {
	    variable buffer
	    set buffer($index) $data
	    return
	}
	proc ::${M}::readBuffer {index} {
	    variable buffer
	    return $buffer($index)
	}
	proc ::${M}::readDeviceArray {index} {
	    variable deviceArray
	    return $deviceArray($index)
	}
	proc ::${M}::initBuffer {} {
	    variable deviceArray
	    variable buffer
	    global flipStates
	    set max [expr $deviceArray(memorySize) * 1024]
	    if {$flipStates(simul)} then {
		for {set i 0} {$i < $max} {incr i} {
		    set buffer([format %06X $i]) $deviceArray(blankValue)
		}
	    } else {
		initBuffer_C $max $deviceArray(blankValue)
	    }
	    return
	}
	proc ::${M}::bufferChecksum {} {
	    variable buffer
	    global flipStates
	    set min $buffer(minProgAddr)
	    set max $buffer(maxProgAddr)
	    if {$flipStates(simul)} then {
		return 0xCAFEFADE
	    } else {
		return [computeBufferChecksum_C $min $max]
	    }
	}
    }
    set ::deviceArray(specialSynchro) 1
    set ::deviceArray(RS232ProtocolsList) "Standard Enhanced"
    set protocol(frameLengthW) 64
    set protocol(frameLengthR) 64
    set expAnsw(readSSBlev0) [list FF BF 7F 3F]
    set expAnsw(readSSBlev0Test) "0F"
    set expAnsw(readSSBlev1) [list FE BE 7E 3E]
    set expAnsw(readSSBlev1Test) "0E"
    set expAnsw(readSSBlev2) [list FC BC 7C 3C XX]
    set expAnsw(readSSBlev2Test) "0C"
    set expAnsw(readManufId) 58
    set expAnsw(readDevId1) D7
    set expAnsw(readDevId2) FC
    set expAnsw(readDevId3) FF
    set testFlag(eraseBlock0) 0
    set testFlag(eraseBlock1) 0
    set testFlag(eraseBlock2) 0
    set testFlag(eraseBlock3) 0
    set testFlag(eraseBlock4) 0
    set testFlag(readDevBootId1) 0
    set testFlag(readDevBootId2) 0
    set testFlag(sbv) "FC"
    set ::tcltest::testConstraints(eraseBlockPossible) 0
    .main.f_device.f_deviceName.l_device configure -text $::deviceArray(name)
    .main.f_device.f_deviceName configure -relief groove
    set fBlocks .deviceErase.f_erase.f_blocks
    set bBlock0 $fBlocks.b_block0
    set bBlock1 $fBlocks.b_block1
    set bBlock2 $fBlocks.b_block2
    set bBlock3 $fBlocks.b_block3
    set bBlock4 $fBlocks.b_block4
    setBalloon $bBlock0 "Erase memory between 0000 and 1FFF"
    setBalloon $bBlock1 "Erase memory between 2000 and 3FFF"
    setBalloon $bBlock2 "Erase memory between 4000 and 7FFF"
    setBalloon $bBlock3 "Erase memory between 8000 and BFFF"
    setBalloon $bBlock4 "Erase memory between C000 and FFFF"
    catch [set ::deviceArray(bootlVer) "XX"]
    catch [set ::deviceArray(ssb) "XX"]
    catch [set ::deviceArray(level) "X"]
    catch [set ::deviceArray(eraseType) "full"]
    catch [set ::deviceArray(crc) "XXXX"]
    set nAddrBits 4
    set rs232standard(readHwByte) ":020000050703EF"
    set rs232standard(readBootlVer) ":020000050800F1"
    set ::deviceArray(flowErase) 0
    set ::deviceArray(flowBlankCheck) 0
    set ::deviceArray(flowProgram) 0
    set ::deviceArray(flowVerify) 0
    set ::deviceArray(flowSpecialBytes) 0
    wm title .deviceErase "$::deviceArray(name) Erase"
    set fReadOnly .main.f_device.f_readOnly
    frame $fReadOnly -relief groove -borderwidth 1
    set fBootlVer $fReadOnly.f_bootlVer
    frame $fBootlVer -relief flat
    set lBootlVer $fBootlVer.l_bootlVer
    label $lBootlVer -text "Bootloader Ver." -font $flipFont -anchor w -width 16
    setBalloon $lBootlVer "Bootloader Version: read-only"
    set eBootlVer $fBootlVer.e_bootlVer
    entry $eBootlVer -textvariable ::deviceArray(bootlVer) -width 5 -font $flipFont -state disabled
    setBalloon $eBootlVer "Bootloader Version"
    pack config $lBootlVer $eBootlVer -side left
    pack config $fBootlVer -side top -ipady 5 -fill both
    pack configure $fReadOnly -side top -padx 5 -pady 5 -fill both
    set fBypass .main.f_device.f_bypass
    frame $fBypass -relief groove -bd 1
    set lBypass $fBypass.l_bypass
    label $lBypass -text "Bypass Bits" -font $flipFont
    set cbBypassUart $fBypass.cb_bypassUart
    checkbutton $cbBypassUart -text "UART" -font $flipFont -variable ::deviceArray(bypassUART) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    setBalloon $cbBypassUart "UART bypassed when ON"
    set cbBypassI2c $fBypass.cb_bypassI2c
    checkbutton $cbBypassI2c -text "I2C" -font $flipFont -variable ::deviceArray(bypassI2C) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    setBalloon $cbBypassI2c "I2C bypassed when ON"
    pack configure $lBypass $cbBypassUart $cbBypassI2c -side top -anchor w
    pack configure $fBypass -side top -padx 5 -pady 5 -ipady 5 -fill both
    set fSSB .main.f_device.f_ssb
    frame $fSSB -relief groove -borderwidth 1
    set fInfo $fSSB.f_info
    frame $fInfo -relief flat
    set lSSB $fInfo.l_ssb
    label $lSSB -text "Device SSB" -font $flipFont -anchor w -width 16
    setBalloon $lSSB "Software Security Byte"
    set eSSB $fInfo.e_ssb
    entry $eSSB -textvariable ::deviceArray(ssb) -width 3 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eSSB "Actual SSB value"
    pack config $lSSB $eSSB -side left
    pack config $fInfo -side top
    set fLevel0 $fSSB.f_level0
    frame $fLevel0 -relief flat
    set bLevel0 $fLevel0.b_level0
    radiobutton $bLevel0 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 0" -value 0 -font $flipFont -text "Level 0" -state disabled
    setBalloon $bLevel0 "Security level 0: no security\n (setting to levels 1 and 2 allowed)"
    pack configure $bLevel0 -side left
    set fLevel1 $fSSB.f_level1
    frame $fLevel1 -relief flat
    set bLevel1 $fLevel1.b_level1
    radiobutton $bLevel1 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 1" -value 1 -font $flipFont -text "Level 1" -state disabled
    setBalloon $bLevel1 "Security level 1: no writing allowed\n (setting to level 2 allowed)"
    pack configure $bLevel1 -side left
    set fLevel2 $fSSB.f_level2
    frame $fLevel2 -relief flat
    set bLevel2 $fLevel2.b_level2
    radiobutton $bLevel2 -indicatoron 1 -variable ::deviceArray(level) -command "set ::deviceArray(level) 2" -value 2 -font $flipFont -text "Level 2" -state disabled
    setBalloon $bLevel2 "Security level 2: no reading/writing allowed\n (full chip erase resets security level to 0)"
    pack configure $bLevel2 -side left
    pack configure $fInfo -side top -anchor w -ipady 5 -fill both
    pack configure $fInfo $fLevel0 $fLevel1 $fLevel2 -side top -anchor w -fill both
    pack configure $fSSB -side top -padx 5 -pady 5 -fill both
    set fCRC .main.f_device.f_crc
    frame $fCRC -relief groove -bd 1
    set bCRC $fCRC.b_crc
    button $bCRC -bd 3 -text "CRC" -font $flipFont -command {storeAndDisplayCRC [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]} -state disabled
    setBalloon $bCRC "Launches a CRC calculation"
    set eCRC $fCRC.e_crc
    entry $eCRC -textvariable ::deviceArray(crc) -width 5 -font $flipFont -takefocus 0 -state disabled
    setBalloon $eCRC "CRC actual value"
    pack configure $bCRC $eCRC -side left -padx 10
    pack configure $fCRC -side top -padx 5 -pady 5 -ipady 5 -fill both
    set fButtons .main.f_device.f_buttons
    frame $fButtons -relief flat
    set bUpdate $fButtons.b_update
    button $bUpdate -bd 3 -text "Read" -font $flipFont -command {devcUpdateDeviceFrame} -state disabled
    setBalloon $bUpdate "Reads device special bytes"
    set bWrite $fButtons.b_write
    button $bWrite -bd 3 -text "Set" -font $flipFont -command {devcSetDeviceSpecialBytes} -state disabled
    setBalloon $bWrite "Sets device special bytes"
    set bExec $fButtons.b_exec
    button $bExec -bd 3 -text "Start Application" -font $flipFont -command {ptclStartAppli 0} -state disabled
    setBalloon $bExec "Starts application at address 0x0000"
    pack config $bUpdate $bWrite $bExec -side left -padx 5
    catch [destroy .main.f_buffer.b_memSelect]
    pack configure $fButtons -side top -padx 10 -pady 10 -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipTestList {protocol} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(skipList) "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28  flash-2.20  flash-2.21  flash-2.22  flash-2.23  flash-2.23.1  flash-2.24  flash-2.25  flash-2.26  flash-2.27  flash-2.28  flash-2.29  flash-2.30  specific-4.2  specific-4.3  specific-4.11  specific-4.12  checksum-5.2  checksum-5.3  checksum-5.4  checksum-5.5  checksum-5.6  checksum-5.13  checksum-5.14  checksum-5.15  checksum-5.28  checksum-5.29 "
    #dbgEndProc [info level [info level]]
    return
}
proc buildSkipProcList {} {
    set skipL [list ptclReadManufId ptclReadDeviceId1 ptclReadDeviceId2 ptclReadDeviceId3 ptclReadHwByte ptclReadDevBootId1 ptclReadDevBootId2 ptclReadSBV ptclReadBSB ptclReadSSB ptclReadEB ptclReadBTC1 ptclReadBTC2 ptclReadBTC3 ptclReadNNB ptclReadCRIS ptclReadPortsConfig]
    return $skipL
}
t8xc5121
foreach m $::deviceArray(memoryList) {
    cmdsImportCurrentMemoryNameSpace $m
    cmdsSetMemoryParameters
    initBuffer
}
cmdsImportCurrentMemoryNameSpace FLASH
#dbgEndSrc [info script]    #dbgBeginSrc [info script]
proc checkSecurityLevel {} {
    #dbgBeginProc [info level [info level]]
    global expAnsw flipStates
    set status 0
    foreach i $expAnsw(readSSBlev0) {
	if {$::deviceArray(ssb) == $i} then {
	    set ::deviceArray(level) 0
	    set status 1
	}
    }
    foreach i $expAnsw(readSSBlev1) {
	if {$::deviceArray(ssb) == $i} then {
	    set ::deviceArray(level) 1
	    set status 1
	}
    }
    foreach i $expAnsw(readSSBlev2) {
	if {$::deviceArray(ssb) == $i} then {
	    set ::deviceArray(level) 2
	    set status 1
	}
    }
    if {! $flipStates(simul)} then {
	if {$status == 0} then {
	    set message "The SSB value is not valid."
	    messageBox "Device Information" error $message
	}
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc devcUpdateDeviceFrame {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    focus .
    set failed "Failed reading special bytes."
    set status 1
    set L [list ptclReadSSB ptclReadManufId ptclReadDeviceId1 ptclReadDeviceId2 ptclReadDeviceId3 ptclReadHwByte ptclReadDevBootId1 ptclReadDevBootId2 ptclReadBootlVer updateBypassBitsDisplay ptclReadSBV ptclReadBSB ptclReadEB ptclReadBTC1 ptclReadBTC2 ptclReadBTC3 ptclReadNNB ptclReadCRIS ptclReadPortsConfig]
    #dbgShowInfo "Building the skip list..."
    set skipL [buildSkipProcList]
    foreach i $skipL {
	set index [lsearch $L $i]
	set L [lreplace $L $index $index ""]
    }
    #dbgShowVar "Executed procs list = $L"
    foreach i $L {
	if {$i != ""} then {
	    if {[info procs $i] == $i} then {
		if {! [$i]} then {
		    break
		} else {
		    update idletasks
		}
	    }
	}
    }
    if {[info exists ::deviceArray(deviceBootId1)] && [info exists ::deviceArray(deviceBootId2)]} then {
	set ::deviceArray(bootloaderId) ${::deviceArray(deviceBootId2)}${::deviceArray(deviceBootId1)}
    }
    set ::tcltest::testConstraints(bootloaderId_0001_Only) [string equal $::deviceArray(bootloaderId) "0001"]
    set ::tcltest::testConstraints(bootloaderId_0002_Only) [string equal $::deviceArray(bootloaderId) "0002"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc devcSetDeviceSpecialBytes {} {
    #dbgBeginProc [info level [info level]]
    global protcl loadConfig expAnsw
    set status 1
    while {1} {
	if {[info exists ::deviceArray(sbv)]} then {
	    if {![isValidHexaInput $::deviceArray(sbv)]} then {
		set status 0
		break
	    }
	    if {"0x$::deviceArray(sbv)" > 0xFF} then {
		set message "The address is out of range."
		messageBox "Entry Check" warning $message
		set status 0
		break
	    }
	    set ::deviceArray(sbv) [format %02X 0x$::deviceArray(sbv)]
	}
	if {[info exists ::deviceArray(bsb)]} then {
	    if {![isValidHexaInput $::deviceArray(bsb)]} then {
		set status 0
		break
	    }
	    if {"0x$::deviceArray(bsb)" > 0xFF} then {
		set message "The address is out of range."
		messageBox "Entry Check" warning $message
		set status 0
		break
	    }
	    set ::deviceArray(bsb) [format %02X 0x$::deviceArray(bsb)]
	}
	if {([info exists eEB]) &&([winfo exists $eEB])} then {
	    if {[info exists ::deviceArray(eb)]} then {
		if {![isValidHexaInput $::deviceArray(eb)]} then {
		    set status 0
		    break
		}
		if {"0x$::deviceArray(eb)" > 0xFF} then {
		    set message "The address is out of range."
		    messageBox "Entry Check" warning $message
		    set status 0
		    break
		}
		set ::deviceArray(eb) [format %02X 0x$::deviceArray(eb)]
	    }
	}
	focus .
	set status 1
	if {([info exist ::deviceArray(ssb)]) &&([lsearch -exact [subst $expAnsw(readSSBlev0)] $::deviceArray(ssb)] != -1)} then {
	    #dbgShowInfo "Security level = 0 => Special bytes changes are possible."
	    if {[info exists ::deviceArray(sbv)]} then {
		set status [ptclWriteSBV $::deviceArray(sbv)]
		set loadConfig(setSbv) "setupSBV $::deviceArray(sbv)"
		if {$status} then {
		    set p ptclReadSBV
		    if {[info procs $p] == $p} then {
			$p
		    }
		}
	    }
	    if {$status} then {
		if {[info exists ::deviceArray(bsb)]} then {
		    set status [ptclWriteBSB $::deviceArray(bsb)]
		    set loadConfig(setBsb) "setupBSB $::deviceArray(bsb)"
		    if {$status} then {
			set p ptclReadBSB
			if {[info procs $p] == $p} then {
			    $p
			}
		    }
		}
	    }
	    if {($status) &&([info procs ptclWriteEB] == "ptclWriteEB")} then {
		if {[info exists ::deviceArray(eb)]} then {
		    set status [ptclWriteEB $::deviceArray(eb)]
		    set loadConfig(setEB) "setupEB $::deviceArray(eb)"
		    if {$status} then {
			set p ptclReadEB
			if {[info procs $p] == $p} then {
			    $p
			}
		    }
		}
	    }
	    if {$status} then {
		if {[info exists ::deviceArray(oscFuse)]} then {
		    set p ptclWriteOscFuse
		    if {[info procs $p] == $p} then {
			set status [$p 0$::deviceArray(oscFuse)]
			set loadConfig(setOscFuse) "setupOscFuse $::deviceArray(oscFuse)"
		    }
		}
	    }
	    if {$status} then {
		if {[info exists ::deviceArray(bljbFuse)]} then {
		    set p ptclWriteBLJBFuse
		    if {[info procs $p] == $p} then {
			set status [$p 0$::deviceArray(bljbFuse)]
			set loadConfig(setBljbFuse) "setupBljbFuse $::deviceArray(bljbFuse)"
		    }
		}
	    }
	    if {$status} then {
		if {[info exists ::deviceArray(x2Fuse)]} then {
		    set p ptclWriteX2Fuse
		    if {[info procs $p] == $p} then {
			set status [$p 0$::deviceArray(x2Fuse)]
			set loadConfig(setX2Fuse) "setupX2Fuse $::deviceArray(x2Fuse)"
		    }
		}
	    }
	    if {$status} then {
		if {[info exists ::deviceArray(x2Fuse)] && [info exists ::deviceArray(bljbFuse)]} then {
		    set p ptclWriteHwByte
		    if {[info procs $p] == $p} then {
			set status [$p]
		    }
		}
	    }
	    if {$status} then {
		set p ptclReadHwByte
		if {[info procs $p] == $p} then {
		    $p
		}
	    }
	}
	if {$status} then {
	    #dbgShowInfo "Status = 1"
	    if {$::deviceArray(level) == 0} then {
		set p ptclReadSSB
		if {[info procs $p] == $p} then {
		    $p
		    if {[info procs "storeSSBinBuffer"] == "storeSSBinBuffer"} then {
			storeSSBinBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
			storeAndDisplayCRC [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
		    }
		}
	    } elseif {$::deviceArray(level) == 1} {
		set status [ptclProgSSBlev1]
		set loadConfig(setSsb) "setupSecurityLevel 1"
		if {$status} then {
		    set p ptclReadSSB
		    if {[info procs $p] == $p} then {
			$p
			if {[info procs "storeSSBinBuffer"] == "storeSSBinBuffer"} then {
			    storeSSBinBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
			    storeAndDisplayCRC [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
			}
		    }
		}
	    } elseif {$::deviceArray(level) == 2} {
		set status [ptclProgSSBlev2]
		set loadConfig(setSsb) "setupSecurityLevel 2"
		if {$status} then {
		    set p ptclReadSSB
		    if {[info procs $p] == $p} then {
			$p
			if {[info procs "storeSSBinBuffer"] == "storeSSBinBuffer"} then {
			    storeSSBinBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
			    storeAndDisplayCRC [format %06X [expr [readDeviceArray memorySize] * 1024 - 3]]
			}
		    }
		}
	    } else {
		set message "The device security level value is not correct."
		messageBox "Device Information" error $message
		set status 0
		break
	    }
	    if {[info exists ::deviceArray(bypassUART)]} then {
		#dbgShowInfo "bypassUART exists"
		if {$::deviceArray(bypassUART) && $::deviceArray(bypassI2C)} then {
		    set bypass "both"
		    set status [ptclProgBypass $bypass]
		} elseif {$::deviceArray(bypassUART)} {
		    set bypass "uart"
		    set status [ptclProgBypass $bypass]
		} elseif {$::deviceArray(bypassI2C)} {
		    set bypass "i2c"
		    set status [ptclProgBypass $bypass]
		} else {
		    set bypass "none"
		    set status [ptclProgBypass $bypass]
		}
		set p ptclReadSSB
		if {[info procs $p] == $p} then {
		    $p
		}
	    }
	}
	if {$status} then {
	    log_message "Special Bytes successfully written"
	    actionsLog_message "Special Bytes successfully written"
	}
	break
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc restoreSSB {ssb} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    if {[checkSecurityLevel] == 0} then {
	return 0
    }
    if {[winfo exists .main.f_device.f_bsb_sbv.f_sbv.e_sbv]} then {
	set eSBV .main.f_device.f_bsb_sbv.f_sbv.e_sbv
    }
    if {[winfo exists .main.f_device.f_bsb_sbv.f_bsb.e_bsb]} then {
	set eBSB .main.f_device.f_bsb_sbv.f_bsb.e_bsb
    }
    if {[winfo exists .main.f_device.f_bsb_sbv.f_bsb.e_eb]} then {
	set eEB .main.f_device.f_bsb_sbv.f_bsb.e_eb
    }
    if {[winfo exists .main.f_device.f_sbvbsb.f_bsb.b_erase]} then {
	set bErase .main.f_device.f_sbvbsb.f_bsb.b_erase
    }
    foreach i {0 1 2} {
	set wdgt .main.f_device.f_ssb.f_level$i.b_level$i
	if {[winfo exists $wdgt]} then {
	    set bLevel$i $wdgt
	}
    }
    foreach i {0 1 2} {
	set wdgt .main.f_device.f_ssb.f_level.b_level$i
	if {[winfo exists $wdgt]} then {
	    set bLevel$i $wdgt
	}
    }
    if {[winfo exists .main.f_device.f_buttons.b_update]} then {
	set bUpdate .main.f_device.f_buttons.b_update
    }
    if {[winfo exists .main.f_device.f_buttons.b_write]} then {
	set bWrite .main.f_device.f_buttons.b_write
    }
    if {[winfo exists .main.f_device.f_fuses]} then {
	if {[winfo exists .main.f_device.f_fuses.b_osc]} then {
	    set bOsc .main.f_device.f_fuses.b_osc
	}
	if {[winfo exists .main.f_device.f_fuses.b_bljb]} then {
	    set bBLJB .main.f_device.f_fuses.b_bljb
	}
	if {[winfo exists .main.f_device.f_fuses.b_x2]} then {
	    set bX2 .main.f_device.f_fuses.b_x2
	}
    }
    set buttonList [list]
    if {[info exists bErase]} then {
	lappend buttonList $bErase
    }
    if {[info exists bLevel0]} then {
	lappend buttonList $bLevel0
    }
    if {[info exists bLevel1]} then {
	lappend buttonList $bLevel1
    }
    if {[info exists bLevel2]} then {
	lappend buttonList $bLevel2
    }
    if {[info exists bUpdate]} then {
	lappend buttonList $bUpdate
    }
    if {[info exists bWrite]} then {
	lappend buttonList $bWrite
    }
    set entryList [list]
    if {[info exists eSBV]} then {
	lappend entryList $eSBV
    }
    if {[info exists eBSB]} then {
	lappend entryList $eBSB
    }
    if {[info exists eEB]} then {
	lappend entryList $eEB
    }
    set fuseList [list]
    if {[info exists bOsc]} then {
	lappend fuseList $bOsc
    }
    if {[info exists bBLJB]} then {
	lappend fuseList $bBLJB
    }
    if {[info exists bX2]} then {
	lappend fuseList $bX2
    }
    if {$::deviceArray(level) == 0} then {
	foreach entry $entryList {
	    if {[winfo exists $entry]} then {
		$entry configure -takefocus 1 -state normal
	    }
	}
	foreach button $buttonList {
	    if {[winfo exists $button]} then {
		$button configure -state normal
	    }
	}
	foreach fuse $fuseList {
	    if {[winfo exists $fuse]} then {
		$fuse configure -state normal
	    }
	}
    } elseif {$::deviceArray(level) == 1} {
	if {([info exists eSBV]) &&([winfo exists $eSBV])} then {
	    $eSBV configure -takefocus 0 -state disabled
	}
	if {([info exists eBSB]) &&([winfo exists $eBSB])} then {
	    $eBSB configure -takefocus 0 -state disabled
	}
	if {([info exists eHSB]) &&([winfo exists $eHSB])} then {
	    $eHSB configure -takefocus 0 -state disabled
	}
	if {([info exists eEB]) &&([winfo exists $eEB])} then {
	    $eEB configure -takefocus 0 -state disabled
	}
	if {([info exists bErase]) &&([winfo exists $bErase])} then {
	    $bErase configure -state disabled
	}
	if {([info exists bLevel0]) &&([winfo exists $bLevel0])} then {
	    $bLevel0 configure -state disabled
	}
	if {([info exists bLevel1]) &&([winfo exists $bLevel1])} then {
	    $bLevel1 configure -state normal
	}
	if {([info exists bLevel2]) &&([winfo exists $bLevel2])} then {
	    $bLevel2 configure -state normal
	}
	if {([info exists bUpdate]) &&([winfo exists $bUpdate])} then {
	    $bUpdate configure -state normal
	}
	if {([info exists bWrite]) &&([winfo exists $bWrite])} then {
	    $bWrite configure -state normal
	}
	foreach fuse $fuseList {
	    if {[winfo exists $fuse]} then {
		$fuse configure -state disabled
	    }
	}
    } elseif {$::deviceArray(level) == 2} {
	foreach entry $entryList {
	    if {[winfo exists $entry]} then {
		$entry configure -takefocus 0 -state disabled
	    }
	}
	foreach button $buttonList {
	    if {[winfo exists $button]} then {
		$button configure -state disabled
	    }
	}
	foreach fuse $fuseList {
	    if {[winfo exists $fuse]} then {
		$fuse configure -state disabled
	    }
	}
	if {[winfo exists $bLevel2]} then {
	    $bLevel2 configure -state normal
	}
    } else {
	set message "Invalid security level value."
	messageBox "Device Information" error $message
	return 0
    }
    if {$::deviceArray(ssb) == "XX"} then {
	set ::deviceArray(level) X
	if {[winfo exists $bLevel2]} then {
	    $bLevel2 configure -state disabled
	}
    }
    if {([info exists flipStates(rs232Comm)]) &&([info exists eEB])} then {
	if {$flipStates(rs232Comm) == "on"} then {
	    $eEB configure -state disabled
	}
    }
    #dbgEndProc [info level [info level]]
    update
    return
}
proc flowButtonsList {} {
    #dbgBeginProc [info level [info level]]
    global flowButtons
    set buttonsList [list]
    if {[info exists $flowButtons(bErase)]} then {
	lappend buttonsList $flowButtons(bErase)
    }
    if {[info exists $flowButtons(bBlankCheck)]} then {
	lappend buttonsList $flowButtons(bBlankCheck)
    }
    if {[info exists $flowButtons(bProgram)]} then {
	lappend buttonsList $flowButtons(bProgram)
    }
    if {[info exists $flowButtons(bVerify)]} then {
	lappend buttonsList $flowButtons(bVerify)
    }
    if {[info exists $flowButtons(bSpecialBytes)]} then {
	lappend buttonsList $flowButtons(bSpecialBytes)
    }
    #dbgEndProc [info level [info level]]
    return $buttonsList
}
proc setBootlVerDepFeatures {ptcl minorPatch} {
    #dbgBeginProc [info level [info level]]
    global bootloaderVerDependent protocol
    if {$ptcl == "RS232_STANDARD"} then {
	set p "bootlVer"
	if {($::deviceArray(name) == "T89C51CC01") ||($::deviceArray(name) == "T89C51CC02")} then {
	    set MINORPATCH 0x12
	    if {[expr 0x$minorPatch <= $MINORPATCH]} then {
		#dbgShowInfo "Device is CC01 or CC02 and blVersion <= 12"
		set bootloaderVerDependent(eeprom) 0
		set bootloaderVerDependent(eb) 0
		set bootloaderVerDependent(startAppli) 0
		set protocol(frameLengthW) 16
		set protocol(frameLengthR) 16
	    } else {
		#dbgShowInfo "Device is CC01 or CC02 and blVersion > 12"
		set bootloaderVerDependent(eeprom) 1
		set bootloaderVerDependent(eb) 1
		set bootloaderVerDependent(startAppli) 1
		set protocol(frameLengthW) 128
		set protocol(frameLengthR) 16
	    }
	}
	if {$::deviceArray(name) == "T89C51AC2"} then {
	    if {[expr 0x$minorPatch <= 0x12]} then {
		set bootloaderVerDependent(eeprom) 0
		set bootloaderVerDependent(eb) 0
		set bootloaderVerDependent(startAppli) 0
		set protocol(frameLengthW) 16
		set protocol(frameLengthR) 16
	    } elseif {([expr 0x$minorPatch > 0x12]) &&([expr 0x$minorPatch <= 0x40])} {
		set bootloaderVerDependent(eeprom) 1
		set bootloaderVerDependent(eb) 1
		set bootloaderVerDependent(startAppli) 1
		set protocol(frameLengthW) 128
		set protocol(frameLengthR) 16
		set ::deviceArray(memoryList) [list FLASH EEPROM]
	    } elseif {[expr 0x$minorPatch > 0x40]} {
		set bootloaderVerDependent(eeprom) 1
		set bootloaderVerDependent(eb) 1
		set bootloaderVerDependent(startAppli) 1
		set protocol(frameLengthW) 128
		set protocol(frameLengthR) 16
		set ::deviceArray(memoryList) [list FLASH EEPROM CUSTOM]
	    }
	}
	if {($::deviceArray(name) == "T89C51RC2") ||($::deviceArray(name) == "T89C51RB2") ||($::deviceArray(name) == "T89C51IC2") ||($::deviceArray(name) == "AT89C51RC2") ||($::deviceArray(name) == "AT89C51RB2") ||($::deviceArray(name) == "AT89C51IC2")} then {
	    set MINORPATCH 0x11
	    if {[expr 0x$minorPatch > $MINORPATCH]} then {
		set protocol(frameLengthW) 128
	    } else {
		set protocol(frameLengthW) 16
	    }
	}
	if {! [info exists bootloaderVerDependent(p1p3p4_config)]} then {
	    set bootloaderVerDependent(p1p3p4_config) 0
	}
	if {$::deviceArray(name) == "T89C51CC02"} then {
	    if {[expr 0x$minorPatch <= 0x11]} then {
		set bootloaderVerDependent(p1p3p4_config) 0
	    } else {
		set bootloaderVerDependent(p1p3p4_config) 1
	    }
	}
	set c1 [string index $minorPatch end-1]
	set c2 [string index $minorPatch end]
	if {($::deviceArray(name) == "T89C51RD2")} then {
	    set ::deviceArray($p) "$c1.$c2"
	    set bootloaderVerDependent(eb) 0
	} else {
	    set ::deviceArray($p) "1.$c1.$c2"
	}
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } elseif {$ptcl == "CAN"} {
	if {$::deviceArray(name) == "T89C51CC02"} then {
	    set bootloaderVerDependent(p1p3p4_config) 1
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc storeAndDisplayCRC {loc} {
    set ::deviceArray(crc) [storeCRCinBuffer $loc]
    return
}
proc storeCRCinBuffer {loc} {
    #dbgBeginProc [info level [info level]]
    global temp buffer
    cmdsImportCurrentMemoryNameSpace [lindex $::deviceArray(memoryList) 0]
    set crc [computeWholeBufferCRC_C $loc [format %06X [expr 0X$loc + 1]] [format %06X [expr 0X$loc + 2]]]
    set crc [expr $crc & 0XFFFF]
    set crcHex [format %04X $crc]
    #dbgShowVar "crcHex = $crcHex"
    set addr1 [format %06X [expr [readDeviceArray memorySize] * 1024 - 2]]
    set data1 [string range $crcHex 2 3]
    #dbgShowInfo "Writing $data1 to $addr1"
    writeBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 2]] [string range $crcHex 2 3]
    set addr2 [format %06X [expr [readDeviceArray memorySize] * 1024 - 1]]
    set data2 [string range $crcHex 0 1]
    #dbgShowInfo "Writing $data2 to $addr2"
    writeBuffer [format %06X [expr [readDeviceArray memorySize] * 1024 - 1]] [string range $crcHex 0 1]
    updateBufferWidget 0.0
    update idletasks
    #dbgEndProc [info level [info level]]
    return ${data2}${data1}
}
proc readBootloaderCrcCheck {} {
    #dbgBeginProc [info level [info level]]
    global buffer waitTime
    #dbgShowVar "RxBuffer = $::sio::sioVars(RxBuffer)"
    set crcCheck [string index $::sio::sioVars(RxBuffer) end-2]
    #dbgShowVar "crcCheck = $crcCheck"
    set status 1
    if {$crcCheck == "Z"} then {
	log_message "Bootloader CRC check FAIL."
	set message "CRC error."
	messageBox "Bootloader CRC test" error $message
	set status 0
    } elseif {$crcCheck == "Y"} {
	log_message "Bootloader CRC check PASS."
    } else {
	log_message "No CRC check status received."
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
#dbgEndSrc [info script]
global libDir projDir tclTestDir deviceFilesList version flipStates working_active tcl_platform exeDir
set DISK H:
set tclTestDir $DISK/tcl/lib/tcl8.3/tcltest1.0
#set DISK /mnt/win_data
#set tclTestDir /usr/lib/tcl8.3/tcltest1.0
set exeDir [file dirname [info script]]
set libDir $DISK/labo/dev/lib/common/tcl
set projDir $DISK/labo/dev/app/flip_dev
set version "1.8.9"
source $libDir/dbglog.tcl
source $libDir/sio.tcl
source $libDir/splash.tcl
source $libDir/libtcl.tcl
source $libDir/libtk.tcl
source $libDir/about.tcl
source $libDir/progressbar.tcl
source $libDir/htmlview.tcl
source $libDir/rnotebook.tcl
source $libDir/balloon.tcl
source $projDir/tcl/flipgui1.tcl
source $projDir/tcl/flipgui2.tcl
source $projDir/tcl/buffer.tcl
source $projDir/tcl/buffergui.tcl
source $projDir/tcl/commands.tcl
source $projDir/tcl/protocol.tcl
source $projDir/tcl/updategui.tcl
source $projDir/tcl/toolbar.tcl
package require splash
package require sio
namespace import ::sio::*
namespace import ::libtcl::*
namespace import ::libtk::*
namespace import ::about::*
namespace import ::#dbglog::*
namespace import ::htmlview::*
namespace import ::balloon::*
set deviceFilesList [lsort [list T89C51RD2.tcl T89C51RB2.tcl T89C51RC2.tcl T89C51IC2.tcl T89C51CC01.tcl T89C51CC02.tcl AT89C5115.tcl T89C51AC2.tcl T8XC5121.tcl AT89C51SND1.tcl AT8XC5122.tcl AT89C5131.tcl AT89C5132.tcl AT89C51ED2.tcl AT89C51ID2.tcl AT89C51RB2.tcl AT89C51RC2.tcl AT89C51RD2.tcl AT89C51IC2.tcl AT89C51CC03.tcl]]
proc addDevices {} {
    global deviceFilesList
    set deviceFilesList [lsort [list T89C51RD2.tcl T89C51RB2.tcl T89C51IB2.tcl T89C51RC2.tcl T89C51IC2.tcl T89C51CC01.tcl T89C51CC02.tcl AT89C5115.tcl T89C51AC2.tcl T8XC5121.tcl AT89C51SND1.tcl AT8XC5122.tcl AT89C5131.tcl AT89C5132.tcl AT89C51ED2.tcl AT89C51ID2.tcl AT89C51RB2.tcl AT89C51RC2.tcl AT89C51RD2.tcl AT89C51IC2.tcl AT89C51CC03.tcl]]
    cmdsBuildDeviceList $deviceFilesList
    catch [destroy .deviceSelectDbox]
    drawDeviceSelectDbox
    return
}
proc addLu2000Device {} {
    global deviceFilesList
    set deviceFilesList [lsort [list LU2000.tcl]]
    cmdsBuildDeviceList $deviceFilesList
    catch [destroy .deviceSelectDbox]
    drawDeviceSelectDbox
    return
}
source $tclTestDir/tcltest.tcl
package require tcltest
namespace import ::tcltest::*
proc main {} {
    #dbgBeginProc [info level [info level]]
    global flipStates flipFont
    font create serif8 -family fixed -size 8
    font create helvetf8 -family Helvetica -size 8
    font create courierb -family Courier -size 10 -weight bold
    font create courier -family Courier -size 8
    label .dummy -text hi
    set flipFont [.dummy cget -font]
    destroy .dummy
    #dbgCtrl on
    #dbgShowInfo "Script = [info script]"
    #dbgShowInfo "Script = [file dirname [info script]]"
    #dbgShowInfo "Script = [file rootname [info script]]"
    init
    createWindows
    after 200
    ::splash::updateSplash "Done."
    ::splash::removeSplash
    #dbgEndProc [info level [info level]]
}
proc init {} {
    #dbgBeginProc [info level [info level]]
    global initialDir flipStates buffer baudList canBaudList
    global nAddrBits testArray blankCheckAddr projDir waitTime
    global canProtocol canAcc txQueue rxQueue rxQAcc
    global protcl env loadConfig workingDir doTestArray errCode working_active gui color bootloaderVerDependent progBar vector serialize
    set vector(slot) 0
    set vector(channel) 0
    set vector(cancardx) 2
    # Found in Vector header file.
    set vector(canpari) 3
    # Found in Vector header file.
    set vector(canac2) 5
    # Found in Vector header file.
    set buffer(movecopy) move
    set progBar(cancel) 0
    set bootloaderVerDependent(version) "XX"
    set bootloaderVerDependent(eeprom) 1
    set bootloaderVerDependent(eb) 1
    set bootloaderVerDependent(startAppli) 1
    set bootloaderVerDependent(p1p3p4_config) 0
    set working_active 0
    set flipStates(bufferInInitialState) 1
    set flipStates(readBlockSize) 0x400
    set flipStates(connectOnlyRS232) 0
    set flipStates(withReset) 0
    set flipStates(mssgBox) 1
    set flipStates(simul) 0
    set flipStates(searchFormat) ascii
    set loadConfig(port) ""
    set loadConfig(baud) ""
    set loadConfig(initComm) ""
    set loadConfig(parseHex) ""
    set loadConfig(fullChipErase) ""
    set loadConfig(eraseBlock0) ""
    set loadConfig(eraseBlock1) ""
    set loadConfig(eraseBlock2) ""
    set loadConfig(eraseBlock3) ""
    set loadConfig(eraseBlock4) ""
    set loadConfig(blankCheck) ""
    set loadConfig(blankCheckStart) ""
    set loadConfig(blankCheckEnd) ""
    set loadConfig(programDevice) ""
    set loadConfig(verifyDevice) ""
    set loadConfig(setSbv) ""
    set loadConfig(setBsb) ""
    set loadConfig(setSsb) ""
    set loadConfig(setOscFuse) ""
    set loadConfig(setBljbFuse) ""
    set loadConfig(setX2Fuse) ""
    set initialDir [pwd]
    set workingDir [pwd]
    set nAddrDigits 6
    set baudList [list 115200 57600 38400 19200 9600 4800 2400 1200]
    set canBaudList [list 1000k 500k 100k]
    set gui(init) 1
    set gui(erasePossibleBlocks) "disabled"
    set gui(erasePossibleBlock0) "disabled"
    set gui(erasePossibleBlock1) "disabled"
    set gui(erasePossibleBlock2) "disabled"
    set gui(erasePossibleBlock3) "disabled"
    set gui(erasePossibleBlock4) "disabled"
    set gui(sizeType) userDefined
    set gui(uDefSizeValue) 64
    set gui(dDepSizeValue) xx
    set gui(sizeValue) $gui(uDefSizeValue)
    set gui(maxAddr) [format "%06X" [expr ($gui(sizeValue) * 1024) - 1]]
    set gui(blankValueType) userDefined
    set gui(uDefBlankValue) FF
    set gui(dDepBlankValue) xx
    set gui(blankValue) $gui(uDefBlankValue)
    set gui(resetBufferOnLoading) no
    set gui(rangeOnDeviceProg) lastLoad
    set gui(uDefMinProgAddr) 000000
    set gui(uDefMaxProgAddr) 00FFFF
    set gui(lastLoadMinProgAddr) 000000
    set gui(lastLoadMaxProgAddr) 00FFFF
    set gui(minProgAddr) $gui(lastLoadMinProgAddr)
    set gui(maxProgAddr) $gui(lastLoadMaxProgAddr)
    set gui(loadingOffset) "0000"
    set gui(hexFileAddrOffset) "0000"
    set gui(modifyAddress) ""
    set gui(modifyData) ""
    set gui(numberOfVisibleLines) 24
    set gui(topDisplayedLine) 1
    set gui(bottomDisplayedLine) $gui(numberOfVisibleLines)
    set gui(numberOfLines) [expr ("0x$gui(maxAddr)" + 1) / 16]
    set gui(startFillAddr) $gui(minProgAddr)
    set gui(endFillAddr) $gui(maxProgAddr)
    set gui(fillValue) $gui(blankValue)
    set gui(fileLoaded) "no"
    set gui(maxSize) 64
    set gui(infoFormat) "%04X"
    set gui(eraseType) "full"
    if {! [info exists flipStates(lastloadedCfgFile)]} then {
	set flipStates(lastloadedCfgFile) ""
    }
    if {$flipStates(lastloadedCfgFile) == ""} then {
	set gui(flowErase) 1
	set gui(flowBlankCheck) 1
	set gui(flowProgram) 1
	set gui(flowVerify) 1
	set gui(flowStartAppli) 0
	set gui(flowWithReset) 0
    }
    set flipStates(anyComm) off
    set flipStates(rs232Comm) off
    set flipStates(canComm) off
    set flipStates(canNode) "closed"
    set flipStates(usbComm) off
    set flipStates(deviceSelection) disabled
    set flipStates(hexFile) "not loaded"
    set flipStates(hexFileMtime) 0
    set flipStates(hexFileName) ""
    set testArray(nonRegress) 0
    set testArray(protocol) 0
    set testArray(debug) "off"
    set testArray(logFile) "$initialDir/log.txt"
    set doTestArray(xaf) 1
    set doTestArray(flash) 1
    set doTestArray(fuse) 1
    set doTestArray(specific) 1
    set doTestArray(checksum) 1
    set doTestArray(eeprom) 1
    set doTestArray(can) 1
    set blankCheckAddr(start) $gui(minProgAddr)
    set blankCheckAddr(end) $gui(maxProgAddr)
    set ::deviceArray(startReadAddr) "000000"
    set ::deviceArray(endReadAddr) $gui(maxAddr)
    set waitTime(standard) 3000
    set waitTime(extended) 12000
    set protcl "none"
    set bMemorySelect .main.f_buffer.b_memSelect
    if {[winfo exists $bMemorySelect]} then {
	destroy $bMemorySelect
    }
    if {! [info exists serialize(memory)]} then {
	set serialize(memory) FLASH
	set serialize(initVal) 0
	set serialize(nBytes) 1
	set serialize(step) 0
	set serialize(lsbAddr) 0x0000
	set serialize(execute) 0
	set serialize(do_it) 0
	for {set i 0} {$i <= 63} {incr i} {
	    set ::sn($i) 0
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc createWindows {} {
    #dbgBeginProc [info level [info level]]
    global libDir projDir deviceFilesList screen version color
    global gui
    image create photo mhs -file $projDir/images/flip_splash.gif
    ::splash::createSplash mhs "Flip $version" "Copyright (C) 2002, Atmel\n \t          All Rights Reserved." "Loading User Interface..."
    wm title .splash "Flip $version"
    after 200
    ::splash::updateSplash "Drawing Main window..."
    drawMainWindow
    cmdsBuildDeviceList $deviceFilesList
    after 200
    ::splash::updateSplash "Drawing Device Selection window..."
    drawDeviceSelectDbox
    after 200
    ::splash::updateSplash "Drawing Device Selection window..."
    drawPartnersWindow
    #after 200
    #drawDeviceEraseDbox
    after 200
    ::splash::updateSplash "Drawing Buffer Options window..."
    drawBufferOptionsWindow
    after 200
    ::splash::updateSplash "Drawing Edit Buffer window..."
    drawBufferEditWindow
    setEditBufferBindings
    after 200
    ::splash::updateSplash "Drawing Modify Buffer window..."
    drawModifyBufferDbox
    after 200
    ::splash::updateSplash "Drawing Goto Buffer window..."
    drawGotoBufferDbox
    after 200
    ::splash::updateSplash "Drawing Buffer Fill window..."
    drawBufferFillDBox
    after 200
    ::splash::updateSplash "Drawing Command window..."
    drawCommandWindow
    after 200
    ::splash::updateSplash "Drawing USB window..."
    drawUsbCommDbox
    after 200
    ::splash::updateSplash "Drawing Search Buffer window..."
    drawSearchBufferDbox
    after 200
    ::splash::updateSplash "Drawing Copy/Move Buffer window..."
    drawCopyMoveDbox
    set screen(width) [winfo screenwidth .]
    set screen(height) [winfo screenheight .]
    set color(systemWindow) [.main.f_flow.f_operations.b_program cget -selectcolor]
    set gui(flowEraseColor) $color(systemWindow)
    set gui(flowBlankCheckColor) $color(systemWindow)
    set gui(flowProgramColor) $color(systemWindow)
    set gui(flowVerifyColor) $color(systemWindow)
    set gui(flowSpecialBytesColor) $color(systemWindow)
    update
    after 200
    wm deiconify .
    #dbgEndProc [info level [info level]]
    return 1
}
proc exitFlip {} {
    #dbgBeginProc [info level [info level]]
    global flipStates protcl
    if {0} then {
	if {[tk_messageBox -message "Exit Flip ?" -type okcancel -icon question -default ok -title "Flip"] != "ok"} then {
	    return
	}
    }
    if {$protcl=="RS232Standard"} then {
	if {[info exists ::sio::devId]} then {
	    catch [::sio::closeDevice]
	}
	if {[info exists ::sio::sioVars(RxBuffer)]} then {
	    catch [unset ::sio::sioVars(RxBuffer)]
	}
    } elseif {$protcl=="CANStandard"} {
	if {$flipStates(canComm) == "on"} then {
	    ptclCancelCANComm
	}
    } elseif {$protcl=="rs232can"} {
	if {$flipStates(canComm) == "on"} then {
	    ptclCancelRs232Comm
	}
    }
    createConfigFile
    #dbgEndProc [info level [info level]]
    exit
}
proc sim {} {
    global flipStates
    set flipStates(simul) 1
    return
}
wm withdraw .
main
#dbgShowVar "argv = $argv"
if {$argv != ""} then {
    set cfgFile [string range $argv 1 end-1]
    set flipStates(lastloadedCfgFile) $cfgFile
    runLastLoadedConfigFile
}
proc showTrace {Name Index Op} {
    upvar $Name $Name
    if {$Index == ""} then {
	set fullName $Name
    } else {
	set fullName ${Name}($Index)
    }
    switch $Op {
    r {
	    puts "$fullName was read"
	}
    w {
	    puts "$fullName was written, new value is \"[set $fullName]\""
	}
    u {
	    puts "$fullName was unset"
	}
    }
}
proc drawCanNodeConfigDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont
    set w .canNodeConfigDbox
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "CAN Node Configuration"
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fTop .canNodeConfigDbox.f_top
    frame $fTop -relief raised -bd 2
    for {set i 1} {$i <=5} {incr i} {
	set f$i $fTop.f_$i
	set j f$i
	frame [subst $$j] -width 150 -relief groove -bd 2
    }
    set fb .canNodeConfigDbox.f_b
    frame $fb
    label $f1.l_node -text "Node :" -anchor w -font $flipFont -width 7
    entry $f1.e_node -textvariable ::deviceArray(nnbProg) -font $flipFont -state normal -width 4
    pack configure $f1.l_node $f1.e_node -side left -padx 5 -pady 5
    label $f2.l_cris -text "CRIS :" -anchor w -font $flipFont -width 7
    entry $f2.e_cris -textvariable ::deviceArray(crisProg) -font $flipFont -state normal -width 4
    pack configure $f2.l_cris $f2.e_cris -side left -padx 5 -pady 5
    label $f3.l_btc1 -text "BTC_1 :" -anchor w -font $flipFont -width 7
    entry $f3.e_btc1 -textvariable ::deviceArray(btc1) -font $flipFont -state normal -width 4
    pack configure $f3.l_btc1 $f3.e_btc1 -side left -padx 5 -pady 5
    label $f4.l_btc1 -text "BTC_2 :" -anchor w -font $flipFont -width 7
    entry $f4.e_btc1 -textvariable ::deviceArray(btc2) -font $flipFont -state normal -width 4
    pack configure $f4.l_btc1 $f4.e_btc1 -side left -padx 5 -pady 5
    label $f5.l_btc1 -text "BTC_3 :" -anchor w -font $flipFont -width 7
    entry $f5.e_btc1 -textvariable ::deviceArray(btc3) -font $flipFont -state normal -width 4
    pack configure $f5.l_btc1 $f5.e_btc1 -side left -padx 5 -pady 5
    pack configure $f1 $f2 $f3 $f4 $f5 -side top -padx 30 -pady 5 -fill x
    button $fb.b_read -text "Read" -font $flipFont -command {ptclReadCanConfig} -bd 3 -state normal
    button $fb.b_set -text "Set" -font $flipFont -command {ptclSetCanConfig} -bd 3 -state normal
    button $fb.b_cancel -text "Cancel" -font $flipFont -command "wm withdraw $w" -bd 2 -state normal
    pack $fb.b_read $fb.b_set $fb.b_cancel -padx 10 -side left
    pack configure $fTop -padx 5 -pady 5
    pack configure $fb -pady 10
    #dbgEndProc [info level [info level]]
    return
}
proc drawP1P3P4ConfigDbox {} {
    global flipFont
    set w .configP1P3P4Window
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Hardware Conditions Setup"
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fTop $w.f_top
    frame $fTop -relief raised -bd 2
    foreach i {p1 p3 p4} {
	set f$i $fTop.f_$i
	set j f$i
	frame [subst $$j] -width 150 -relief flat
    }
    set fb $w.f_b
    frame $fb
    foreach i {p1 p3 p4} j {"P1 Config" "P3 Config" "P4 Config"} {
	set k f$i
	label [subst $$k].l_$i -text $j -anchor w -font $flipFont -width 10
	entry [subst $$k].e_$i -textvariable ::deviceArray(${i}_config) -font $flipFont -state normal -width 3
	pack configure [subst $$k].l_$i [subst $$k].e_$i -side left -padx 5 -pady 5
	pack configure [subst $$k]
    }
    button $fb.b_read -text "Read" -font $flipFont -command {ptclReadPortsConfig} -bd 3 -state normal
    button $fb.b_set -text "Set" -font $flipFont -command {ptclSetPortsConfig} -bd 3 -state normal
    button $fb.b_cancel -text "Cancel" -font $flipFont -command "wm withdraw $w" -bd 2 -state normal
    pack $fb.b_read $fb.b_set $fb.b_cancel -padx 10 -side left
    pack configure $fTop -padx 5 -pady 5 -expand 1 -fill both
    pack configure $fb -pady 10
    return
}
proc drawOscillatorConfigDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont
    set w .configOscWindow
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "Oscillator Control"
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fTop $w.f_top
    frame $fTop -relief raised -bd 2
    set frb $fTop.f_rb
    frame $frb
    set fb $w.f_b
    frame $fb
    set bOsc32 $frb.b_osc32
    radiobutton $bOsc32 -indicatoron 1 -variable ::deviceArray(oscCtrl) -value 3 -font $flipFont -text "32 MHz" -anchor w
    set bOsc16 $frb.b_osc16
    radiobutton $bOsc16 -indicatoron 1 -variable ::deviceArray(oscCtrl) -value 2 -font $flipFont -text "16 MHz" -anchor w
    set bOsc8 $frb.b_osc8
    radiobutton $bOsc8 -indicatoron 1 -variable ::deviceArray(oscCtrl) -value 1 -font $flipFont -text "8 MHz" -anchor w
    pack configure $bOsc32 $bOsc16 $bOsc8 -anchor w -side top
    button $fb.b_read -text "Read" -font $flipFont -command {ptclReadHwByte} -bd 3 -state normal
    button $fb.b_set -text "Set" -font $flipFont -command {ptclWriteHwByte} -bd 3 -state normal
    button $fb.b_cancel -text "Cancel" -font $flipFont -command "wm withdraw $w" -bd 2 -state normal
    pack $fb.b_read $fb.b_set $fb.b_cancel -padx 10 -side left
    pack configure $frb
    pack configure $fTop -padx 5 -pady 5 -expand 1 -fill both
    pack configure $fb -pady 10
    #dbgEndProc [info level [info level]]
    return
}
proc popupCommMenu {} {
    #dbgBeginProc [info level [info level]]
    set geoInfo [winfo geometry .]
    set w [winfo width .]
    set h [winfo height .]
    set xTopLeft [winfo x .]
    set yTopLeft [winfo y .]
    tk_popup .menubar.settings.comm [expr [winfo x .] + 55] [expr [winfo y .] + 90]
    #dbgEndProc [info level [info level]]
}
proc drawMainWindow {} {
    #dbgBeginProc [info level [info level]]
    global flipStates PROMPT projDir prot version flipFont
    global canProtocol gui
    wm title . "Atmel - Flip $version"
    wm resizable . 0 0
    wm protocol . WM_DELETE_WINDOW { exitFlip }
    menu .menubar -type menubar
    . configure -menu .menubar
    set MainItemsList "File Buffer Device Settings Help"
    foreach Item $MainItemsList {
	set SubMenu [string tolower $Item]
	.menubar add cascade -label $Item -menu .menubar.$SubMenu -underline 0 -font $flipFont
    }
    set f "file"
    menu .menubar.$f -tearoff no
    .menubar.$f add command -label "Load HEX..." -command {cbParseHexFile} -underline 0 -font $flipFont -state disabled
    .menubar.$f add command -label "Save HEX As..." -command {cbWriteHexFile} -underline 0 -font $flipFont -state disabled
    .menubar.$f add separator
    .menubar.$f add command -label "Read Configuration File..." -command {cmdsLoadConfig} -accelerator "F4" -underline 0 -font $flipFont
    .menubar.$f add command -label "Execute Configuration File" -command {runLastLoadedConfigFile} -accelerator "F5" -underline 0 -font $flipFont -state disabled
    .menubar.$f add command -label "Save Configuration As..." -command {cbSaveConfig} -underline 5 -font $flipFont -state disabled
    .menubar.$f add separator
    .menubar.$f add command -label "Exit" -command {exitFlip} -underline 1 -font $flipFont
    set b "buffer"
    menu .menubar.$b -tearoff no
    .menubar.$b add command -label "Edit" -command {cbDboxWakeUp .bufferEditWindow} -underline 0 -font $flipFont -state disabled
    .menubar.$b add command -label "Options" -command {cbOnBufferOptions} -underline 0 -font $flipFont -state disabled
    set d "device"
    menu .menubar.$d -tearoff no
    .menubar.$d add command -label "Select..." -accelerator "F2" -command {cbDboxWakeUp .deviceSelectDbox} -underline 0 -font $flipFont
    .menubar.$d add separator
    .menubar.$d add command -label "Erase..." -command {cbDboxWakeUp .deviceErase} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    .menubar.$d add command -label "Blank Check..." -command {cbDboxWakeUp .blankCheckDBox} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    .menubar.$d add command -label "Read..." -command {cbDboxWakeUp .deviceReadDBox} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    .menubar.$d add command -label "Program" -command {cmdsDeviceProgram} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    .menubar.$d add command -label "Verify" -command {cmdsDeviceVerify} -underline 0 -font $flipFont -state $flipStates(deviceSelection)
    set t "settings"
    set c "comm"
    menu .menubar.$t -tearoff no
    .menubar.$t add cascade -label "Communication        F3" -menu .menubar.$t.$c -underline 0 -font $flipFont
    .menubar.$t add command -label "Command Window..." -command {cbDboxWakeUp .cmdWindow} -underline 8 -font $flipFont
    menu .menubar.$t.$c -tearoff no
    .menubar.$t.$c add command -label "RS232" -state disabled -command {initProtocol "RS232Standard"
	cbDboxWakeUp .rs232CommDbox} -underline 0 -font $flipFont
    .menubar.$t.$c add cascade -label "CAN" -state disabled -menu .menubar.$t.$c.select -underline 0 -font $flipFont
    .menubar.$t.$c add cascade -label "USB" -state disabled -command {initProtocol "USB_DFU"
	cbDboxWakeUp .usbCommDbox} -underline 0 -font $flipFont
    menu .menubar.$t.$c.select -tearoff no
    .menubar.$t.$c.select add command -label "ATMEL RS232" -state normal -command {set canProtocol(hardware) "ATMEL_RS232"
	initProtocol "rs232can"
	cbDboxWakeUp .rs232canSetup
	updateGUI onCANDongleSelection} -underline 0 -font $flipFont
    .menubar.$t.$c.select add command -label "RM CANview" -state normal -command {set canProtocol(hardware) "CANVIEW"
	initProtocol "canview"
	cbDboxWakeUp .rs232canSetup
	updateGUI onCANDongleSelection} -underline 0 -font $flipFont
    .menubar.$t.$c.select add separator
    .menubar.$t.$c.select add cascade -label "VECTOR" -state normal -menu .menubar.$t.$c.select.vector -underline 0 -font $flipFont
    .menubar.$t.$c.select add command -label "IXXAT CANdy" -state normal -command {set canProtocol(hardware) "CANDY"
	initProtocol "CANStandard"
	cbDboxWakeUp .canSetup
	updateGUI onCANDongleSelection} -underline 0 -font $flipFont
    .menubar.$t.$c.select add command -label "PEAK PCAN-DONGLE" -state normal -command {set canProtocol(hardware) "PEAK"
	initProtocol "CANStandard"
	cbDboxWakeUp .canSetup
	updateGUI onCANDongleSelection} -underline 0 -font $flipFont
    .menubar.$t.$c.select add separator
    .menubar.$t.$c.select add command -label "ATMEL USB" -state normal -command {set canProtocol(hardware) "ATMEL_USB"
	initProtocol "usbcan"
	cbDboxWakeUp .canSetup
	updateGUI onCANDongleSelection} -underline 0 -font $flipFont -state disabled
    .menubar.$t.$c.select add command -label "SYSTEC USBCAN" -state normal -command {set canProtocol(hardware) "SYSTEC"
	initProtocol "CANStandard"
	cbDboxWakeUp .canSetup
	updateGUI onCANDongleSelection} -underline 0 -font $flipFont
    menu .menubar.$t.$c.select.vector -tearoff no
    if {0} then {
	.menubar.$t.$c.select.vector add command -label "CANac2" -state normal -command {set canProtocol(hardware) "CANAC2"
	    initProtocol "CANStandard"
	    cbDboxWakeUp .canSetup
	    set vector(hwType) $vector(canac2)
	    updateGUI onCANDongleSelection} -underline 3 -font $flipFont
    }
    .menubar.$t.$c.select.vector add command -label "CANcardX" -state normal -command {set canProtocol(hardware) "CANCARDX"
	initProtocol "CANStandard"
	cbDboxWakeUp .canSetup
	set vector(hwType) $vector(cancardx)
	updateGUI onCANDongleSelection} -underline 3 -font $flipFont
    .menubar.$t.$c.select.vector add command -label "CANpari" -state normal -command {set canProtocol(hardware) "CANPARI"
	initProtocol "CANStandard"
	cbDboxWakeUp .canSetup
	set vector(hwType) $vector(canpari)
	updateGUI onCANDongleSelection} -underline 3 -font $flipFont
    menu .menubar.help -tearoff no
    .menubar.help add command -label "Contents..." -accelerator "F1" -command {htmlView "Help" ./doc/flip_um.htm} -underline 0 -font $flipFont
    .menubar.help add separator
    .menubar.help add command -label "About Flip..." -command {displayAbout} -underline 0 -font $flipFont
    .menubar.help add command -label "Third Party Vendors..." -command {cbDboxWakeUp .partners} -underline 0 -font $flipFont
    frame .main -relief sunken -bd 1
    createMainToolBar
    set h1 410
    set w1 190
    frame .main.topRow
    frame .main.bottomRow
    frame .main.f_flow -borderwidth 2 -relief groove -height $h1 -width $w1
    frame .main.f_buffer -borderwidth 2 -relief groove -height $h1 -width $w1
    frame .main.f_device -borderwidth 2 -relief groove -height $h1 -width [expr $w1 + 30]
    set ff .main.f_flow
    label $ff.l_flow -text "Operations Flow" -font $flipFont -relief groove -bd 2
    setBalloon $ff.l_flow "Define operations to be performed"
    set fOperations $ff.f_operations
    frame $fOperations -relief flat
    set bErase $fOperations.b_erase
    checkbutton $bErase -text "Erase" -font $flipFont -variable gui(flowErase) -onvalue 1 -offvalue 0 -indicatoron true -state disabled -command {writeBuffer flowErase $gui(flowErase)}
    setBalloon $bErase "Check the Erase dialog box for\n erasing boundaries."
    set bBlankCheck $fOperations.b_blankCheck
    checkbutton $bBlankCheck -text "Blank Check" -font $flipFont -variable gui(flowBlankCheck) -onvalue 1 -offvalue 0 -command {writeBuffer flowBlankCheck $gui(flowBlankCheck)} -indicatoron true -state disabled
    setBalloon $bBlankCheck "Check the Blank Check dialog box\n for blank checking boundaries."
    set bProgram $fOperations.b_program
    checkbutton $bProgram -text "Program" -font $flipFont -variable gui(flowProgram) -onvalue 1 -offvalue 0 -command {writeBuffer flowProgram $gui(flowProgram)} -indicatoron true -state disabled
    setBalloon $bProgram "Device memory programming:\n see the address range in the Buffer Information frame."
    set bVerify $fOperations.b_verify
    checkbutton $bVerify -text "Verify" -font $flipFont -variable gui(flowVerify) -onvalue 1 -offvalue 0 -command {writeBuffer flowVerify $gui(flowVerify)} -indicatoron true -state disabled
    setBalloon $bVerify "Device memory verification:\n see the address range in the Buffer Information frame."
    set bSpecialBytes $fOperations.b_specialBytes
    checkbutton $bSpecialBytes -text "Set Special Bytes" -font $flipFont -variable gui(flowSpecialBytes) -onvalue 1 -offvalue 0 -command {writeBuffer flowSpecialBytes $gui(flowSpecialBytes)} -indicatoron true -state disabled
    setBalloon $bSpecialBytes "Set device special bytes:\n see selected values in the device frame."
    pack configure $bErase $bBlankCheck $bProgram $bVerify $bSpecialBytes -anchor w -pady 15
    set fButtons $ff.f_buttons
    frame $fButtons -relief flat
    set bRun $fButtons.b_run
    button $bRun -text "Run" -font $flipFont -bd 3 -font $flipFont -command {cmdsRunOperations} -state disabled
    setBalloon $bRun "Performs selected operations"
    set bClear $fButtons.b_clear
    button $bClear -text "Clear" -font $flipFont -bd 3 -font $flipFont -command {cmdsClearOperations 0} -state disabled
    setBalloon $bClear "Clears operations selection"
    pack configure $bRun $bClear -side left -padx 10
    pack config $ff.l_flow -side top -pady 5 -ipadx 10
    pack configure $fOperations -side top -pady 15
    pack configure $fButtons -side top -pady 5
    pack propagate $ff 0
    set fb .main.f_buffer
    label $fb.l_bufferInfoTitle -text "Buffer Information" -font $flipFont -relief groove -bd 2
    setBalloon $fb.l_bufferInfoTitle "Buffer information"
    pack config $fb.l_bufferInfoTitle -side top -pady 5 -ipadx 10
    label $fb.l_bufferSize -text "Size:\t$gui(sizeValue) Kbytes" -font $flipFont
    setBalloon $fb.l_bufferSize "Buffer size"
    pack config $fb.l_bufferSize -side top -anchor w -padx 5
    label $fb.l_bufferBlank -text "Blank:\t$gui(blankValue)" -font $flipFont
    setBalloon $fb.l_bufferBlank "Blank value used on buffer reset"
    pack config $fb.l_bufferBlank -side top -anchor w -padx 5
    label $fb.l_range -text "Range:\t[format $gui(infoFormat) 0x$gui(minProgAddr)] - [format $gui(infoFormat) 0x$gui(maxProgAddr)]" -font $flipFont -fg blue
    setBalloon $fb.l_range "Address range used for \n Program and Verify operations."
    pack config $fb.l_range -side top -anchor w -padx 5
    frame $fb.f_checkSum
    label $fb.f_checkSum.l_title -text "Checksum:" -font $flipFont -fg blue
    setBalloon $fb.f_checkSum.l_title "Buffer checksum"
    label $fb.f_checkSum.l_cksum -text "" -font $flipFont -fg blue
    setBalloon $fb.f_checkSum.l_cksum "Calculation is made on the above address range"
    pack config $fb.f_checkSum.l_title -side left -padx 5
    pack config $fb.f_checkSum.l_cksum -side left
    pack config $fb.f_checkSum -side top -fill x
    label $fb.l_offset -text "Offset:\t[format $gui(infoFormat) 0x$gui(loadingOffset)]" -font $flipFont
    setBalloon $fb.l_offset "Offset applied to read addresses on file load"
    pack config $fb.l_offset -side top -anchor w -padx 5
    if {$gui(resetBufferOnLoading) == "yes"} then {
	label $fb.l_bufferReset -text "Reset Before Loading" -font $flipFont
    } else {
	label $fb.l_bufferReset -text "No Reset Before Loading" -font $flipFont
    }
    setBalloon $fb.l_bufferReset "Reset/no buffer reset before file load"
    pack config $fb.l_bufferReset -side top -anchor w -padx 5
    frame $fb.f_separator -height 2 -relief groove -bd 2
    pack config $fb.f_separator -side top -fill x -padx 10 -pady 10
    frame $fb.f_hexFile
    label $fb.f_hexFile.l_title -text "HEX File:" -font $flipFont
    setBalloon $fb.f_hexFile.l_title "Last loaded HEX file"
    label $fb.f_hexFile.l_fileN -text "none" -font $flipFont
    setBalloon $fb.f_hexFile.l_fileN "Last loaded HEX file"
    frame $fb.f_serialNum
    label $fb.f_serialNum.l_title -text "Serial Number:" -font $flipFont
    label $fb.f_serialNum.l_number -text "" -font $flipFont
    image create photo logo_company -file $projDir/images/atmel_rvb.gif
    frame $fb.f_hexFileSize
    frame $fb.f_hexFileSize.space -width 50
    frame $fb.f_hexFileSize.title
    frame $fb.f_companyLogo -width 50 -height 80 -relief flat
    label $fb.f_companyLogo.l_companyLogo -image logo_company
    pack $fb.f_companyLogo.l_companyLogo
    label $fb.f_hexFileSize.l_title -text "         " -font $flipFont
    setBalloon $fb.f_hexFileSize.l_title "Hex file size"
    label $fb.f_hexFileSize.title.l_fileS -text "" -font $flipFont
    setBalloon $fb.f_hexFileSize.title.l_fileS "HEX file size"
    pack config $fb.f_hexFile.l_title -side left -padx 5
    pack config $fb.f_hexFile.l_fileN -side left
    pack config $fb.f_hexFile -side top -fill x
    pack config $fb.f_hexFileSize.title.l_fileS -side left
    pack config $fb.f_hexFileSize.space -side left -padx 5
    pack config $fb.f_hexFileSize.title -side left
    pack config $fb.f_hexFileSize -side top -fill x
    pack config $fb.f_serialNum.l_title -side top -padx 5 -anchor w
    pack config $fb.f_serialNum.l_number -side top
    pack config $fb.f_serialNum -side top -fill x
    pack config $fb.f_companyLogo -side top -fill x -pady 30 -padx 10
    pack propagate $fb 0
    set fd .main.f_device.f_deviceName
    frame $fd -bd 2 -relief groove -height 20 -width 160
    label $fd.l_device -text "No device selected" -font $flipFont
    setBalloon $fd "Device frame:\n values shown are actual values"
    pack config $fd.l_device -side top
    pack config $fd -side top -pady 5
    pack propagate $fd 0
    pack .main.toolbar -pady 2 -anchor w
    pack .main.f_flow -side left -padx 10 -pady 5
    pack .main.f_buffer -side left -pady 5
    pack .main.f_device -side left -padx 10 -pady 5
    pack propagate .main.f_flow 0
    pack propagate .main.f_buffer
    pack propagate .main.f_device 0
    drawStatusBar
    pack config .main -fill x -side top
    log_message "Device > Select..."
    bind . <F1> {htmlView "Help" ./doc/flip_um.htm}
    bind . <F2> {cbDboxWakeUp .deviceSelectDbox}
    bind . <F4> {cmdsLoadConfig}
    bind . <F5> {runLastLoadedConfigFile}
    bind . <F9> {#dbgCtrl on }
    for {set i 1} {$i <= 9} {incr i} {
	bind . <Alt-F$i> {doNothing}
	bind . <Control-F$i> {doNothing}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc doNothing {} {
    return
}
proc drawStatusBar {} {
    #dbgBeginProc [info level [info level]]
    global flipFont
    set f .f_status
    frame $f -borderwidth 0
    label $f.l_message -relief sunken -anchor w -borderwidth 1 -height 1 -text "" -font $flipFont -bg white -width 35
    label $f.l_comm -relief sunken -anchor w -borderwidth 1 -height 1 -text "Comm. OFF" -font $flipFont -width 30
    setBalloon $f.l_comm "Communication information:\n port / baudrate / ..."
    set pBar [::progressbar::progressbar $f.pb -width 280 -color grey -shape flat]
    pack config $f.l_message -side left -padx 1 -pady 1 -expand 0 -fill x
    pack config $pBar -side left -pady 1
    pack $f.l_comm -side right -padx 1 -pady 1
    pack propagate $f.l_message 0
    pack config $f -fill x -side bottom
    #dbgEndProc [info level [info level]]
    return
}
proc drawProgressBarDbox {} {
    #dbgBeginProc [info level [info level]]
    global progBar flipFont
    set w .progressBarDbox
    if {[winfo exists $w]} then {
	destroy $w
    }
    toplevel $w -class Dialog
    wm title $w "Running..."
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    label $w.l_actionOnGoing -relief flat -anchor w -text "" -font $flipFont
    label $w.l_percent -relief flat -width 20 -borderwidth 1 -text "" -font $flipFont
    set pBar [::progressbar::progressbar $w.pb -width 300]
    frame $w.f_extraSpace -relief flat -height 20
    button $w.b_cancel -bd 1 -text "Cancel" -font $flipFont -bd 2 -command "closeProgBarWindow;  set progBar(cancel) 1"
    pack config $w.l_actionOnGoing $w.l_percent -side top -fill x -pady 10
    pack $pBar $w.f_extraSpace -side top
    pack config $w.b_cancel -side top -pady 5
    set progBar(cancel) 0
    #dbgEndProc [info level [info level]]
    return
}
proc cmdInterp {} {
    #dbgBeginProc [info level [info level]]
    global projDir
    interp create interact
    interact alias h displayGeneralHelp
    interact alias hlp displayGeneralHelp
    interact alias help displayGeneralHelp
    interact alias H displayGeneralHelp
    interact alias HLP displayGeneralHelp
    interact alias HELP displayGeneralHelp
    interact alias Help displayGeneralHelp
    interact alias Hlp displayGeneralHelp
    interact alias sos displayGeneralHelp
    interact alias SOS displayGeneralHelp
    interact alias Sos displayGeneralHelp
    interact alias "?" displayGeneralHelp
    interact alias man displayGeneralHelp
    interact alias cmds displayCommandsHelp
    interact alias bdata bufferData
    interact alias bopt bufferOptions
    interact alias tst drawTestSelectionDbox
    interact alias #dbgOn #dbgCtrl on
    interact alias #dbgOff #dbgCtrl off
    interact alias timers cbDboxWakeUp .timersDBox
    interact alias crc storeCRCinBuffer
    interact alias puts #dbgShowInfo
    interact alias uc addDevices
    interact alias lu2000 addLu2000Device
    interact alias ptclSendFrame ptclSendFrame
    #dbgEndProc [info level [info level]]
    return
}
proc displayCommandsHelp {} {
    #dbgBeginProc [info level [info level]]
    actionsLog_message ""
    actionsLog_message "_______________________________________________"
    actionsLog_message ""
    actionsLog_message "\tC O M M A N D S      H E L P"
    actionsLog_message "_______________________________________________"
    actionsLog_message "bdata Lo Hi\tdisplays buffer data within specified address range."
    actionsLog_message "bopt\t\tdisplays buffer options."
    #dbgEndProc [info level [info level]]
    return
}
proc displayGeneralHelp {} {
    #dbgBeginProc [info level [info level]]
    actionsLog_message ""
    actionsLog_message "_______________________________________________"
    actionsLog_message ""
    actionsLog_message "\tG E N E R A L      H E L P"
    actionsLog_message "_______________________________________________"
    actionsLog_message "#dbgOn\t\topens the debug window."
    actionsLog_message "#dbgOff\t\tcloses the debug window."
    actionsLog_message "tst\t\topens the tests setup dialog box."
    actionsLog_message "timers\t\topens the time out timers setup dialog box."
    actionsLog_message "cmds\t\tdisplays help on commands."
    #dbgEndProc [info level [info level]]
    return
}
proc drawCommandWindow {} {
    #dbgBeginProc [info level [info level]]
    global PROMPT flipFont
    set w .cmdWindow
    if {[winfo exists $w]} then {
	destroy $w
    }
    toplevel $w -class Dialog
    wm title $w "Command"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fl $w.f_actionsLog
    frame $fl -height 80
    text $fl.text -yscrollcommand "$fl.scroll set" -insertofftime 0 -height 20 -width 100 -background #ffff9f
    scrollbar $fl.scroll -command "$fl.text yview"
    set fb $w.f_button
    frame $fb
    button $fb.b_ok -text "Dismiss" -command "wm withdraw $w" -bd 3 -font $flipFont
    setBalloon $fb.b_ok "Closes the command window"
    pack configure $fl.scroll -side right -fill y -pady 5
    pack configure $fl.text -side left -fill x -pady 5
    pack configure $fb.b_ok -side top -pady 5
    pack config $fl $fb -side top
    focus $fl.text
    bind $fl.text <Key> {
	if {"%K" == "BackSpace"} then {
	    if [%W compare insert <= boundary] then break
	} elseif {"%K" == "Right" || "%K" == "Left" || "%K" == "Up" || "%K" == "Down" || "%K" == "Prior" || "%K" == "Next"} {
	    continue
	} elseif [%W compare insert < boundary] {
	    %W mark set insert {end -1char}
	}
	%W see {insert linestart}
	%W see insert
    }
    cmdInterp
    bind $fl.text <Key-Return> {
	if {[%W compare insert < boundary]} then {
	    %W mark set insert {end -1char}
	}
	doCommand %W
	break
    }
    bind $w <Key-Escape> {
	wm withdraw .cmdWindow
    }
    set PROMPT "> "
    startNewCommandLine $fl.text
    $fl.text mark gravity boundary left
    #dbgEndProc [info level [info level]]
    return
}
proc drawTestSelectionDbox {} {
    #dbgBeginProc [info level [info level]]
    global testArray flipFont protcl doTestArray
    set w .testSelectionDbox
    if {[winfo exists $w]} then {
	destroy $w
    }
    toplevel $w -class Dialog
    wm title $w "Tests Selection"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set checkbuttfr $w.f_buttons
    frame $checkbuttfr -relief groove -bd 2
    checkbutton $checkbuttfr.b_appli -text "FLIP non regression tests" -variable testArray(nonRegress) -font $flipFont
    setBalloon $checkbuttfr.b_appli "GUI and internal procedures tests"
    checkbutton $checkbuttfr.b_protocol -text "$protcl protocol non regression tests" -variable testArray(protocol) -command {updateGUI onProtocolTestSelection} -font $flipFont
    setBalloon $checkbuttfr.b_protocol "Protocol specific tests"
    checkbutton $checkbuttfr.b_debugWindow -text "Debug Window" -variable testArray(debug) -command {updateGUI onTestDebugChanged} -onvalue "on" -offvalue "off" -font $flipFont
    setBalloon $checkbuttfr.b_debugWindow "Shows debug window"
    pack config $checkbuttfr.b_appli $checkbuttfr.b_protocol $checkbuttfr.b_debugWindow -side top -anchor w
    set filesfr $w.f_files
    frame $filesfr -relief groove -bd 2
    set skipTestsFr $w.f_skip
    frame $skipTestsFr -relief groove -bd 2
    if {$protcl == "RS232Standard"} then {
	checkbutton $skipTestsFr.b_skip1 -text "XAF tests" -variable doTestArray(xaf) -font $flipFont
	checkbutton $skipTestsFr.b_skip2 -text "FLASH tests" -variable doTestArray(flash) -font $flipFont
	checkbutton $skipTestsFr.b_skip3 -text "FUSE tests" -variable doTestArray(fuse) -font $flipFont
	checkbutton $skipTestsFr.b_skip4 -text "SPECIFIC tests" -variable doTestArray(specific) -font $flipFont
	checkbutton $skipTestsFr.b_skip5 -text "CHECKSUM tests" -variable doTestArray(checksum) -font $flipFont
	checkbutton $skipTestsFr.b_skip6 -text "EEPROM tests" -variable doTestArray(eeprom) -font $flipFont
	pack config $skipTestsFr.b_skip1 $skipTestsFr.b_skip2 $skipTestsFr.b_skip3 $skipTestsFr.b_skip4 $skipTestsFr.b_skip5 $skipTestsFr.b_skip6 -side top -anchor w
    } elseif {($protcl == "CANStandard") ||($protcl == "canview") ||($protcl == "usbcan")} {
	checkbutton $skipTestsFr.b_skip1 -text "XAF tests" -variable doTestArray(xaf) -font $flipFont
	checkbutton $skipTestsFr.b_skip2 -text "FLASH tests" -variable doTestArray(flash) -font $flipFont
	checkbutton $skipTestsFr.b_skip3 -text "FUSE tests" -variable doTestArray(fuse) -font $flipFont
	checkbutton $skipTestsFr.b_skip4 -text "SPECIFIC tests" -variable doTestArray(specific) -font $flipFont
	checkbutton $skipTestsFr.b_skip5 -text "CAN tests" -variable doTestArray(can) -font $flipFont
	checkbutton $skipTestsFr.b_skip6 -text "EEPROM tests" -variable doTestArray(eeprom) -font $flipFont
	pack config $skipTestsFr.b_skip1 $skipTestsFr.b_skip2 $skipTestsFr.b_skip3 $skipTestsFr.b_skip4 $skipTestsFr.b_skip5 $skipTestsFr.b_skip6 -side top -anchor w
    } elseif {$protcl == "rs232can"} {
	checkbutton $skipTestsFr.b_skip1 -text "XAF tests" -variable doTestArray(xaf) -font $flipFont
	checkbutton $skipTestsFr.b_skip2 -text "FLASH tests" -variable doTestArray(flash) -font $flipFont
	checkbutton $skipTestsFr.b_skip3 -text "FUSE tests" -variable doTestArray(fuse) -font $flipFont
	checkbutton $skipTestsFr.b_skip4 -text "SPECIFIC tests" -variable doTestArray(specific) -font $flipFont
	checkbutton $skipTestsFr.b_skip5 -text "CAN tests" -variable doTestArray(can) -font $flipFont
	checkbutton $skipTestsFr.b_skip6 -text "EEPROM tests" -variable doTestArray(eeprom) -font $flipFont
	pack config $skipTestsFr.b_skip1 $skipTestsFr.b_skip2 $skipTestsFr.b_skip3 $skipTestsFr.b_skip4 $skipTestsFr.b_skip5 $skipTestsFr.b_skip6 -side top -anchor w
    } elseif {$protcl == "USB_DFU"} {
	checkbutton $skipTestsFr.b_skip1 -text "XAF tests" -variable doTestArray(xaf) -font $flipFont
	checkbutton $skipTestsFr.b_skip2 -text "FLASH tests" -variable doTestArray(flash) -font $flipFont
	checkbutton $skipTestsFr.b_skip3 -text "FUSE tests" -variable doTestArray(fuse) -font $flipFont
	checkbutton $skipTestsFr.b_skip4 -text "SPECIFIC tests" -variable doTestArray(specific) -font $flipFont
	checkbutton $skipTestsFr.b_skip5 -text "EEPROM tests" -variable doTestArray(eeprom) -font $flipFont
	pack config $skipTestsFr.b_skip1 $skipTestsFr.b_skip2 $skipTestsFr.b_skip3 $skipTestsFr.b_skip4 $skipTestsFr.b_skip5 -side top -anchor w
    }
    set logfr $filesfr.f_log
    frame $logfr -width 300
    label $logfr.l_log -text "Tests Log File:" -width 15 -font $flipFont
    setBalloon $logfr.l_log "File where tests results will be logged"
    entry $logfr.e_log -textvariable testArray(logFile) -width 30 -font $flipFont
    setBalloon $logfr.e_log "Log file name"
    button $logfr.b_log -text "Browse..." -font $flipFont -command {set testArray(logFile) [fileSaveGet "Tests Log File Selection"]}
    setBalloon $logfr.b_log "Browse file system"
    pack config $logfr.l_log $logfr.e_log -side left
    pack config $logfr.b_log -side left -padx 10 -pady 10
    set okbuttonfr $w.f_okbutton
    frame $okbuttonfr
    button $okbuttonfr.b_ok -text "OK" -bd 3 -font $flipFont -command " wm withdraw $w; cmdsRunTests "
    setBalloon $okbuttonfr.b_ok "Applies selection\nand close dialog box"
    button $okbuttonfr.b_apply -text "Apply" -bd 3 -font $flipFont -command {cmdsRunTests}
    setBalloon $okbuttonfr.b_apply "Applies selection"
    button $okbuttonfr.b_cancel -bd 2 -text "Cancel" -font $flipFont -command "wm withdraw $w"
    setBalloon $okbuttonfr.b_cancel "Closes dialog box\nwithout applying selection"
    pack config $okbuttonfr.b_cancel $okbuttonfr.b_apply $okbuttonfr.b_ok -side right -padx 5
    pack config $logfr -side top
    pack config $checkbuttfr $skipTestsFr $filesfr $okbuttonfr -side top -padx 5 -pady 10 -expand 1 -fill x
    bind $logfr.e_log <Key-Return> {cmdsRunTests "ok"}
    if {$testArray(protocol)} then {
	foreach chkb [winfo children .testSelectionDbox.f_skip] {
	    $chkb configure -state normal
	}
    } else {
	foreach chkb [winfo children .testSelectionDbox.f_skip] {
	    $chkb configure -state disabled
	}
    }
    wm deiconify $w
    #dbgEndProc [info level [info level]]
    return
}
proc drawUsbCommDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont hUSB_DFU
    set hUSB_DFU 0
    set w .usbCommDbox
    if {[winfo exists $w]} then {
	destroy $w
    }
    toplevel $w -class Dialog
    wm title $w "USB Port Connection"
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr $w.f_buttons
    frame $fr -relief groove -bd 2 -width 400 -height 200
    button $fr.b_open -text "Open" -font $flipFont -command {set hUSB_DFU [USB_DFU_LocateAndOpenDevice $::deviceArray(usb_dfu_default_product_id)]} -bd 3 -state normal
    setBalloon $fr.b_open "Opens the USB device"
    button $fr.b_close -text "Close" -font $flipFont -command {ptclCancelUSBComm} -bd 3 -state disabled
    setBalloon $fr.b_close "Closes the USB device"
    button $fr.b_cancel -text "Cancel" -font $flipFont -command "wm withdraw $w" -bd 2
    setBalloon $fr.b_cancel "Closes the dialog box"
    pack configure $fr.b_open $fr.b_close $fr.b_cancel -side left -padx 10 -pady 5
    pack configure $fr -expand 1 -fill both -padx 5 -pady 5
    #dbgEndProc [info level [info level]]
    return
}
proc drawRs232CommDbox {ProtocolList} {
    #dbgBeginProc [info level [info level]]
    global flipStates tcl_platform port baud baudList prot projDir protcl
    global flipFont
    set w .rs232CommDbox
    if {[winfo exists $w]} then {
	destroy $w
    }
    if {[info exists prot]} then {
	unset prot
    }
    toplevel $w -class Dialog
    wm title $w RS232
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr $w.f_port
    frame $fr -relief flat
    label $fr.l_port -text "Port:" -width 10 -font $flipFont
    setBalloon $fr.l_port "Port selection"
    switch $tcl_platform(platform) {
    windows {
	    set flipStates(comList) {}
	    for {set i 1} {$i <= 20} {incr i} {
		if {! [catch {set devId [open COM$i RDWR]} err_id]} then {
		    close $devId
		    lappend flipStates(comList) COM$i
		}
	    }
	    #dbgShowVar "flipStates(comList) = $flipStates(comList)"
	    if {$flipStates(comList) != ""} then {
		set port [lindex $flipStates(comList) 0]
		set command [concat tk_optionMenu $fr.portSelect port $flipStates(comList)]
		eval $command
	    }
	}
    unix {
	    switch $tcl_platform(os) {
	    SunOs {
		    set flipStates(comList) {}
		    if {! [catch {set devId [open /dev/ttya RDWR]} err_id]} then {
			close $devId
			lappend flipStates(comList) /dev/ttya
		    }
		    if {! [catch {set devId [open /dev/ttyb RDWR]} err_id]} then {
			close $devId
			lappend flipStates(comList) /dev/ttyb
		    }
		    #dbgShowVar "flipStates(comList) = $flipStates(comList)"
		    if {$flipStates(comList) != ""} then {
			set port [lindex $flipStates(comList) 0]
			set command [concat tk_optionMenu $fr.portSelect port $flipStates(comList)]
			eval $command
		    }
		}
	    Linux {
		    set flipStates(comList) {}
		    for {set i 0} {$i <= 3} {incr i} {
			if {! [catch {set devId [open /dev/ttyS$i RDWR]} err_id]} then {
			    close $devId
			    lappend flipStates(comList) /dev/ttyS$i
			}
		    }
		    #dbgShowVar "flipStates(comList) = $flipStates(comList)"
		    if {$flipStates(comList) != ""} then {
			set port [lindex $flipStates(comList) 0]
			set command [concat tk_optionMenu $fr.portSelect port $flipStates(comList)]
			eval $command
		    }
		}
	    }
	}
    default {
	    log_message "Unknown Tcl platform"
	    return 0
	}
    }
    if {[winfo exists $fr.portSelect]} then {
	setBalloon $fr.portSelect "Actual selected port"
	pack configure $fr.l_port $fr.portSelect -side left
	$fr.portSelect configure -width 10 -font $flipFont
	pack configure $fr -side top
    }
    set fr $w.f_baud
    frame $fr -relief flat
    label $fr.l_baud -text "Baud:" -width 10 -font $flipFont
    setBalloon $fr.l_baud "Baudrate selection"
    set command [concat tk_optionMenu $fr.baudSelect baud $baudList]
    eval $command
    setBalloon $fr.baudSelect "Actual selected baudrate"
    set baud 38400
    pack configure $fr.l_baud $fr.baudSelect -side left
    $fr.baudSelect configure -width 10 -font $flipFont
    pack configure $fr -side top
    set fr $w.f_laptopSync
    frame $fr -relief flat
    checkbutton $fr.b_laptopSync -text "Manual Sync" -font $flipFont -variable flipStates(connectOnlyRS232) -onvalue 1 -offvalue 0 -indicatoron true
    setBalloon $fr.b_laptopSync "Manual Synchronization \n\n If set, you must :\n Click Connect, reset the target HW, then click Sync."
    pack configure $fr.b_laptopSync -side left
    pack configure $fr -side top -anchor e -padx 30
    set fr $w.f_protocol
    frame $fr -relief flat
    label $fr.l_protocol -text "Protocol:" -width 10 -font $flipFont
    setBalloon $fr.l_protocol "Protocol selection"
    set command [concat tk_optionMenu $fr.protocolSelect prot $ProtocolList]
    eval $command
    setBalloon $fr.protocolSelect "Actual protocol selection"
    pack configure $fr.l_protocol $fr.protocolSelect -side left
    $fr.protocolSelect configure -width 10 -font $flipFont
    set prot "Standard"
    set fr $w.f_empty
    frame $fr -relief flat -height 20
    pack configure $fr -side top
    set fr $w.f_buttons
    frame $fr -relief flat
    button $fr.b_connect -text "Connect" -font $flipFont -command {connectRS232 $prot} -bd 3 -state normal
    setBalloon $fr.b_connect "Opens a RS232 port and optionally syncs the target HW"
    button $fr.b_synchro -text "Sync" -font $flipFont -command {ptclSynchroRs232Comm} -bd 3 -state disabled
    setBalloon $fr.b_synchro "Synchronizes FLIP and the target HW"
    button $fr.b_disconnect -text "Disconnect" -font $flipFont -command {ptclCancelRs232Comm} -bd 3 -state disabled
    setBalloon $fr.b_disconnect "Closes the RS232 port"
    button $fr.b_cancel -text "Cancel" -font $flipFont -command "wm withdraw $w" -bd 2
    setBalloon $fr.b_cancel "Closes dialog box\nwithout applying options"
    pack configure $fr.b_connect $fr.b_disconnect $fr.b_synchro $fr.b_cancel -padx 2 -side left
    pack configure $fr -side bottom -fill both
    #dbgEndProc [info level [info level]]
    return
}
proc drawDeviceSelectDbox {} {
    #dbgBeginProc [info level [info level]]
    global deviceList device flipFont
    set w .deviceSelectDbox
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "Device Selection"
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fr $w.f_device
    frame $fr -relief groove -bd 2 -width 200
    label $fr.l_device -text "Device:" -font $flipFont
    setBalloon $fr.l_device "Device selection"
    set command [concat tk_optionMenu $fr.deviceSelect device $deviceList]
    eval $command
    setBalloon $fr.deviceSelect "Actual device selection"
    pack configure $fr.l_device $fr.deviceSelect -side left -pady 10 -padx 10
    $fr.deviceSelect configure -width 15 -font $flipFont
    pack configure $fr -side top -pady 10 -fill x -padx 30
    set fr $w.f_empty
    frame $fr -relief flat -height 20
    pack configure $fr -side top
    set fr $w.f_buttons
    frame $fr
    button $fr.b_ok -text "OK" -command {selectDevice $device} -bd 3 -font $flipFont -state normal
    setBalloon $fr.b_ok "Applies selection\nand closes dialog box"
    button $fr.b_cancel -text "Cancel" -command "wm withdraw $w" -bd 2 -font $flipFont
    setBalloon $fr.b_cancel "Closes dialog box\nwithout applying options"
    pack configure $fr.b_ok $fr.b_cancel -padx 10 -ipadx 10 -pady 10 -side left -anchor e
    pack configure $fr -side bottom -fill y
    #dbgEndProc [info level [info level]]
    return
}
proc cbDboxWakeUp {w} {
    #dbgBeginProc [info level [info level]]
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => just deiconify it"
	wm deiconify $w
	if {$w == ".cmdWindow"} then {
	    focus .cmdWindow.f_actionsLog.text
	} else {
	    focus $w
	}
	update
    } else {
	#dbgShowInfo "$w does not exist => draw it"
	switch $w {
	.partners {
		drawPartnersWindow
		wm deiconify $w
	    }
	.progressBarDbox {
		drawProgressBarDbox
		wm deiconify $w
	    }
	.timersDBox {
		drawTimersDBox
		wm deiconify $w
	    }
	.bufferGotoDbox {
		drawGotoBufferDbox
		wm deiconify $w
	    }
	.bufferModifyDbox {
		drawModifyBufferDbox
		wm deiconify $w
	    }
	.bufferOptionsWindow {
		drawBufferOptionsWindow
		wm deiconify $w
	    }
	.bufferEditWindow {
		drawBufferEditWindow
		wm deiconify $w
	    }
	.bufferFillDBox {
		drawBufferFillDBox
		wm deiconify $w
	    }
	.deviceSpecial {
		drawDeviceSpecial
		wm deiconify $w
	    }
	.deviceErase {
		drawDeviceEraseDbox
		wm deiconify $w
	    }
	.blankCheckDBox {
		drawBlankCheckDbox
		wm deiconify $w
	    }
	.deviceReadDBox {
		drawDeviceReadDbox
		wm deiconify $w
	    }
	.canSetup {
		drawCanSetupDbox
		wm deiconify $w
	    }
	.cmdWindow {
		drawCommandWindow
	    }
	.canNodeConfigDbox {
		drawCanNodeConfigDbox
		wm deiconify $w
	    }
	.configP1P3P4Window {
		drawP1P3P4ConfigDbox
		wm deiconify $w
	    }
	.configOscWindow {
		drawOscillatorConfigDbox
		wm deiconify $w
	    }
	.startAppliDbox {
		drawStartAppliDbox
		wm deiconify $w
	    }
	.rs232canSetup {
		drawRs232canSetupDbox
		wm deiconify $w
	    }
	.usbCommDbox {
		drawUsbCommDbox
		wm deiconify $w
	    }
	.bufferSearchDbox {
		drawSearchBufferDbox
		wm deiconify $w
	    }
	.bufferCopyMoveDbox {
		drawCopyMoveDbox
		wm deiconify $w
	    }
	default {
		log_message "Window $w unknown"
		return 0
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc messageBox {title severity message} {
    global flipStates
    if {$flipStates(mssgBox)} then {
	set parentWindow [focus]
	if {[string length $parentWindow] == 0} then {
	    set parentWindow .
	}
	tk_messageBox -message $message -title $title -type ok -icon $severity -parent $parentWindow
	update idletasks
    }
    return
}
proc displayAbout {} {
    #dbgBeginProc [info level [info level]]
    global projDir version flipFont
    set title "Flip"
    set version $version
    set authors "Atmel"
    set copyright "Copyright (C) 2002, Atmel"
    set comment "Flip: FLexible In-system Programmer"
    set logo "$projDir/images/flip_about.gif"
    set url "www.atmel.com"
    set w .about
    if {[winfo exists $w]} then {
	wm deiconify $w
	focus $w
    } else {
	::about::showAbout -title $title -version $version -copyright $copyright -comment $comment -logo $logo -url $url
    }
    #dbgEndProc [info level [info level]]
    return
}
proc actionsLog_message {message} {
    #dbgBeginProc [info level [info level]]
    global flipFont
    set txt .cmdWindow.f_actionsLog.text
    $txt insert {insert -2char} "$message\n"
    $txt see insert
    #dbgEndProc [info level [info level]]
    return
}
proc log_message {message} {
    global flipFont
    .f_status.l_message configure -text $message -font $flipFont
    update
    return
}
proc drawDeviceEraseDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont gui
    set w .deviceErase
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Erasing Options"
    wm resizable $w 0 0
    wm geometry $w 190x260+[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fErase $w.f_erase
    frame $fErase -bd 2 -relief groove
    set fFull $fErase.f_full
    frame $fFull -relief flat
    set bFull $fFull.b_fullErase
    radiobutton $bFull -text "Full Chip Erase" -variable gui(eraseType) -value "full" -font $flipFont -command {onEraseBlockWidgetChangeGUI "full"}
    setBalloon $bFull "Full Chip Erase"
    pack configure $bFull -side top -anchor w
    set fBlocks $fErase.f_blocks
    frame $fBlocks -relief flat
    set bBlocks $fBlocks.b_blockErase
    radiobutton $bBlocks -text "Erase blocks:" -variable gui(eraseType) -value "blocks" -font $flipFont -state $gui(erasePossibleBlocks) -command {onEraseBlockWidgetChangeGUI "blocks"}
    setBalloon $bBlocks "Erase memory blocks"
    set bBlock0 $fBlocks.b_block0
    checkbutton $bBlock0 -text "block 0" -font $flipFont -variable gui(eraseBlock0) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    set bBlock1 $fBlocks.b_block1
    checkbutton $bBlock1 -text "block 1" -font $flipFont -variable gui(eraseBlock1) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    set bBlock2 $fBlocks.b_block2
    checkbutton $bBlock2 -text "block 2" -font $flipFont -variable gui(eraseBlock2) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    set bBlock3 $fBlocks.b_block3
    checkbutton $bBlock3 -text "block 3" -font $flipFont -variable gui(eraseBlock3) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    set bBlock4 $fBlocks.b_block4
    checkbutton $bBlock4 -text "block 4" -font $flipFont -variable gui(eraseBlock4) -onvalue 1 -offvalue 0 -indicatoron true -state disabled
    pack configure $bBlocks $bBlock0 $bBlock1 $bBlock2 $bBlock3 $bBlock4 -side top
    pack configure $fFull $fBlocks -side top -anchor w
    pack $fErase -side top -padx 10 -pady 10 -fill both
    set fbuttons $w.f_buttons
    frame $fbuttons -relief flat
    button $fbuttons.b_erase -bd 3 -text "Erase" -command {cmdsOnEraseOptionsChange
	cmdsDeviceErase} -font $flipFont
    setBalloon $fbuttons.b_erase "Erases the device memory\nusing the selected options."
    button $fbuttons.b_apply -bd 3 -text "Apply" -command {cmdsOnEraseOptionsChange} -font $flipFont
    setBalloon $fbuttons.b_apply "Activates the selected options.\nNo erasing is done."
    button $fbuttons.b_cancel -bd 2 -text "Close" -command {cmdsForgetEraseOptions
	wm withdraw .deviceErase} -font $flipFont
    setBalloon $fbuttons.b_cancel "Closes the dialog box\nwithout applying options."
    pack configure $fbuttons.b_erase $fbuttons.b_apply $fbuttons.b_cancel -side left -padx 5
    pack configure $fbuttons -side top
    bind $w <Return> {cmdsDeviceErase}
    #dbgEndProc [info level [info level]]
    return
}
proc drawBlankCheckDbox {} {
    #dbgBeginProc [info level [info level]]
    global blankCheckAddr flipFont gui
    set w .blankCheckDBox
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm title $w "Blank Checking Options"
    wm resizable $w 0 0
    wm geometry $w 230x180+[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set blankCheckAddr(start) [format $gui(infoFormat) 0x$blankCheckAddr(start)]
    set blankCheckAddr(end) [format $gui(infoFormat) 0x$blankCheckAddr(end)]
    set fAddr $w.f_addresses
    frame $fAddr -bd 2 -relief groove
    set fStart $fAddr.f_start
    frame $fStart -relief flat
    set lStart $fStart.l_start
    label $lStart -text "Start address:" -font $flipFont -anchor w -width 15
    setBalloon $lStart "Start address (included)\nfor blank checking range"
    set eStart $fStart.e_start
    entry $eStart -textvariable gui(blankCheckMin) -width 6 -font $flipFont
    setBalloon $eStart "Start address value"
    pack $lStart $eStart -side left
    set fEnd $fAddr.f_end
    frame $fEnd -relief flat
    set lEnd $fEnd.l_end
    label $lEnd -text "End address:" -font $flipFont -anchor w -width 15
    setBalloon $lEnd "End address (included)\nfor blank checking range"
    set eEnd $fEnd.e_end
    entry $eEnd -textvariable gui(blankCheckMax) -width 6 -font $flipFont
    setBalloon $eEnd "End address value"
    pack $lEnd $eEnd -side left
    pack $fStart $fEnd -side top -pady 5
    bind $eStart <Return> {cmdsBlankCheck}
    bind $eEnd <Return> {cmdsBlankCheck}
    set fResults $w.f_results
    frame $fResults -bd 2 -relief groove
    setBalloon $fResults "Blank check status:\n no check, pass, fail"
    set lTitle $fResults.l_title
    label $lTitle -text "Blank Check Status:" -font $flipFont
    set lResults $fResults.l_results
    label $lResults -text "no check" -font $flipFont
    pack $lTitle $lResults -side top
    set fbuttons $w.f_buttons
    frame $fbuttons -relief flat
    button $fbuttons.b_check -bd 3 -text "Check" -command {updateGUI onBlankCheckOptionsChange
	cmdsBlankCheck} -font $flipFont
    setBalloon $fbuttons.b_check "Performs blank check between\n (and including) specified addresses"
    button $fbuttons.b_reset -bd 2 -text "Reset" -command {cbOnResetBlankCheck} -font $flipFont
    setBalloon $fbuttons.b_reset "Resets addresses to\nbuffer min/max addresses"
    button $fbuttons.b_cancel -bd 2 -text "Close" -command {wm withdraw .blankCheckDBox} -font $flipFont
    setBalloon $fbuttons.b_cancel "Closes dialog box\nwithout applying options"
    pack $fbuttons.b_check $fbuttons.b_reset $fbuttons.b_cancel -side left -padx 5
    pack $fAddr -side top -fill both -expand true -padx 10 -pady 10
    pack $fResults -side top -fill both -expand true -padx 10
    pack $fbuttons -side top -fill both -expand true -padx 20 -pady 10
    bind $w <Return> {cmdsBlankCheck}
    #dbgEndProc [info level [info level]]
    return
}
proc drawDeviceReadDbox {} {
    #dbgBeginProc [info level [info level]]
    global flipFont gui
    set w .deviceReadDBox
    if {[winfo exists $w]} then {
	return
    }
    toplevel $w -class Dialog
    wm geometry $w 220x130+[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm title $w "Reading Options"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set gui(startReadAddr) [format $gui(infoFormat) 0]
    set gui(endReadAddr) [format $gui(infoFormat) 0x$gui(maxAddr)]
    set fAddr $w.f_addresses
    frame $fAddr -bd 2 -relief groove
    set fStart $fAddr.f_start
    frame $fStart -relief flat
    set lStart $fStart.l_start
    label $lStart -text "Start address:" -font $flipFont -anchor w -width 15
    setBalloon $lStart "Start address (included)\nfor device memory read range"
    set eStart $fStart.e_start
    entry $eStart -textvariable gui(startReadAddr) -width 6 -font $flipFont
    setBalloon $eStart "Start address value"
    pack $lStart $eStart -side left
    set fEnd $fAddr.f_end
    frame $fEnd -relief flat
    set lEnd $fEnd.l_end
    label $lEnd -text "End address:" -font $flipFont -anchor w -width 15
    setBalloon $lEnd "End address (included)\nfor device memory read range"
    set eEnd $fEnd.e_end
    entry $eEnd -textvariable gui(endReadAddr) -width 6 -font $flipFont
    setBalloon $eEnd "End address value"
    pack $lEnd $eEnd -side left
    pack $fStart $fEnd -side top -pady 5
    bind $eStart <Return> {cmdsReadDevice}
    bind $eEnd <Return> {cmdsReadDevice}
    set fResults $w.f_results
    frame $fResults -bd 2 -relief groove
    set lTitle $fResults.l_title
    label $lTitle -text "Read Status:" -font $flipFont
    set lResults $fResults.l_results
    label $lResults -text "no reading" -font $flipFont
    pack $lTitle $lResults -side top
    set fbuttons $w.f_buttons
    frame $fbuttons -relief flat
    button $fbuttons.b_read -bd 3 -text "Read" -command {cmdsOnReadOptionsChange
	cmdsReadDevice} -font $flipFont
    setBalloon $fbuttons.b_read "Reads device memory between\n (and including) specified addresses"
    button $fbuttons.b_reset -bd 2 -text "Reset" -command {cbOnResetReadDBox} -font $flipFont
    setBalloon $fbuttons.b_reset "Resets addresses to\nbuffer min/max addresses"
    button $fbuttons.b_cancel -bd 2 -text "Close" -command {cmdsForgetReadOptions
	wm withdraw .deviceReadDBox} -font $flipFont
    setBalloon $fbuttons.b_cancel "Closes dialog box\nwithout applying options"
    pack $fbuttons.b_read $fbuttons.b_reset $fbuttons.b_cancel -side left -padx 5
    pack $fAddr -side top -fill both -expand true -padx 10 -pady 10
    pack $fbuttons -side top -fill both -expand true -padx 20 -pady 5
    bind $w <Return> {cmdsOnReadOptionsChange
	cmdsReadDevice}
    #dbgEndProc [info level [info level]]
    return
}
proc drawTimersDBox {} {
    #dbgBeginProc [info level [info level]]
    global waitTime flipFont
    set w .timersDBox
    if {[winfo exists $w]} then {
	destroy $w
    }
    toplevel $w -class Dialog
    wm title $w "Timers"
    wm geometry $w 150x90
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fTimers $w.f_timers
    frame $fTimers -bd 2 -relief groove
    set fStd $fTimers.f_std
    frame $fStd -relief flat
    set lStd $fStd.l_std
    label $lStd -text "Standard (ms):" -font $flipFont -anchor w -width 15
    setBalloon $lStd "Standard timeout (in ms)"
    set eStd $fStd.e_std
    entry $eStd -textvariable waitTime(standard) -width 5 -font $flipFont
    setBalloon $eStd "Standard timeout value"
    pack $lStd $eStd -side left
    set fExt $fTimers.f_ext
    frame $fExt -relief flat
    set lExt $fExt.l_ext
    label $lExt -text "Extended (ms):" -font $flipFont -anchor w -width 15
    setBalloon $lExt "Extended timeout (in ms)"
    set eExt $fExt.e_ext
    entry $eExt -textvariable waitTime(extended) -width 5 -font $flipFont
    setBalloon $eExt "Extended timeout value"
    pack $lExt $eExt -side left
    pack config $fStd $fExt -side top
    set fbuttons $w.f_buttons
    frame $fbuttons -relief flat
    button $fbuttons.b_ok -bd 3 -text "OK" -command {cbOnOkTimersDbox} -font $flipFont
    setBalloon $fbuttons.b_ok "Applies specified options"
    pack $fbuttons.b_ok -side left -padx 55
    pack $fTimers -side top -fill both -expand true -padx 5 -pady 5
    pack $fbuttons -side top -fill both -expand true -padx 5 -pady 5
    bind $w <Return> {cbOnOkTimersDbox}
    bind $eStd <Return> {cbOnOkTimersDbox}
    bind $eExt <Return> {cbOnOkTimersDbox}
    #dbgEndProc [info level [info level]]
    return
}
#david eseo
proc drawRs232canSetupDbox {} {
    #dbgBeginProc [info level [info level]]
    global atmelProtocol canAcc flipFont tcl_platform
    global canPort canBaud flipStates baudList
    set w .rs232canSetup
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "Controller Area Network Setup"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fMain $w.f_main
    frame $fMain -relief raised -bd 2
    set f0 $fMain.f_0
    frame $f0 -relief groove -bd 2
    set f1 $fMain.f_1
    frame $f1 -relief groove -bd 2
    set f2 $fMain.f_2
    frame $f2 -relief groove -bd 2
    set f3 $f1.f_3
    frame $f3
    set f4 $f1.f_4
    frame $f4 -width 55
    set f5 $f1.f_5
    frame $f5
    set f6 $f2.f_6
    frame $f6
    set f7 $f2.f_7
    frame $f7 -width 85
    set f8 $f2.f_8
    frame $f8
    set idLabelList [list "Select_Node :" "Prog_Start :" "Prog_Data :" "Display_Data :" "Write_Command :" "Read_Command :" "Error :"]
    set numberOfIds [llength $idLabelList]
    for {set i 0} {$i < $numberOfIds} {incr i} {
	set f[expr $i + 9] $fMain.f_[expr $i + 9]
	set j f[expr $i + 9]
	frame [subst $$j]
    }
    set f_s $fMain.f_s
    frame $f_s
    set fb $w.f_b
    frame $fb
    switch $tcl_platform(platform) {
    windows {
	    set flipStates(comList) {}
	    for {set i 1} {$i <= 20} {incr i} {
		if {! [catch {set devId [open COM$i RDWR]} err_id]} then {
		    close $devId
		    lappend flipStates(comList) COM$i
		}
	    }
	    #dbgShowVar "flipStates(comList) = $flipStates(comList)"
	    if {$flipStates(comList) != ""} then {
		set port [lindex $flipStates(comList) 0]
		set command [concat tk_optionMenu $f0.portSelect port $flipStates(comList)]
		eval $command
	    }
	}
    unix {
	    switch $tcl_platform(os) {
	    SunOs {
		    set port /dev/ttya
		    tk_optionMenu $f0.portSelect port /dev/ttya /dev/ttyb
		}
	    Linux {
		    set port /dev/ttyS0
		    tk_optionMenu $f0.portSelect port /dev/ttyS0 /dev/ttyS1 /dev/ttyS2 /dev/ttyS3
		}
	    }
	}
    default {
	    log_message "Unknown Tcl platform"
	    return 0
	}
    }
    tk_optionMenu $f0.baudSelect baud 115200 57600 38400 19200 9600 4800 2400
    set baud 38400
    setBalloon $f0.baudSelect "Actual selected baudrate"
    label $f0.l_port -text "Port" -width 6 -font $flipFont
    label $f0.l_baud -text "Baud Rate" -width 12 -font $flipFont
    pack configure $f0.l_port $f0.portSelect $f0.l_baud $f0.baudSelect -side left
    label $f5.l_baud -text "Can Bit Rate" -width 15 -font $flipFont
    tk_optionMenu $f5.baudSelect canBaud 20k 100k 125k 250k 500k 1000k
    set canBaud 500k
    pack configure $f5.l_baud $f5.baudSelect -side left -anchor e
    setBalloon $f5.baudSelect "CAN  actual selected bit rate"
    pack configure $f3 $f4 $f5 -side left -pady 5
    label $f6.l_cris -text "CRIS" -anchor w -font $flipFont -fg blue
    setBalloon $f6.l_cris "CAN Relocatable Identifier Segment"
    entry $f6.e_cris -textvariable ::deviceArray(crisConnect) -font $flipFont -state normal -width 4 -fg blue
    setBalloon $f6.e_cris "CRIS hexadecimal value"
    pack configure $f6.l_cris $f6.e_cris -side left -padx 5
    label $f8.l_node -text "Node" -anchor w -font $flipFont
    entry $f8.e_node -textvariable ::deviceArray(nnbConnect) -font $flipFont -state normal -width 4
    setBalloon $f8.e_node "Node number hexadecimal value"
    pack configure $f8.l_node $f8.e_node -side left -padx 5
    pack configure $f8 $f7 $f6 -side left -pady 5
    pack configure $f0 $f1 $f2 -side top -padx 20 -pady 5 -fill x
    set idValueList [list atmelProtocol(ci_select_node) atmelProtocol(ci_prog_start) atmelProtocol(ci_prog_data) atmelProtocol(ci_display_data) atmelProtocol(ci_write_command) atmelProtocol(ci_read_command) atmelProtocol(ci_error)]
    for {set i 0} {$i < [llength $idLabelList]} {incr i} {
	set j f[expr $i + 9]
	label [subst $$j].l_$i -text [lindex $idLabelList $i] -anchor w -font $flipFont -width 18
	label [subst $$j].l_val$i -text 0x$::deviceArray(crisConnect)[subst $[lindex $idValueList $i]] -anchor w -font $flipFont -fg blue
	pack configure [subst $$j].l_$i [subst $$j].l_val$i -side left
	pack configure [subst $$j] -side top
    }
    pack configure $f_s -pady 5
    button $fb.b_comm -text "Init Comm" -font $flipFont -command {ptclInitComm} -bd 3 -state normal
    setBalloon $fb.b_comm "Opens Communication"
    #setBalloon $fb.b_synchro "Synchronizes Flip and device"
    button $fb.b_start -text "Node Connect" -command {updateCis
	ptclSelectNode} -bd 3 -state disabled
    setBalloon $fb.b_start "Starts communication with node $::deviceArray(nnbConnect)"
    button $fb.b_cancel -text "Cancel" -font $flipFont -command "wm withdraw $w" -bd 3
    setBalloon $fb.b_cancel "Closes dialog box\nwithout applying options"
    frame $fb.f_bspace1 -width 25
    frame $fb.f_bspace2 -width 25
    pack configure $fb.b_comm $fb.f_bspace1 $fb.b_start $fb.f_bspace2 $fb.b_cancel -side left
    pack configure $fMain $fb -side top -padx 5 -pady 5 -expand 1
    bind $f6.e_cris <Return> {
	if {[isValidHexaInput [%W get]]} then {
	    set atmelProtocol(cris) [%W get]
	    updateCis
	}
    }
    bind $f8.e_node <Return> {
	isValidHexaInput [%W get]
    }
    #dbgEndProc [info level [info level]]
}
proc updateCis {} {
    global atmelProtocol
    foreach id {ci_select_node ci_prog_start ci_prog_data ci_display_data ci_write_command ci_read_command ci_error} j {0 1 2 3 4 5 6} {
	set atmelProtocol($id) 0x$::deviceArray(crisConnect)$j
	.rs232canSetup.f_main.f_[expr $j + 9].l_val$j configure -text $atmelProtocol($id)
    }
    return
}
#fin david eseo
proc drawCanSetupDbox {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol canAcc flipFont tcl_platform
    global canPort canBaud flipStates vector
    set w .canSetup
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "Controller Area Network Setup"
    wm resizable $w 0 0
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fMain $w.f_main
    frame $fMain -relief raised -bd 2
    set f1 $fMain.f_1
    frame $f1 -relief groove -bd 2
    set f2 $fMain.f_2
    frame $f2 -relief groove -bd 2
    set f3 $f1.f_3
    frame $f3
    set f4 $f1.f_4
    frame $f4 -width 10
    set f5 $f1.f_5
    frame $f5
    set f6 $f2.f_6
    frame $f6
    set f7 $f2.f_7
    frame $f7 -width 40
    set f8 $f2.f_8
    frame $f8
    set f20 $fMain.f_20
    frame $f20 -relief groove -bd 2
    set f21 $f20.f_21
    frame $f21
    set f22 $f20.f_22
    frame $f22
    set f23 $f21.f_23
    frame $f23 -width 40
    set f24 $f22.f_24
    frame $f24 -width 40
    setBalloon $f20 "If only one PCMCIA slot is used, select slot 0\n even if CANcardX is inserted in slot 1."
    set idLabelList [list "Id_Select_Node :" "Id_Prog_Start :" "Id_Prog_Data :" "Id_Display_Data :" "Id_Write_Command :" "Id_Read_Command :" "Id_Error :"]
    set numberOfIds [llength $idLabelList]
    for {set i 0} {$i < $numberOfIds} {incr i} {
	set f[expr $i + 9] $fMain.f_[expr $i + 9]
	set j f[expr $i + 9]
	frame [subst $$j]
    }
    set f_s $fMain.f_s
    frame $f_s
    set fb $w.f_b
    frame $fb
    label $f3.l_port -text "Port :" -width 6 -font $flipFont
    switch $tcl_platform(platform) {
    windows {
	    set canPort LPT1
	    tk_optionMenu $f3.portSelect canPort LPT1 LPT2
	}
    unix {
	    notImplemented
	}
    default {
	    notImplemented
	}
    }
    pack configure $f3.l_port $f3.portSelect -side left
    label $f5.l_baud -text "Baud :" -width 6 -font $flipFont
    tk_optionMenu $f5.baudSelect canBaud 20k 100k 125k 250k 500k 1000k
    set canBaud 500k
    pack configure $f5.l_baud $f5.baudSelect -side left
    pack configure $f3 $f4 $f5 -side left -pady 5
    label $f6.l_cris -text "CRIS" -anchor w -font $flipFont -fg blue
    setBalloon $f6.l_cris "CAN Relocatable Identifier Segment"
    entry $f6.e_cris -textvariable ::deviceArray(crisConnect) -font $flipFont -state normal -width 4 -fg blue
    setBalloon $f6.e_cris "CRIS hexadecimal value"
    pack configure $f6.l_cris $f6.e_cris -side left -padx 5
    label $f8.l_node -text "Node" -anchor w -font $flipFont
    entry $f8.e_node -textvariable ::deviceArray(nnbConnect) -font $flipFont -state normal -width 4
    setBalloon $f8.e_node "Node number hexadecimal value"
    pack configure $f8.l_node $f8.e_node -side left -padx 5
    pack configure $f8 $f7 $f6 -side left -pady 5
    label $f21.l_slot -text "PCMCIA Slot :" -anchor w -font $flipFont -width 16
    radiobutton $f21.b_s0 -text "0" -variable vector(slot) -value 0 -font $flipFont
    radiobutton $f21.b_s1 -text "1" -variable vector(slot) -value 1 -font $flipFont
    pack configure $f21.l_slot $f23 $f21.b_s0 $f21.b_s1 -side left
    label $f22.l_channel -text "CAN Channel :" -anchor w -font $flipFont -width 16
    radiobutton $f22.b_c0 -text "1" -variable vector(channel) -value 0 -font $flipFont
    radiobutton $f22.b_c1 -text "2" -variable vector(channel) -value 1 -font $flipFont
    pack configure $f22.l_channel $f24 $f22.b_c0 $f22.b_c1 -side left
    pack configure $f21 $f22 -side top
    pack configure $f1 $f2 $f20 -side top -padx 20 -pady 5 -fill x
    set idValueList [list canProtocol(id_select_node) canProtocol(id_prog_start) canProtocol(id_prog_data) canProtocol(id_display_data) canProtocol(id_write_command) canProtocol(id_read_command) canProtocol(id_error)]
    for {set i 0} {$i < [llength $idLabelList]} {incr i} {
	set j f[expr $i + 9]
	label [subst $$j].l_$i -text [lindex $idLabelList $i] -anchor w -font $flipFont -width 18
	label [subst $$j].l_val$i -text 0x$::deviceArray(crisConnect)[subst $[lindex $idValueList $i]] -anchor w -font $flipFont -fg blue
	pack configure [subst $$j].l_$i [subst $$j].l_val$i -side left
	pack configure [subst $$j] -side top
    }
    pack configure $f_s -pady 5
    button $fb.b_init -text "Init" -command {.canSetup.f_b.b_init config -state disabled
	ptclInitCANinterface} -bd 3 -state normal
    setBalloon $fb.b_init "Initializes the CAN interface"
    frame $fb.f_bspace1 -width 30
    button $fb.b_start -text "Node Connect" -command {updateIds
	ptclSelectNode} -bd 3 -state disabled
    setBalloon $fb.b_start "Starts communication with node $::deviceArray(nnbConnect)"
    frame $fb.f_bspace2 -width 30
    button $fb.b_cancel -text "Cancel" -command "wm withdraw $w" -bd 2 -state normal
    pack configure $fb.b_init $fb.f_bspace1 $fb.b_start $fb.f_bspace2 $fb.b_cancel -side left
    pack configure $fMain $fb -side top -padx 5 -pady 5
    bind $f6.e_cris <Return> {
	if {[isValidHexaInput [%W get]]} then {
	    set canProtocol(cris) [%W get]
	    updateIds
	}
    }
    bind $f8.e_node <Return> {
	isValidHexaInput [%W get]
    }
    #dbgEndProc [info level [info level]]
}
proc updateIds {} {
    global canProtocol
    foreach id {id_select_node id_prog_start id_prog_data id_display_data id_write_command id_read_command id_error} j {0 1 2 3 4 5 6} {
	set canProtocol($id) 0x$::deviceArray(crisConnect)$j
	.canSetup.f_main.f_[expr $j + 9].l_val$j configure -text $canProtocol($id)
    }
    return
}
proc working_display {widget show_text fore back} {
    global working_active
    if {$working_active == 0} then {
	return
    }
    if {$show_text > 0} then {
	$widget configure -fg $fore
	set show_text 0
    } else {
	$widget configure -fg $back
	set show_text 1
    }
    after 500 "working_display $widget $show_text $fore $back"
}
proc working_start {widget fore back} {
    global working_active
    set working_active 1
    working_display $widget 0 $fore $back
}
proc working_stop {widget fore back} {
    global working_active
    set working_active 0
    $widget configure -bg $back -fg $fore
}
proc drawCustomWindow {} {
    set w .customWindow
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "FLIP Customized Window"
    wm resizable $w 0 0
    set fCustom $w.f_custom
    frame $fCustom -relief groove -bd 2 -height 300 -width 250
    pack configure $fCustom -fill both -expand 1
    pack propagate $fCustom 0
    return
}
proc addButton {bName bText bCommand} {
    set w .customWindow
    set butt $w.f_custom.$bName
    button $butt -text $bText -command $bCommand
    pack $butt
    return
}
proc addEntry {eName eVariable} {
    set w .customWindow
    set ent $w.f_custom.$eName
    entry $ent -textVariable $eVariable
    pack $ent
    return
}
proc drawPartnersWindow {} {
    #dbgBeginProc [info level [info level]]
    global flipFont
    set partnersList [list Jungo Ixxat Peak Rm Systec Vector]
    set urlList [list "www.jungo.com" "www.ixxat.com" "www.peak-system.com" "www.rmcan.com" "www.systec-electronic.de" "www.vector-informatik.de"]
    set labelsList [list "USB Drivers :" "IXXAT CAN Interface :" "PEAK CAN Interface :" "RM CAN Interface :" "SYSTEC CAN Interface :" "VECTOR CAN Interface :"]
    set w .partners
    if {[winfo exists $w]} then {
	#dbgShowInfo "$w already exists => return"
	#dbgEndProc [info level [info level]]
	return
    }
    toplevel $w -class Dialog
    wm title $w "Third Party Vendors"
    wm resizable $w 0 0
    wm geometry $w +[expr [winfo x .]+100]+[expr [winfo y .]+100]
    wm protocol $w WM_DELETE_WINDOW "wm withdraw $w"
    wm withdraw $w
    set fTop $w.f_top
    frame $fTop -relief raised -bd 2 -height 600 -width 300
    foreach i $partnersList {
	frame $fTop.f_${i}
    }
    set fButtons $w.f_buttons
    frame $fButtons -relief flat
    foreach t $labelsList p $partnersList u $urlList {
	label $fTop.f_${p}.l_${p} -text $t -anchor w -font $flipFont -width 22 -padx 5
	text $fTop.f_${p}.t_${p}WEB -height 1 -width 30 -relief flat -cursor hand2 -foreground blue -font $flipFont -bg [.main cget -background]
	$fTop.f_${p}.t_${p}WEB insert end $u
	$fTop.f_${p}.t_${p}WEB tag add UrlText 1.0 end
	$fTop.f_${p}.t_${p}WEB tag configure UrlText -justify left
	$fTop.f_${p}.t_${p}WEB configure -state disabled
	pack $fTop.f_${p}.l_${p} $fTop.f_${p}.t_${p}WEB -side left
	bind $fTop.f_${p}.t_${p}WEB <ButtonPress-1> [list wwwBrowser $u]
    }
    button $fButtons.b_ok -text "OK" -font $flipFont -command "wm withdraw $w" -bd 3 -state normal
    pack $fButtons.b_ok -pady 5 -anchor e
    foreach i $partnersList {
	pack configure $fTop.f_${i} -expand 1 -fill both -pady 5
    }
    pack configure $fTop $fButtons -side top
    #dbgEndProc [info level [info level]]
    return
}
proc cancelEveryLink {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    if {$flipStates(canNode) == "open"} then {
	catch [ptclSelectNode]
    }
    if {$flipStates(rs232Comm) == "on"} then {
	#dbgShowInfo "Cancelling RS232..."
	catch [ptclCancelRs232Comm]
    } elseif {$flipStates(canComm) == "on"} {
	#dbgShowInfo "Cancelling CAN..."
	catch [ptclCancelCANComm]
    } elseif {$flipStates(usbComm) == "on"} {
	#dbgShowInfo "Cancelling USB..."
	catch [ptclCancelUSBComm]
    }
    catch [wm withdraw .rs232CommDbox]
    catch [wm withdraw .rs232canSetup]
    catch [wm withdraw .usbCommDbox]
    catch [wm withdraw .canSetup]
    #dbgEndProc [info level [info level]]
    return
}
proc initProtocol {prot} {
    #dbgBeginProc [info level [info level]]
    global protocol rs232standard rs232enhanced canstandard projDir
    global vci canProtocol canBoard canAcc txQueue rxQueue rxQAcc
    global protcl flipStates loadConfig bootloaderVerDependent
    set protcl $prot
    clearStatusMessage
    set protFlag 1
    cancelEveryLink
    buildSkipTestList $prot
    foreach P [info procs ptcl*] {
	rename $P ""
    }
    if {$prot == "RS232Standard"} then {
	if {$flipStates(comList) == ""} then {
	    tk_messageBox -message "There is no available serial port\n on your platform. Please fix the problem then\n restart FLIP." -title "RS232 Ports Scan" -type ok -icon error
	    exit
	}
	#dbgShowInfo "RS232 Standard protocol selected."
	set loadConfig(protocol) "initProtocol RS232Standard"
	if {0} then {
	    set bErase .main.f_device.f_sbvbsb.f_sbv.b_erase
	    if {[winfo exists $bErase]} then {
		pack config $bErase -padx 1 -side right
	    }
	}
	source $projDir/tcl/protocol/rs232std.tcl
	set rs232standard(readSSB) ":020000050700F2"
	set protocol(eof) ":00000001FF"
	set protocol(ack) "."
	set protocol(checkSumErr) "X"
	set protocol(wrSecurityError) "P"
	set protocol(rdWrSecurityError) "L"
	#david eseo
	set protocol(name) "rs232"
	#fin david eseo
	set bootloaderVerDependent(version) "XX"
	set bootloaderVerDependent(eeprom) 1
	set bootloaderVerDependent(eb) 1
	set bootloaderVerDependent(startAppli) 1
    } elseif {$prot == "RS232Enhanced"} {
	#dbgShowInfo "RS232 Enhanced protocol selected."
	set loadConfig(protocol) "initProtocol RS232Enhanced"
	if {0} then {
	    set bErase .main.f_device.f_sbvbsb.f_sbv.b_erase
	    if {[winfo exists $bErase]} then {
		pack config $bErase -padx 1 -side right
	    }
	}
	set protocol(eof) ":00000001FF"
	set protocol(ack) "."
	set protocol(checkSumErr) "X"
	set protocol(noSecurity) "P"
	set protocol(rdWrSecurity) "L"
	#david eseo
	set protocol(name) "rs232"
	#fin david eseo
    } elseif {$prot == "CANStandard"} {
	#dbgShowInfo "CAN Standard protocol selected."
	set loadConfig(protocol) "initProtocol CANStandard"
	if {0} then {
	    set bErase .main.f_device.f_sbvbsb.f_sbv.b_erase
	    if {[winfo exists $bErase]} then {
		pack forget $bErase
	    }
	}
	source $projDir/tcl/protocol/canstd.tcl
	set canProtocol(commState) 0
	#david eseo
    } elseif {$prot == "usbcan"} {
	#dbgShowInfo "USB CAN protocol selected."
	set loadConfig(protocol) "initProtocol usbcan"
	if {0} then {
	    set bErase .main.f_device.f_sbvbsb.f_sbv.b_erase
	    if {[winfo exists $bErase]} then {
		pack forget $bErase
	    }
	}
	source $projDir/tcl/protocol/usb/usb_can_protocol.tcl
    } elseif {$prot == "rs232can"} {
	#dbgShowInfo "RS232 Atmel protocol selected."
	if {$flipStates(comList) == ""} then {
	    tk_messageBox -message "There is no available serial port\n on your platform. Please fix the problem then\n restart FLIP." -title "RS232 Ports Scan" -type ok -icon error
	    exit
	}
	set loadConfig(protocol) "initProtocol rs232can"
	set protocol(name) rs232can
	source $projDir/tcl/protocol/rs232can.tcl
	#fin david eso
    } elseif {$prot == "canview"} {
	#dbgShowInfo "CANview protocol selected."
	set loadConfig(protocol) "initProtocol canview"
	set protocol(name) canview
	source $projDir/tcl/protocol/canview.tcl
    } elseif {$prot == "USB_DFU"} {
	#dbgShowInfo "USB DFU protocol selected."
	set loadConfig(protocol) "initProtocol USB_DFU"
	source $projDir/tcl/protocol/usb/usb_dfu_protocol.tcl
    } else {
	set protFlag 0
	log_message "The selected protocol is not defined."
    }
    if {$protFlag} then {
	#dbgEndProc [info level [info level]]
	return $prot
    } else {
	#dbgEndProc [info level [info level]]
	return 0
    }
}
#dbgBeginSrc [info script]
global canProtocol protocol
if {! [info exists protocol(frameLengthW)]} then {
    set protocol(frameLengthW) 8
    set protocol(frameLengthR) 8
}
set canProtocol(mssgId) ""
set canProtocol(mssgLength) 0
set canProtocol(mssg) ""
set canProtocol(id_select_node) 0
set canProtocol(id_prog_start) 1
set canProtocol(id_prog_data) 2
set canProtocol(id_display_data) 3
set canProtocol(id_write_command) 4
set canProtocol(id_read_command) 5
set canProtocol(id_error) 6
proc ptclUpdateOrCompareBuffer {addr6digit action} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set addr 1
    for {set i 0; set j 0} {$i < $canProtocol(mssgLen)} {incr i; incr j 2} {
	if {$action == "update"} then {
	    writeBuffer [format "%06X" [expr $addr6digit + $i]] [string range $canProtocol(mssg) $j [expr $j + 1]]
	} else {
	    set addr -1
	    if {[readBuffer [format "%06X" [expr $addr6digit + $i]]] != [string range $canProtocol(mssg) $j [expr $j + 1]]} then {
		set addr [format "%#06X" [expr $addr6digit + $i]]
		set message "Memory Verify Fail at: $addr"
		log_message $message
		actionsLog_message "Memory Verify Fail at: $addr"
		cmdsResetProgressBar
		#dbgShowInfo "Verify FAIL."
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $addr
}
proc ptclReadBlock {addrLo addrHi {memory "00"} {action "update"}} {
    #dbgBeginProc [info level [info level]]
    global nAddrBits waitTime canProtocol flipStates
    set expNbrOfDataBytes [expr $addrHi - $addrLo + 1]
    set status 1
    set space " "
    set cmd "[format %03X $canProtocol(id_display_data)] 05 $memory "
    set cmd $cmd[string range [format "%04X" $addrLo] 0 1]$space
    set cmd $cmd[string range [format "%04X" $addrLo] 2 3]$space
    set cmd $cmd[string range [format "%04X" $addrHi] 0 1]$space
    set cmd $cmd[string range [format "%04X" $addrHi] 2 3]
    #dbgShowInfo "CAN MESSAGE > $cmd"
    if {! $flipStates(simul)} then {
	if {$canProtocol(hardware) == "CANDY"} then {
	    set cmd "candyPut_C $cmd"
	} elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	    set cmd "vectorPut_C $cmd"
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    set cmd "canpeakPut_C $cmd"
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    set cmd "cansystecPut_C $cmd"
	}
	set state [eval $cmd]
    } else {
	set state 1
    }
    if {$state == 1} then {
	set loBoundUpdate $addrLo
	while {$expNbrOfDataBytes != 0} {
	    #dbgShowVar "expNbrOfDataBytes = $expNbrOfDataBytes"
	    set status [ptclGetAck $waitTime(standard) $canProtocol(id_display_data) 0]
	    if {! $status} then {
		break
	    } else {
		set failAddr [ptclUpdateOrCompareBuffer [format "%#06X" $loBoundUpdate] $action]
		if {($action == "compare") &&($failAddr != -1)} then {
		    set status 0
		    break
		}
		set loBoundUpdate [expr $loBoundUpdate + $canProtocol(mssgLen)]
		set expNbrOfDataBytes [expr $expNbrOfDataBytes - $canProtocol(mssgLen)]
	    }
	}
    } else {
	set message "CAN interface error."
	messageBox "CAN Interface Message" error $message
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclInitCANinterface {} {
    #dbgBeginProc [info level [info level]]
    global flipStates canPort canBaud canProtocol vector
    if {$flipStates(rs232Comm) == "on"} then {
	catch [ptclCancelRs232Comm]
    }
    if {$flipStates(canNode) == "open"} then {
	ptclSelectNode
    }
    if {$flipStates(canComm) == "on"} then {
	ptclCancelCANComm
    }
    switch $canPort {
    LPT1 {
	    set baseAddress 1
	}
    LPT2 {
	    set baseAddress 2
	}
    default {
	    log_message "CAN Port unknown"
	    set state 0
	}
    }
    .f_status.l_message configure -bg red -fg yellow -text "Initializing the CAN interface..."
    update idletasks
    set accCode $::deviceArray(crisConnect)0
    set accMask FFFFFFF8
    if {! $flipStates(simul)} then {
	if {$canProtocol(hardware) == "CANDY"} then {
	    set status [candyInit_C $canBaud "Standard" $accMask $accCode 200 $baseAddress]
	} elseif {$canProtocol(hardware) == "CANCARDX"} {
	    set status [vectorInit_C $canBaud "Standard" $accMask $accCode 200 $vector(hwType) $vector(slot) $vector(channel)]
	} elseif {$canProtocol(hardware) == "CANPARI"} {
	    set status [vectorInit_C $canBaud "Standard" $accMask $accCode 200 $vector(hwType) 0 0]
	} elseif {$canProtocol(hardware) == "CANAC2"} {
	    set status [vectorInit_C $canBaud "Standard" $accMask $accCode 200 $vector(hwType) $vector(slot) $vector(channel)]
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    set status [canpeakInit_C $canBaud "Standard" $accMask $accCode 200]
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    set status [cansystecInit_C $canBaud "Standard" $accMask $accCode 200]
	}
    } else {
	set status 1
    }
    .f_status.l_message configure -bg white -fg black
    if {$status} then {
	set flipStates(canComm) "on"
	log_message "Select CAN Node..."
    } else {
	set flipStates(canComm) "off"
	log_message "CAN Init Fail"
    }
    updateGUI onCanCommStatusModified
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclCheckCanEntries {} {
    set status 1
    if {! [isValidHexaInput $::deviceArray(nnbProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(crisProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc1)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc2)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc3)]} then {
	set status 0
    }
    return $status
}
proc ptclTestCANdy {} {
    #dbgBeginProc [info level [info level]]
    set status [candyTest_C]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclCancelCANComm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates canProtocol
    if {$flipStates(canNode) == "open"} then {
	ptclSelectNode
    }
    if {! $flipStates(simul)} then {
	if {$canProtocol(hardware) == "CANDY"} then {
	    set status [candyClose_C]
	} elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	    set status [vectorClose_C]
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    set status [canpeakClose_C]
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    set status [cansystecClose_C]
	}
    } else {
	set status 1
    }
    if {$status} then {
	log_message "CAN interface disabled"
	set flipStates(canComm) "off"
	updateGUI onAnyCommunicationOff
	updateGUI onCanCommStatusModified
	if {0} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack forget .main.f_buffer.b_memSelect
	    }
	}
    } else {
	log_message "Board Cancel Fail"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSelectNode {} {
    #dbgBeginProc [info level [info level]]
    global flipStates canProtocol waitTime
    set status 0
    set cmd "[format %03X $canProtocol(id_select_node)]  01 $::deviceArray(nnbConnect)"
    #dbgShowInfo "CAN MESSAGE > $cmd"
    set accCode $::deviceArray(crisConnect)0
    set accMask FFFFFFF8
    if {! $flipStates(simul)} then {
	if {$canProtocol(hardware) == "CANDY"} then {
	    candyUpdateMask_C $accMask $accCode
	    set cmd "candyPut_C $cmd"
	} elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	    vectorUpdateMask_C $accMask $accCode
	    set cmd "vectorPut_C $cmd"
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    canpeakUpdateMask_C $accMask $accCode
	    set cmd "canpeakPut_C $cmd"
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    cansystecUpdateMask_C $accMask $accCode "Standard"
	    set cmd "cansystecPut_C $cmd"
	}
	set status [eval $cmd]
	after 200
	if {$status} then {
	    #dbgShowInfo "status = 1"
	    if {[set status [ptclGetAck $waitTime(standard) $canProtocol(id_select_node) 2]]} then {
		set ::deviceArray(bootlId) [string range $canProtocol(mssg) 0 1]
		set canProtocol(commState) [string range $canProtocol(mssg) 2 3]
	    }
	}
    } else {
	set status 1
	if {$canProtocol(commState) == "01"} then {
	    set canProtocol(commState) "00"
	} else {
	    set canProtocol(commState) "01"
	}
    }
    if {$status} then {
	if {0} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
	    }
	}
	if {$canProtocol(commState) == "01"} then {
	    ptclReadBootlVer
	    updateGUI onAnyCommunicationOn
	    updateGUI onCanNodeSelectionOpened
	} else {
	    if {0} then {
		if {[winfo exists .main.f_buffer.b_memSelect]} then {
		    pack forget .main.f_buffer.b_memSelect
		}
	    }
	    updateGUI onAnyCommunicationOff
	    updateGUI onCanNodeSelectionClosed
	}
    } else {
	updateGUI onAnyCommunicationOff
	updateGUI onCanNodeSelectionClosed
	if {0} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack forget .main.f_buffer.b_memSelect
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendIdProgStart {addLo addHi {memory "00"}} {
    #dbgBeginProc [info level [info level]]
    global buffer waitTime canProtocol
    set addLo [cmdsZeroxPrefix $addLo]
    set addHi [cmdsZeroxPrefix $addHi]
    set p "id_prog_start"
    set status 0
    set cmd "[format %03X $canProtocol($p)]  5  $memory  [string range [format %04X $addLo] 0 1]  [string range [format %04X $addLo] 2 3]  [string range [format %04X $addHi] 0 1]  [string range [format %04X $addHi] 2 3]"
    #dbgShowInfo "CAN MESSAGE > $cmd"
    if {$canProtocol(hardware) == "CANDY"} then {
	set cmd "candyPut_C $cmd"
    } elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	set cmd "vectorPut_C $cmd"
    } elseif {$canProtocol(hardware) == "PEAK"} {
	set cmd "canpeakPut_C $cmd"
    } elseif {$canProtocol(hardware) == "SYSTEC"} {
	set cmd "cansystecPut_C $cmd"
    }
    set status [eval $cmd]
    if {$status} then {
	set status [ptclGetAck $waitTime(standard) $canProtocol($p) 0]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgramData {addLo addHi dummyArg} {
    #dbgBeginProc [info level [info level]]
    global buffer waitTime canProtocol
    set dataCount [format %02X [expr $addHi - $addLo + 1]]
    set p "id_prog_data"
    set message ""
    set space " "
    set status 0
    set cmd "[format %03X $canProtocol($p)] $dataCount "
    for {set i $addLo} {$i <= $addHi} {incr i} {
	set message $message${space}[readBuffer [format %06X $i]]
    }
    set cmd $cmd$message
    #dbgShowInfo "CAN MESSAGE > $cmd"
    if {$canProtocol(hardware) == "CANDY"} then {
	set cmd "candyPut_C $cmd"
    } elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	set cmd "vectorPut_C $cmd"
    } elseif {$canProtocol(hardware) == "PEAK"} {
	set cmd "canpeakPut_C $cmd"
    } elseif {$canProtocol(hardware) == "SYSTEC"} {
	set cmd "cansystecPut_C $cmd"
    }
    set status [eval $cmd]
    if {$status} then {
	set status [ptclGetAck $waitTime(standard) $canProtocol($p) 1]
    }
    if {$status} then {
	set mssg [string range $canProtocol(mssg) 0 1]
	if {$mssg == "00"} then {
	    #dbgShowInfo "Got all data."
	} elseif {$mssg == "01"} {
	    #dbgShowInfo "Command FAIL."
	    set message "The bootloader did not understand the FLIP command."
	    messageBox "Programming Information" error $message
	    set status 0
	} elseif {$mssg == "02"} {
	    #dbgShowInfo "Expecting more data..."
	    set status 2
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclGetAck {timeOut mssgId mssgLength} {
    #dbgBeginProc [info level [info level]]
    global extraTimeOut canProtocol errCode
    set status 1
    set errCode 0
    startExtraTimeOutCounter $timeOut
    if {$canProtocol(hardware) == "CANDY"} then {
	while {[candyGet_C 1] == 0} {
	    #dbgShowInfo "Waiting for rxQ..."
	    if {$extraTimeOut == -1} then {
		break
	    }
	    update
	}
    } elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	while {[vectorGet_C] == 0} {
	    #dbgShowInfo "Waiting for rxQ..."
	    if {$extraTimeOut == -1} then {
		break
	    }
	    update
	}
    } elseif {$canProtocol(hardware) == "PEAK"} {
	while {[canpeakGet_C] == 0} {
	    #dbgShowInfo "Waiting for rxQ..."
	    if {$extraTimeOut == -1} then {
		break
	    }
	    update
	}
    } elseif {$canProtocol(hardware) == "SYSTEC"} {
	while {[cansystecGet_C] == 0} {
	    #dbgShowInfo "Waiting for rxQ..."
	    if {$extraTimeOut == -1} then {
		break
	    }
	    update
	}
    }
    if {$extraTimeOut == -1} then {
	set message "Time Out Error."
	messageBox "Communication Information" error $message
	cmdsResetProgressBar
	set errCode -10
	set status 0
    } else {
	stopExtraTimeOutCounter
	if {[expr 0x$canProtocol(mssgLen) <= 8]} then {
	    #dbgShowInfo "CAN MESSAGE < \
		    [format %03X $canProtocol(mssgId)] \
		    [format %02X $canProtocol(mssgLen)] \
		    [string range $canProtocol(mssg) \
		    0 [expr ($canProtocol(mssgLen) * 2) - 1]]"
	} else {
	    #dbgShowInfo "CAN MESSAGE < Illegal message"
	}
	if {$canProtocol(mssgId) == $mssgId} then {
	    if {$canProtocol(mssgLen) == $mssgLength} then {
		set status 1
	    } elseif {$mssgId == $canProtocol(id_display_data)} {
		set status 1
	    } else {
		set message "Unexpected CAN response data length."
		messageBox "CAN Communication" error $message
		cmdsResetProgressBar
		set errCode -11
		set status 0
	    }
	} elseif {$canProtocol(mssgId) == $canProtocol(id_error)} {
	    if {$canProtocol(mssgLen) == 1} then {
		if {[string range $canProtocol(mssg) 0 1] == "00"} then {
		    set message "Software Security Bit set.\n  Cannot access device data."
		    messageBox "Device Information" warning $message
		    cmdsResetProgressBar
		    set errCode -12
		    set status 0
		} else {
		    set message "Got an error message ID from the bootloader\n  but the CAN message data value is not correct."
		    messageBox "CAN Communication" error $message
		    cmdsResetProgressBar
		    set errCode -13
		    set status 0
		}
	    } else {
		set message "Got an error message ID from the bootloader\n  but the CAN message data length is not correct."
		messageBox "CAN Communication" error $message
		cmdsResetProgressBar
		set errCode -13
		set status 0
	    }
	} else {
	    set message "The CAN message ID is not correct."
	    messageBox "CAN Communication" error $message
	    cmdsResetProgressBar
	    set errCode -14
	    set status 0
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBlankCheck {addrLo addrHi {memory "01"}} {
    #dbgBeginProc [info level [info level]]
    global canProtocol waitTime
    set waitTime(standard) 10000
    set addrLo [cmdsZeroxPrefix $addrLo]
    set addrHi [cmdsZeroxPrefix $addrHi]
    if {[string first "0X" $addrLo] == -1} then {
	set addrLo 0X$addrLo
    }
    set status -1
    set space " "
    set cmd "[format %03X $canProtocol(id_display_data)] 05 $memory "
    set cmd $cmd[string range [format "%04X" $addrLo] 0 1]$space
    set cmd $cmd[string range [format "%04X" $addrLo] 2 3]$space
    set cmd $cmd[string range [format "%04X" $addrHi] 0 1]$space
    set cmd $cmd[string range [format "%04X" $addrHi] 2 3]
    #dbgShowInfo "CAN MESSAGE > $cmd"
    if {$canProtocol(hardware) == "CANDY"} then {
	set cmd "candyPut_C $cmd"
    } elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	set cmd "vectorPut_C $cmd"
    } elseif {$canProtocol(hardware) == "PEAK"} {
	set cmd "canpeakPut_C $cmd"
    } elseif {$canProtocol(hardware) == "SYSTEC"} {
	set cmd "cansystecPut_C $cmd"
    }
    set status [eval $cmd]
    if {$status} then {
	set status [ptclGetAck $waitTime(standard) $canProtocol(id_display_data) 0]
	if {$status} then {
	    if {$canProtocol(mssgLen) == 0} then {
		set status -1
	    } elseif {$canProtocol(mssgLen) == 2} {
		set status [string range $canProtocol(mssg) 0 3]
	    } else {
		set message "Invalid bootloader answer on blank check."
		messageBox "CAN Communication" error $message
		set status -2
	    }
	}
    }
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendGet {id args} {
    #dbgBeginProc [info level [info level]]
    global canProtocol waitTime flipStates
    set space " "
    set status 0
    set cmd [format %03X $canProtocol($id)]
    foreach i $args {
	set cmd $cmd$space$i
    }
    #dbgShowInfo "CAN MESSAGE > $cmd"
    if {! $flipStates(simul)} then {
	if {$canProtocol(hardware) == "CANDY"} then {
	    set cmd "candyPut_C $cmd"
	} elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	    set cmd "vectorPut_C $cmd"
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    set cmd "canpeakPut_C $cmd"
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    set cmd "cansystecPut_C $cmd"
	}
	set status [eval $cmd]
	if {$status} then {
	    set status [ptclGetAck $waitTime(standard) $canProtocol($id) 1]
	}
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendOnly {id args} {
    #dbgBeginProc [info level [info level]]
    global canProtocol waitTime flipStates
    set space " "
    set status 0
    set cmd [format %03X $canProtocol($id)]
    foreach i $args {
	set cmd $cmd$space$i
    }
    #dbgShowInfo "CAN MESSAGE > $cmd"
    if {! $flipStates(simul)} then {
	if {$canProtocol(hardware) == "CANDY"} then {
	    set cmd "candyPut_C $cmd"
	} elseif {($canProtocol(hardware) == "CANCARDX") ||($canProtocol(hardware) == "CANPARI")} {
	    set cmd "vectorPut_C $cmd"
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    set cmd "canpeakPut_C $cmd"
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    set cmd "cansystecPut_C $cmd"
	}
	set status [eval $cmd]
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBootlVer {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p bootlVer
    if {[set status [ptclSendGet id_read_command 2 00 00]] == 1} then {
	set ::deviceArray($p) "1."
	set minorPatch ""
	append ::deviceArray($p) [string index $canProtocol(mssg) 0]
	append minorPatch [string index $canProtocol(mssg) 0]
	append ::deviceArray($p) "."
	append ::deviceArray($p) [string index $canProtocol(mssg) 1]
	append minorPatch [string index $canProtocol(mssg) 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	setBootlVerDepFeatures "CAN" $minorPatch
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId1 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p deviceBootId1
    if {[set status [ptclSendGet id_read_command 2 00 01]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId2 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p deviceBootId2
    if {[set status [ptclSendGet id_read_command 2 00 02]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBSB {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p bsb
    if {[set status [ptclSendGet id_read_command 2 01 00]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSBV {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p sbv
    if {[set status [ptclSendGet id_read_command 2 01 01]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSSB {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol expAnsw
    set p ssb
    if {[set status [ptclSendGet id_read_command 2 01 05]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(level) X
	foreach lev {0 1 2} {
	    foreach i $expAnsw(readSSBlev$lev) {
		if {$::deviceArray(ssb) == $i} then {
		    set ::deviceArray(level) $lev
		}
	    }
	}
    }
    updateGUI onSecurityLevelChange
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadEB {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p eb
    if {[set status [ptclSendGet id_read_command 2 01 06]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadManufId {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p manufId
    if {[set status [ptclSendGet id_read_command 2 01 30]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId1 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p deviceId1
    if {[set status [ptclSendGet id_read_command 2 01 31]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId2 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p deviceId2
    if {[set status [ptclSendGet id_read_command 2 01 60]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId3 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p deviceId3
    if {[set status [ptclSendGet id_read_command 2 01 61]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC1 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p btc1
    if {[set status [ptclSendGet id_read_command 2 01 1C]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC2 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p btc2
    if {[set status [ptclSendGet id_read_command 2 01 1D]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC3 {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p btc3
    if {[set status [ptclSendGet id_read_command 2 01 1E]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadNNB {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p nnbProg
    if {[set status [ptclSendGet id_read_command 2 01 1F]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadCRIS {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p crisProg
    if {[set status [ptclSendGet id_read_command 2 01 20]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadHwByte {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol
    set p hsb
    if {[set status [ptclSendGet id_read_command 2 02 00]] == 1} then {
	set ::deviceArray($p) [string range $canProtocol(mssg) 0 1]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(x2Fuse) [expr (0x$::deviceArray(hsb) | 0x7F) >> 7]
	set ::deviceArray(bljbFuse) [expr ((0x$::deviceArray(hsb) | 0xBF) & 0x7F) >> 6]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock0 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    set status [ptclSendGet id_write_command 2 00 00]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    set status [ptclSendGet id_write_command 2 00 20]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    set status [ptclSendGet id_write_command 2 00 40]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock3 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    set status [ptclSendGet id_write_command 2 00 80]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock4 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    set status [ptclSendGet id_write_command 2 00 C0]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclFullChipErase {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    set status [ptclSendGet id_write_command 2 00 FF]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBSB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 00 $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSBV {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 01 $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSSB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 05 $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime canProtocol
    set status [ptclWriteSSB FE]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime canProtocol
    set status [ptclWriteSSB FC]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteEB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 06 $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC1 {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 1C $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC2 {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 1D $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC3 {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 1E $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteNNB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 1F $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteCRIS {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclSendGet id_write_command 3 01 20 $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwByte {{data "X"}} {
    #dbgBeginProc [info level [info level]]
    if {$data == "X"} then {
	set data [format %02X [expr [expr 0x$::deviceArray(hsb) & 0x3F] | [expr 0x$::deviceArray(x2Fuse) << 7] | [expr 0x$::deviceArray(bljbFuse) << 6]]]
    }
    set status [ptclSendGet id_write_command 3 02 00 $data]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclReadNNB]} then {
	    break
	}
	if {! [ptclReadCRIS]} then {
	    break
	}
	if {! [ptclReadBTC1]} then {
	    break
	}
	if {! [ptclReadBTC2]} then {
	    break
	}
	if {! [ptclReadBTC3]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclSetCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclCheckCanEntries]} then {
	    break
	}
	if {! [ptclWriteNNB $::deviceArray(nnbProg)]} then {
	    break
	}
	if {! [ptclWriteCRIS $::deviceArray(crisProg)]} then {
	    break
	}
	if {! [ptclWriteBTC1 $::deviceArray(btc1)]} then {
	    break
	}
	if {! [ptclWriteBTC2 $::deviceArray(btc2)]} then {
	    break
	}
	if {! [ptclWriteBTC3 $::deviceArray(btc3)]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclStartAppli {reset} {
    #dbgBeginProc [info level [info level]]
    if {$reset} then {
	set status [ptclSendOnly id_write_command 2 03 00]
    } else {
	set status [ptclSendOnly id_write_command 4 03 01 00 00]
    }
    updateGUI onAnyCommunicationOff
    updateGUI onCanNodeSelectionClosed
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSetPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set d0 01
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    if {[set status [ptclSendGet id_write_command 3 $d0 $d1 $::deviceArray(${p}_config)]] == 0} then {
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global canProtocol bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set d0 01
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    if {[set status [ptclSendGet id_read_command 2 $d0 $d1]] == 1} then {
		set ::deviceArray(${p}_config) [string range $canProtocol(mssg) 0 1]
		#dbgShowVar "::deviceArray(${p}_config) = \
			$::deviceArray(${p}_config)"
	    } else {
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc getReturn {data} {
    return $data
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global atmelProtocol protocol
global cmd dongle cv
set cv(STB) "C"
set cv(SPB) [format %c 0X0A]
set atmelProtocol(ci_select_node) 0
set atmelProtocol(ci_prog_start) 1
set atmelProtocol(ci_prog_data) 2
set atmelProtocol(ci_display_data) 3
set atmelProtocol(ci_write_command) 4
set atmelProtocol(ci_read_command) 5
set atmelProtocol(ci_error) 6
set atmelProtocol(dongle) FFFF
set ::deviceArray(crisConnect) 00
set cmd(select_node) [format %04X [expr $atmelProtocol(ci_select_node) - 0x$::deviceArray(crisConnect)0]]
set cmd(prog_start) [format %04X [expr $atmelProtocol(ci_prog_start) - 0x$::deviceArray(crisConnect)0]]
set cmd(prog_data) [format %04X [expr $atmelProtocol(ci_prog_data) - 0x$::deviceArray(crisConnect)0]]
set cmd(display_data) [format %04X [expr $atmelProtocol(ci_display_data) - 0x$::deviceArray(crisConnect)0]]
set cmd(write_command) [format %04X [expr $atmelProtocol(ci_write_command) - 0x$::deviceArray(crisConnect)0]]
set cmd(read_command) [format %04X [expr $atmelProtocol(ci_read_command) - 0x$::deviceArray(crisConnect)0]]
set cmd(ciError) [format %04X [expr $atmelProtocol(ci_error) - 0x$::deviceArray(crisConnect)0]]
set dongle [format %04X 0x$atmelProtocol(dongle)]
if {! [info exists protocol(frameLengthW)]} then {
    set protocol(frameLengthW) 8
    set protocol(frameLengthR) 8
}
proc ptclInitComm {} {
    #dbgBeginProc [info level [info level]]
    global canBaud flipStates
    set status [ptclInitRs232Comm]
    if {$status == 1} then {
	set status [ptclInitDongle]
    } else {
	ptclCancelRs232Comm
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclInitRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates port baud baudList prot waitTime loadConfig projDir
    log_message "Selected protocol : $prot Rs232"
    log_message "Initializing Rs232 communication..."
    set sync 0
    #dbgShowVar "port = $port"
    #dbgShowVar "baud = $baud"
    if {![info exists ::sio::devId]} then {
	set ::sio::devId [::sio::openDevice $port $baud async n 8 1 0]
    }
    if {$::sio::devId != 0} then {
	set loadConfig(globals) "global port baud"
	set loadConfig(port) "set port $port"
	set loadConfig(baud) "set baud $baud"
	set loadConfig(initComm) "connectRS232 Standard"
	::sio::setBaud $baud
	set sync 1
    } else {
	catch [unset ::sio::devId]
	updateGUI onRs232CommunicationOff
	updateGUI onAnyCommunicationOff
	set sync -3
	set message "The RS232 port could not be opened."
	messageBox "RS232 Communication" error $message
	log_message "RS232 Communication could not be opened."
    }
    #dbgEndProc [info level [info level]]
    return $sync
}
proc ptclCancelRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    if {[info exists ::sio::devId]} then {
	::sio::closeDevice
	updateGUI onRs232CommunicationOff
	updateGUI onAnyCommunicationOff
    }
    #dbgEndProc [info level [info level]]
    return
}
proc ptclSendFrame {frame} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set ::sio::sioVars(AbortTx) 0
    ::sio::clearRxBuffer
    startTimeOutCounter $waitTime(standard)
    puts -nonewline $::sio::devId $frame
    #dbgEndProc [info level [info level]]
    return $frame
}
proc ptclUpdateOrCompareBuffer {addr6digit action} {
    #dbgBeginProc [info level [info level]]
    global cv
    set addr 1
    set lineIdx 0
    while {[string length $::sio::sioVars(RxBuffer)] != 0} {
	set line [string range $::sio::sioVars(RxBuffer) 0 [string first $cv(SPB) $::sio::sioVars(RxBuffer) 0]]
	for {set i 5; set j 0} {[string range $line $i $i] != $cv(SPB)} {incr i 2; incr j 1} {
	    if {$action == "update"} then {
		writeBuffer [format "%06X" [expr $addr6digit + $lineIdx*8 + $j]] [string range $line $i [expr $i + 1]]
	    } else {
		set addr -1
		if {[readBuffer [format "%06X" [expr $addr6digit + $lineIdx*8 + $j]]] != [string range $line $i [expr $i + 1]]} then {
		    set addr [format "%#06X" [expr $addr6digit + $lineIdx*8 + $j]]
		    set message "Memory Verify Fail at: $addr"
		    log_message $message
		    actionsLog_message "Memory Verify Fail at: $addr"
		    cmdsResetProgressBar
		    #dbgShowInfo "Verify FAIL."
		    break
		}
	    }
	}
	if {($addr != -1) &&($addr != 1)} then {
	    break
	}
	set ::sio::sioVars(RxBuffer) [string replace $::sio::sioVars(RxBuffer) 0 [string first $cv(SPB) $::sio::sioVars(RxBuffer) 0]]
	incr lineIdx
    }
    #dbgEndProc [info level [info level]]
    return $addr
}
proc ptclSelectNode {} {
    #dbgBeginProc [info level [info level]]
    global cv cmd
    #dbgShowInfo "*********** Looping 50 times to clear the error counter ************"
    for {set i 0} {$i < 50} {incr i} {
	ptclSelectNod 0
	update
    }
    #dbgShowInfo "*********** End of clearing error counter loop ************"
    ptclSelectNod 1
    #dbgEndProc [info level [info level]]
    return
}
proc ptclSelectNod {displayCanError} {
    #dbgBeginProc [info level [info level]]
    global flipStates atmelProtocol waitTime readframe
    global dongle sendframe cmd canBaud cv
    set status 1
    set frame "${cv(STB)}${cmd(select_node)}"
    ptclSendFrame "${frame}${::deviceArray(nnbConnect)}${cv(SPB)}"
    if {! [getCmdEcho $frame 10 1000]} then {
	return 0
    }
    set tmp [string range $::sio::sioVars(RxBuffer) end-2 end-1]
    if {$displayCanError} then {
	if {[noCANviewError]} then {
	    set atmelProtocol(commState) $tmp
	    if {$atmelProtocol(commState) == "01"} then {
		if {[winfo exists .main.f_buffer.b_memSelect]} then {
		    pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
		}
		ptclReadBootlVer
		updateGUI onAnyCommunicationOn
		updateGUI onCanNodeSelectionOpened
		log_message "CAN node $::deviceArray(nnbConnect) opened."
		#dbgShowInfo "CAN node $::deviceArray(nnbConnect) opened."
	    } else {
		if {[winfo exists .main.f_buffer.b_memSelect]} then {
		    pack forget .main.f_buffer.b_memSelect
		}
		updateGUI onAnyCommunicationOff
		updateGUI onCanNodeSelectionClosed
		log_message "CAN node $::deviceArray(nnbConnect) closed."
		#dbgShowInfo "CAN node $::deviceArray(nnbConnect) closed."
	    }
	} else {
	    set status 0
	    set flipStates(anyComm) "off"
	    updateGUI onAnyCommunicationOff
	}
    }
    #dbgShowVar "status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendIdProgStart {addLo addHi {memory "00"}} {
    #dbgBeginProc [info level [info level]]
    global cv cmd
    set status 1
    set frame "${cv(STB)}${cmd(prog_start)}"
    set addrStr "[format %04X 0x$addLo][format %04X 0x$addHi]"
    ptclSendFrame "${frame}${memory}${addrStr}${cv(SPB)}"
    if {! [getCmdEcho $frame 0 1000]} then {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgramData {addLo addHi dummyArg} {
    #dbgBeginProc [info level [info level]]
    global cv cmd
    set status 1
    set frame "${cv(STB)}${cmd(prog_data)}"
    set fullFrame $frame
    for {set i $addLo} {$i <= $addHi} {incr i} {
	set fullFrame ${fullFrame}[readBuffer [format "%06X" $i]]
    }
    #dbgShowVar "frame = $fullFrame"
    ptclSendFrame "${fullFrame}${cv(SPB)}"
    if {! [getCmdEcho $frame 8 3000]} then {
	return 0
    }
    set tmp [string range $::sio::sioVars(RxBuffer) end-2 end-1]
    if {$tmp == "00"} then {
	set status 1
    } elseif {$tmp == "01"} {
	set status 0
    } elseif {$tmp == "02"} {
	set status 2
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBlock {addrLo addrHi {memory "00"} {action "update"}} {
    #dbgBeginProc [info level [info level]]
    global cv cmd
    set status 1
    set mod [expr ($addrHi - $addrLo + 1) % 8]
    set nbFrames [expr ($addrHi - $addrLo + 1) / 8]
    if {$mod} then {
	set nbChars [expr ($nbFrames * (5+16+1)) + 5 + ($mod * 2) + 1]
    } else {
	set nbChars [expr $nbFrames * (5+16+1)]
    }
    #dbgShowVar "Expected number of chars = $nbChars"
    set addrStr "[format %04X $addrLo][format %04X $addrHi]"
    set frame "${cv(STB)}${cmd(display_data)}"
    ptclSendFrame "${frame}${memory}${addrStr}${cv(SPB)}"
    if {! [getCmdEcho $frame $nbChars 4000]} then {
	return 0
    }
    set failAddr [ptclUpdateOrCompareBuffer [format "%#06X" $addrLo] $action]
    if {($action == "compare") &&($failAddr != -1)} then {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBlankCheck {addrLo addrHi {memory "01"}} {
    #dbgBeginProc [info level [info level]]
    global cv cmd
    set status -1
    set addrStr [format %04X "0x$addrLo"][format %04X "0x$addrHi"]
    set frame "${cv(STB)}${cmd(display_data)}"
    ptclSendFrame "${frame}${memory}${addrStr}${cv(SPB)}"
    if {! [getCmdEcho $frame 0 4000]} then {
	set status -2
    } else {
	set tmpStr $::sio::sioVars(RxBuffer)
	if {! [noCANviewError]} then {
	    set status -2
	} elseif {[string length $tmpStr] == 10} {
	    set status [string range $tmpStr end-4 end-1]
	}
    }
    #dbgShowVar "ptclBlankCheck status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock0 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte "" "0000" 3000]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock1 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte "" "0020" 3000]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock2 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte "" "0040" 3000]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclFullChipErase {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte "" "00FF" 10000]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteByte {data cmdBytes {timeOut 1000}} {
    #dbgBeginProc [info level [info level]]
    global cv cmd
    set status 1
    set frame "${cv(STB)}${cmd(write_command)}"
    ptclSendFrame "${frame}${cmdBytes}${data}${cv(SPB)}"
    if {! [getCmdEcho $frame 8 $timeOut]} then {
	set status 0
    } elseif {! [noCANviewError]} {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBSB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "0100"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSBV {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "0101"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev1 {} {
    #dbgBeginProc [info level [info level]]
    global expAnsw
    set status [ptclWriteByte $expAnsw(readSSBlev1Test) "0105"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev2 {} {
    #dbgBeginProc [info level [info level]]
    global expAnsw
    set status [ptclWriteByte $expAnsw(readSSBlev2Test) "0105"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteEB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "0106"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC1 {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "011C"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC2 {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "011D"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC3 {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "011E"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteNNB {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "011F"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteCRIS {data} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "0120"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwByte {{data "X"}} {
    #dbgBeginProc [info level [info level]]
    if {$data == "X"} then {
	set data [format %02X [expr [expr 0x$::deviceArray(hsb) & 0x3F] | [expr 0x$::deviceArray(x2Fuse) << 7] | [expr 0x$::deviceArray(bljbFuse) << 6]]]
    }
    set status [ptclWriteByte $data "0200"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwReset {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $data "0300"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteLJMP {address} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteByte $address "0301"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSetPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set d0 01
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    if {! [ptclWriteByte $::deviceArray(${p}_config) ${d0}${d1}]} then {
		set status 0
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBootlVer {} {
    #dbgBeginProc [info level [info level]]
    global cv flipStates cmd
    set status 1
    set p bootlVer
    set frame "${cv(STB)}${cmd(read_command)}"
    ptclSendFrame "${frame}0000${cv(SPB)}"
    if {! [getCmdEcho $frame 8 1000]} then {
	return 0
    }
    set tmp [string range $::sio::sioVars(RxBuffer) end-2 end-1]
    if {[noCANviewError]} then {
	set c1 [string index $tmp end-1]
	set c2 [string index $tmp end]
	set ::deviceArray($p) "1.$c1.$c2"
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)" 
	setBootlVerDepFeatures "CAN" ${c1}${c2}
    } else {
	set status 0
	set flipStates(anyComm) "off"
	updateGUI onAnyCommunicationOff
    }
    #dbgShowVar "status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId1 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "deviceBootId1" "0001"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId2 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "deviceBootId2" "0002"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBSB {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "bsb" "0100"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSBV {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "sbv" "0101"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSSB {} {
    #dbgBeginProc [info level [info level]]
    global expAnsw
    set status [ptclreadByte "ssb" "0105"]
    set ::deviceArray(level) X
    foreach lev {0 1 2} {
	foreach i $expAnsw(readSSBlev$lev) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) $lev
	    }
	}
    }
    updateGUI onSecurityLevelChange
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadEB {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "eb" "0106"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadManufId {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "manufId" "0130"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId1 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "deviceId1" "0131"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId2 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "deviceId2" "0160"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId3 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "deviceId3" "0161"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC1 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "btc1" "011C"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC2 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "btc2" "011D"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC3 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "btc3" "011E"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadNNB {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "nnbProg" "011F"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadCRIS {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "crisProg" "0120"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadHwByte {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclreadByte "hsb" "0200"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global bootloaderVerDependent cv flipStates cmd
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set d0 01
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    set frame "${cv(STB)}${cmd(read_command)}${d0}${d1}"
	    ptclSendFrame "${frame}${cv(SPB)}"
	    if {! [getCmdEcho $frame 8 1000]} then {
		set status 0
		break
	    }
	    set tmp [string range $::sio::sioVars(RxBuffer) end-2 end-1]
	    if {[noCANviewError]} then {
		set ::deviceArray(${p}_config) $tmp
		#dbgShowVar "::deviceArray(${p}_config) = $::deviceArray(${p}_config)" 
	    } else {
		set status 0
		set flipStates(anyComm) "off"
		updateGUI onAnyCommunicationOff
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc getCmdEcho {echo length timeOut} {
    #dbgBeginProc [info level [info level]]
    global cv extraTimeOut errCode
    set extraTimeOut 1
    set status 1
    set errCode 0
    startExtraTimeOutCounter $timeOut
    if {$length == 0} then {
	while {([string first "$echo" $::sio::sioVars(RxBuffer)] == -1) &&([string first "C0006" $::sio::sioVars(RxBuffer)] == -1)} {
	    if {$extraTimeOut == -1} then {
		set status 0
		break
	    }
	    update
	}
    } else {
	while {([string length $::sio::sioVars(RxBuffer)] < $length) &&([string first "C0006" $::sio::sioVars(RxBuffer)] == -1)} {
	    if {$extraTimeOut == -1} then {
		set status 0
		break
	    }
	    update
	}
    }
    if {$status} then {
	stopExtraTimeOutCounter
	if {[string first "C0006" $::sio::sioVars(RxBuffer)] == 0} then {
	    cmdsResetProgressBar
	    set status 0
	    set errCode -12
	    messageBox "CANview message" error "Security bit set.\nCannot access device memory."
	}
    } else {
	cmdsResetProgressBar
	set errCode -10
	messageBox "CANview message" error "Time out error.\nFLIP and CANview baud rates  may not match.\n"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc noCANviewError {} {
    #dbgBeginProc [info level [info level]]
    global cv
    set status 1
    set frame "${cv(STB)}8"
    ptclSendFrame "${frame}${cv(SPB)}"
    while {[string length $::sio::sioVars(RxBuffer)] < 5} {
	if {$::sio::sioVars(SerialEventOccured) == -1} then {
	    cmdsResetProgressBar
	    set status 0
	    messageBox "CANview message" error "Time out error.\nFLIP and CANview baud rates  may not match.\n"
	    break
	}
	update
    }
    if {$status} then {
	set status 0
	set errStatus [string range $::sio::sioVars(RxBuffer) 2 3]
	switch $errStatus {
	"01" {
		set message "CAN Buffer Overflow."
	    }
	"02" {
		set message "CAN Transmit Timeout."
	    }
	"04" {
		set message "CAN Error Counter Overflow."
	    }
	"08" {
		set message "CAN Bus-Off Error."
	    }
	"10" {
		set message "RS232 Syntax Error."
	    }
	"20" {
		set message "RS232 Format Error."
	    }
	"40" {
		set message "RS232 Buffer Overflow."
	    }
	default {
		set status 1
	    }
	}
	if {! $status} then {
	    messageBox "CANview Message" error "${message}\n FLIP will attempt to  reset the error status."
	    set frame "${cv(STB)}A"
	    ptclSendFrame "${frame}${cv(SPB)}"
	}
    }
    #dbgShowVar "status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclInitDongle {} {
    #dbgBeginProc [info level [info level]]
    global canBaud cv
    set status 1
    set frame "${cv(STB)}E"
    ptclSendFrame "${frame}${cv(SPB)}"
    set status [getCmdEcho $frame 0 1000]
    if {$status} then {
	updateGUI onRs232CommunicationOn
	updateGUI onAnyCommunicationOff
	updateGUI onCanCommStatusModified
	switch $canBaud {
	20k {
		set frame "${cv(STB)}62101"
	    }
	125k {
		set frame "${cv(STB)}62103"
	    }
	250k {
		set frame "${cv(STB)}62104"
	    }
	500k {
		set frame "${cv(STB)}62105"
	    }
	1000k {
		set frame "${cv(STB)}62107"
	    }
	default {
		messageBox "CANview Message" warning "The selected bit rate is not supported by CANview."
		set status 0
	    }
	}
	if {$status} then {
	    ptclSendFrame "${frame}${cv(SPB)}"
	    if {! [getCmdEcho $frame 0 1000]} then {
		set status 0
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclCheckCanEntries {} {
    set status 1
    if {! [isValidHexaInput $::deviceArray(nnbProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(crisProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc1)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc2)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc3)]} then {
	set status 0
    }
    return $status
}
proc ptclReadCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclReadNNB]} then {
	    break
	}
	if {! [ptclReadCRIS]} then {
	    break
	}
	if {! [ptclReadBTC1]} then {
	    break
	}
	if {! [ptclReadBTC2]} then {
	    break
	}
	if {! [ptclReadBTC3]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclSetCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclCheckCanEntries]} then {
	    break
	}
	if {! [ptclWriteNNB $::deviceArray(nnbProg)]} then {
	    break
	}
	if {! [ptclWriteCRIS $::deviceArray(crisProg)]} then {
	    break
	}
	if {! [ptclWriteBTC1 $::deviceArray(btc1)]} then {
	    break
	}
	if {! [ptclWriteBTC2 $::deviceArray(btc2)]} then {
	    break
	}
	if {! [ptclWriteBTC3 $::deviceArray(btc3)]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclStartAppli {reset} {
    #dbgBeginProc [info level [info level]]
    if {$reset} then {
	set status [ptclWriteHwReset]
    } else {
	set status [ptclWriteLJMP 0000]
    }
    updateGUI onAnyCommunicationOff
    updateGUI onCanNodeSelectionClosed
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclreadByte {parameter cmdBytes} {
    #dbgBeginProc [info level [info level]]
    global cv flipStates cmd
    set status 1
    set frame "${cv(STB)}${cmd(read_command)}"
    ptclSendFrame "${frame}${cmdBytes}${cv(SPB)}"
    if {! [getCmdEcho $frame 8 1000]} then {
	return 0
    }
    set tmp [string range $::sio::sioVars(RxBuffer) end-2 end-1]
    if {[noCANviewError]} then {
	set ::deviceArray($parameter) $tmp
	#dbgShowVar "::deviceArray($parameter) = $::deviceArray($parameter)" 
    } else {
	set status 0
	set flipStates(anyComm) "off"
	updateGUI onAnyCommunicationOff
    }
    #dbgShowVar "status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
#dbgShowInfo "Sourcing rs232_0001.tcl"
global rs232standard
writeBuffer rangeOnDeviceProg whole
.bufferOptionsWindow.f_bufferRange.b_bufferRangeLastLoad configure -state disabled
.bufferOptionsWindow.f_bufferRange.f_uDefined.b_bufferRangeUserDefined configure -state disabled
set rs232standard(readBootlVer) ":020000050F00EA"
set rs232standard(ljmp0000) ":020000030301F7"
proc ptclReadDeviceCRAM {addrLo addrHi} {
    #dbgBeginProc [info level [info level]]
    global nAddrBits waitTime
    set frame [append frame ":05000004" [format %04X $addrLo] [format %04X $addrHi] "03"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    startExtraTimeOutCounter $waitTime(standard)
    set status [ptclWaitForDeviceData $addrLo $addrHi]
    #dbgEndProc [info level [info level]]
    return $deviceData
}
proc noBypass {} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(bypassUART) 0
    set ::deviceArray(bypassI2C) 0
    #dbgEndProc [info level [info level]]
    return
}
proc uartBypass {} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(bypassUART) 1
    set ::deviceArray(bypassI2C) 0
    #dbgEndProc [info level [info level]]
    return
}
proc i2cBypass {} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(bypassUART) 0
    set ::deviceArray(bypassI2C) 1
    #dbgEndProc [info level [info level]]
    return
}
proc bypassAll {} {
    #dbgBeginProc [info level [info level]]
    set ::deviceArray(bypassUART) 1
    set ::deviceArray(bypassI2C) 1
    #dbgEndProc [info level [info level]]
    return
}
proc updateBypassBitsDisplay {} {
    #dbgBeginProc [info level [info level]]
    global flipStates color
    if {[winfo exists .main.f_device.f_bypass]} then {
	.main.f_device.f_bypass.cb_bypassUart configure -state normal -selectcolor $color(systemWindow)
	.main.f_device.f_bypass.cb_bypassI2c configure -state normal -selectcolor $color(systemWindow)
    }
    if {! $flipStates(simul)} then {
	set status [ptclReadSSB]
    } else {
	set ::deviceArray(ssb) FF
	set status 1
    }
    if {$status == 1} then {
	set hiNibble [format %02X [expr 0XF0 & 0x$::deviceArray(ssb)]]
	switch $hiNibble {
	F0 {
		noBypass
	    }
	B0 {
		uartBypass
	    }
	70 {
		i2cBypass
	    }
	30 {
		bypassAll
	    }
	default {
		#dbgShowInfo "Wrong bypass byte value." 
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgBypass {bypass} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    switch $bypass {
    uart {
	    set frame ":030000030605BF30"
	}
    i2c {
	    set frame ":0300000306057F70"
	}
    both {
	    set frame ":0300000306053FB0"
	}
    none {
	    set frame ":030000030605FFF0"
	}
    default {
	    set message "Bypass bit error."
	    messageBox "Bypass Message" error $message
	}
    }
    ptclSendFrame $frame
    set ack [ptclGetAck 1000]
    #dbgEndProc [info level [info level]]
    return $ack
}
proc ptclLjmp0000 {} {
    #dbgBeginProc [info level [info level]]
    global rs232standard waitTime
    ptclSendFrame $rs232standard(ljmp0000)
    #dbgEndProc [info level [info level]]
    return
}
proc ptclStartAppli {reset} {
    #dbgBeginProc [info level [info level]]
    global rs232standard
    if {! [cmdsDeviceVerify 000000 000002]} then {
	tk_messageBox -message "CRAM contents not valid\n Please erase and program the device again." -title "CRAM Error" -type ok -icon error
	catch [.main.f_device.f_buttons.b_exec configure -state disabled -bg SystemButtonFace]
    } else {
	ptclSendFrame $rs232standard(ljmp0000)
	ptclCancelRs232Comm
    }
    #dbgEndProc [info level [info level]]
    return
}
proc cbLjmp0000 {} {
    #dbgBeginProc [info level [info level]]
    if {[ptclLjmp0000]} then {
	log_message "Long Jump 0000 done."
	actionsLog_message "Long Jump 0000 done."
    } else {
	log_message "Long Jump 0000 command failed."
    }
    #dbgEndProc [info level [info level]]
    return
}
proc removeProcs {} {
    #dbgBeginProc [info level [info level]]
    if {[info procs ptclReadManufId] == "ptclReadManufId"} then {
	rename ptclReadManufId ""
    }
    if {[info procs ptclReadDeviceId1] == "ptclReadDeviceId1"} then {
	rename ptclReadDeviceId1 ""
    }
    if {[info procs ptclReadDeviceId2] == "ptclReadDeviceId2"} then {
	rename ptclReadDeviceId2 ""
    }
    if {[info procs ptclReadDeviceId3] == "ptclReadDeviceId3"} then {
	rename ptclReadDeviceId3 ""
    }
    if {[info procs ptclReadHwByte] == "ptclReadHwByte"} then {
	rename ptclReadHwByte ""
    }
    if {[info procs ptclReadDevBootId1] == "ptclReadDevBootId1"} then {
	rename ptclReadDevBootId1 ""
    }
    if {[info procs ptclReadDevBootId2] == "ptclReadDevBootId2"} then {
	rename ptclReadDevBootId2 ""
    }
    if {[info procs ptclReadBSB] == "ptclReadBSB"} then {
	rename ptclReadBSB ""
    }
    if {[info procs ptclWriteBSB] == "ptclWriteBSB"} then {
	rename ptclWriteBSB ""
    }
    if {[info procs ptclReadSBV] == "ptclReadSBV"} then {
	rename ptclReadSBV ""
    }
    if {[info procs ptclReadEB] == "ptclReadEB"} then {
	rename ptclReadEB ""
    }
    #dbgEndProc [info level [info level]]
    return
}
proc storeSSBinBuffer {loc} {
    #dbgBeginProc [info level [info level]]
    if {[ptclReadSSB]} then {
	#dbgShowVar "::deviceArray(ssb) = $::deviceArray(ssb)"
	writeBuffer $loc $::deviceArray(ssb)
	#dbgShowVar "buffer($loc) = [readBuffer [subst $loc]]"
    }
    #dbgEndProc [info level [info level]]
    return
}
proc skipTests {} {
    global tclTestDir
    if {[lsearch [namespace children] ::tcltest] == -1} then {
	source $tclTestDir/tcltest.tcl
	package require tcltest
	namespace import ::tcltest::*
    }
    set ::tcltest::skip { \
	    xaf-1.1 \
	    xaf-1.2 \
	    xaf-1.3 \
	    xaf-1.4 \
	    xaf-1.7 \
	    xaf-1.8 \
	    xaf-1.9 \
	    xaf-1.10 \
	    xaf-1.13 \
	    xaf-1.14 \
	    xaf-1.15 \
	    xaf-1.16 \
	    xaf-1.20 \
	    xaf-1.21 \
	    flash-2.20 \
	    flash-2.21 \
	    flash-2.22 \
	    flash-2.23 \
	    flash-2.24 \
	    flash-2.25 \
	    fuse-3.0 \
	    fuse-3.1 \
	    fuse-3.2 \
	    fuse-3.3 \
	    fuse-3.4 \
	    fuse-3.5 \
	    specific-4.0 \
	    specific-4.1 \
	    specific-4.2 \
	    specific-4.3 \
	    specific-4.4 \
	    specific-4.5 \
	    specific-4.6 \
	    specific-4.7 \
	    specific-4.8 \
	    specific-4.9 \
	    specific-4.10 \
	    specific-4.11 \
	    specific-4.12 \
	    specific-4.13 \
	    specific-4.14 \
	    specific-4.15 \
	    specific-4.16 \
	    specific-4.17 \
	    checksum-5.0 \
	    checksum-5.1 \
	    checksum-5.2 \
	    checksum-5.3 \
	    checksum-5.4 \
	    checksum-5.5 \
	    checksum-5.6 \
	    checksum-5.7 \
	    checksum-5.8 \
	    checksum-5.9 \
	    checksum-5.10 \
	    checksum-5.11 \
	    checksum-5.12 \
	    checksum-5.13 \
	    checksum-5.14 \
	    checksum-5.15 \
	    checksum-5.16 \
	    checksum-5.17 \
	    checksum-5.18 \
	    checksum-5.19 \
	    checksum-5.20 \
	    checksum-5.21 \
	    checksum-5.22 \
	    checksum-5.23 \
	    checksum-5.24 \
	    checksum-5.25 \
	    checksum-5.26 \
	    checksum-5.27 \
	    checksum-5.28 \
	    checksum-5.29 \
	    checksum-5.30 \
	    checksum-5.31}
    set ::tcltest::testConstraints(bootloaderId_0001_Only) [string equal $::deviceArray(bootloaderId) "0001"]
}
removeProcs
skipTests
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global atmelProtocol protocol retryPossible
global select_node prog_start prog_data display_data write_command read_command ciError dongle
set atmelProtocol(ci_select_node) 0
set atmelProtocol(ci_prog_start) 1
set atmelProtocol(ci_prog_data) 2
set atmelProtocol(ci_display_data) 3
set atmelProtocol(ci_write_command) 4
set atmelProtocol(ci_read_command) 5
set atmelProtocol(ci_error) 6
set atmelProtocol(dongle) FFFF
set select_node [format %04X [expr $atmelProtocol(ci_select_node) - 0x$::deviceArray(crisConnect)0]]
set prog_start [format %04X [expr $atmelProtocol(ci_prog_start) - 0x$::deviceArray(crisConnect)0]]
set prog_data [format %04X [expr $atmelProtocol(ci_prog_data) - 0x$::deviceArray(crisConnect)0]]
set display_data [format %04X [expr $atmelProtocol(ci_display_data) - 0x$::deviceArray(crisConnect)0]]
set write_command [format %04X [expr $atmelProtocol(ci_write_command) - 0x$::deviceArray(crisConnect)0]]
set read_command [format %04X [expr $atmelProtocol(ci_read_command) - 0x$::deviceArray(crisConnect)0]]
set ciError [format %04X [expr $atmelProtocol(ci_error) - 0x$::deviceArray(crisConnect)0]]
set dongle [format %04X 0x$atmelProtocol(dongle)]
set retryPossible 1
if {! [info exists protocol(frameLengthW)]} then {
    set protocol(frameLengthW) 128
    set protocol(frameLengthR) 128
}
proc ptclInitComm {} {
    global canBaud flipStates
    #dbgBeginProc [info level [info level]]
    set status [ptclInitRs232Comm]
    if {$status == 1} then {
	set CRIS [format %08X 0x$::deviceArray(crisConnect)]
	set bitrate [format %04X [string range $canBaud 0 end-1]]
	set protocol "00"
	set status [ptclInitDongle $bitrate $protocol $CRIS]
    }
    if {$status != 1} then {
	ptclCancelRs232Comm
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclInitRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates port baud baudList prot waitTime extraTimeOut loadConfig projDir
    log_message "Selected protocol : $prot Rs232"
    log_message "Initializing Rs232 communication..."
    set sync 0
    #dbgShowVar "port = $port"
    #dbgShowVar "baud = $baud"
    if {![info exists ::sio::devId]} then {
	set ::sio::devId [::sio::openDevice $port $baud async n 8 1 0]
    }
    if {$::sio::devId != 0} then {
	set loadConfig(globals) "global port baud"
	set loadConfig(port) "set port $port"
	set loadConfig(baud) "set baud $baud"
	set loadConfig(initComm) "connectRS232 Standard"
	::sio::setBaud $baud
	set sync [::sio::autoBaudSync "U" $waitTime(standard)]
	if {$sync == 1} then {
	    updateGUI onRs232CommunicationOn
	    log_message "Rs232 communication initialized."
	    log_message "Dongle Initialization"
	} elseif {$sync == -1} {
	    updateGUI onRs232CommunicationOff
	    set message "The board reply is not correct."
	    messageBox "RS232 Communication" error $message
	    log_message "RS232 Communication Error."
	} else {
	    set message "Time out error."
	    messageBox "RS232 Communication" error $message
	    log_message "RS232 Communication time out."
	    updateGUI onRs232CommunicationOn
	    updateGUI onAnyCommunicationOff
	}
    } else {
	catch [unset ::sio::devId]
	updateGUI onRs232CommunicationOff
	updateGUI onAnyCommunicationOff
	set sync -3
	set message "The RS232 port could not be opened."
	messageBox "RS232 Communication" error $message
	log_message "RS232 Communication could not be opened."
    }
    #dbgEndProc [info level [info level]]
    return $sync
}
proc ptclCancelRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    if {[info exists ::sio::devId]} then {
	::sio::closeDevice
	updateGUI onRs232CommunicationOff
	updateGUI onAnyCommunicationOff
    }
    #dbgEndProc [info level [info level]]
    return
}
proc verifyChecksum {frame} {
    #dbgBeginProc [info level [info level]]
    set sum 0x00
    for {set i 1} {$i < [expr [string length $frame] - 2]} {incr i 2} {
	set byte [string range $frame $i [expr $i + 1]]
	set sum [format "%#04X" [expr $sum + 0x$byte]]
    }
    set cs [format %02X [expr [format "%#04X" [expr ~$sum + 0x01]] & 0xFF]]
    set frameCRC [string range $frame end-1 end]
    set status [string equal $cs $frameCRC]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendFrame {frame} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set ::sio::sioVars(AbortTx) 0
    ::sio::clearRxBuffer
    startTimeOutCounter $waitTime(standard)
    puts $::sio::devId $frame
    #dbgEndProc [info level [info level]]
    return $frame
}
proc ptclGetAck {t frame} {
    #dbgBeginProc [info level [info level]]
    global extraTimeOut errCode readframe sendframe retryPossible dongle ciError
    startExtraTimeOutCounter $t
    set status 1
    set errCode 0
    set sendframe $frame
    while {[string first "\n" $::sio::sioVars(RxBuffer)] == -1} {
	if {$extraTimeOut == -1} then {
	    set message "Time Out Error."
	    cmdsResetProgressBar
	    set errCode -10
	    set status 0
	    break
	}
	update
    }
    if {$status == 1} then {
	stopExtraTimeOutCounter
	set beginIndex [string first ":" $::sio::sioVars(RxBuffer)]
	set endIndex [string first "\n" $::sio::sioVars(RxBuffer)]
	set id [string range $frame 3 6]
	set speByte [string range $frame 7 8]
	set readframe [string range $::sio::sioVars(RxBuffer) $beginIndex [expr $endIndex-1]]
	set ::sio::sioVars(RxBuffer) [string replace $::sio::sioVars(RxBuffer) $beginIndex $beginIndex "!"]
	set ::sio::sioVars(RxBuffer) [string replace $::sio::sioVars(RxBuffer) $endIndex $endIndex "!"]
	set readId [string range $readframe 3 6]
	set readspeByte [string range $readframe 7 8]
	if {[verifyChecksum $readframe] == 1} then {
	    if {($readId == $id) &&($readspeByte == $speByte)} then {
		set status 1
	    } elseif {$readId == $ciError} {
		set message "Software Security Bit set.\n  Cannot access device data."
		set errCode -12
		set status 0
	    } elseif {$readId == $dongle} {
		set status -2
		#dbgShowInfo "getack -2 $retryPossible"
		if {$retryPossible == 0} then {
		    set message "Check sum error."
		    set errCode -15
		}
	    } else {
		set status 0
	    }
	} else {
	    set status -1
	    #dbgShowInfo "getack -1 $retryPossible"
	    if {$retryPossible == 0} then {
		set message "Check sum error."
		set errCode -15
	    }
	}
    }
    if {[info exists message]} then {
	messageBox "Communication Information" error $message
	cmdsResetProgressBar
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclUpdateOrCompareBuffer {addr6digit action} {
    #dbgBeginProc [info level [info level]]
    global readframe
    set addr 1
    set len 0x[string range $readframe 1 2]
    for {set i 0; set j 9} {$i < $len} {incr i; incr j 2} {
	if {$action == "update"} then {
	    writeBuffer [format "%06X" [expr $addr6digit + $i]] [string range $readframe $j [expr $j + 1]]
	} else {
	    set addr -1
	    if {[readBuffer [format "%06X" [expr $addr6digit + $i]]] != [string range $readframe $j [expr $j + 1]]} then {
		set addr [format "%#06X" [expr $addr6digit + $i]]
		set message "Memory Verify Fail at: $addr"
		log_message $message
		actionsLog_message "Memory Verify Fail at: $addr"
		cmdsResetProgressBar
		#dbgShowInfo "Verify FAIL."
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $addr
}
proc ptclSelectNode {} {
    #dbgBeginProc [info level [info level]]
    global flipStates atmelProtocol waitTime readframe
    global retryPossible dongle sendframe select_node canBaud
    set status 1
    set retryPossible 1
    set CRIS [format %08X 0x$::deviceArray(crisConnect)]
    set bitrate [format %04X [string range $canBaud 0 end-1]]
    set protocol "00"
    ptclInitDongle $bitrate $protocol $CRIS
    set frame [append frame ":01" $select_node "00" $::deviceArray(nnbConnect)]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray(bootlId) [string range $readframe 9 10]
	set atmelProtocol(commState) [string range $readframe 11 12]
	if {$atmelProtocol(commState) == "01"} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
	    }
	    ptclReadBootlVer
	    updateGUI onAnyCommunicationOn
	    updateGUI onCanNodeSelectionOpened
	    log_message "CAN node $::deviceArray(nnbConnect) opened."
	} else {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack forget .main.f_buffer.b_memSelect
	    }
	    updateGUI onAnyCommunicationOff
	    updateGUI onCanNodeSelectionClosed
	    log_message "CAN node $::deviceArray(nnbConnect) closed."
	}
    } else {
	set flipStates(anyComm) "off"
	updateGUI onAnyCommunicationOff
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendIdProgStart {addLo addHi {memory "00"}} {
    #dbgBeginProc [info level [info level]]
    global buffer waitTime canProtocol prog_start retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":05" $prog_start "00" $memory [format %04X 0x$addLo] [format %04X 0x$addHi]]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgramData {addLo addHi dummyArg} {
    #dbgBeginProc [info level [info level]]
    global waitTime temp prog_data readframe retryPossible dongle sendframe
    #dbgShowVar "addLo  > $addLo"
    #dbgShowVar "addHi  > $addHi"
    set retryPossible 1
    set len [format "%02X" [expr $addHi - $addLo + 1]]
    set frame [append frame ":" $len $prog_data "00"]
    for {set i $addLo} {$i <= $addHi} {incr i} {
	set frame ${frame}[readBuffer [format "%06X" $i]]
    }
    #dbgShowVar "frame = $frame"
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	if {[string index $readframe end-2] == 0} then {
	    set status 1
	} elseif {[string index $readframe end-2] == 1} {
	    set status 0
	} elseif {[string index $readframe end-2] == 2} {
	    set status 2
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBlock {addrLo addrHi {memory "00"} {action "update"}} {
    #dbgBeginProc [info level [info level]]
    global waitTime display_data retryaddrLo protocol readframe retryPossible dongle sendframe
    set status 1
    set retryPossible 1
    set nbFrame [expr (($addrHi - $addrLo) / $protocol(frameLengthR)) +1]
    #dbgShowVar "nbFrame $nbFrame"
    set frame [append frame ":05" $display_data "00" $memory [format %04X $addrLo] [format %04X $addrHi]]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    while {$nbFrame !=0} {
	set status [ptclGetAck $waitTime(standard) $frame]
	if {$status == 1} then {
	    set failAddr [ptclUpdateOrCompareBuffer [format "%#06X" $addrLo] $action]
	    if {($failAddr == 1) ||($failAddr == -1)} then {
		set status 1
	    } else {
		set status 0
		break
	    }
	    #Frame is correctly read so we can read the following one
	    incr nbFrame -1
	    set addrLo [expr $addrLo + $protocol(frameLengthR)]
	} elseif {$retryPossible} {
	    if {$status == -2} then {
		set retryPossible 0
		set frame [append frame ":05" $display_data "00" $memory [format %04X $addrLo] [format %04X $addrHi]]
		set lFrame [list]
		for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
		    lappend lFrame [string range $frame $i [expr $i + 1]]
		}
		append frame [checkSum $lFrame]
		ptclSendFrame $frame
		set nbFrame [expr (($addrHi - $addrLo) / $protocol(frameLengthR)) +1]
	    } elseif {$status == -1} {
		set retryPossible 0
		set frame [append frame ":05" $display_data "00" $memory [format %04X $addrLo] [format %04X $addrHi]]
		set lFrame [list]
		for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
		    lappend lFrame [string range $frame $i [expr $i + 1]]
		}
		append frame [checkSum $lFrame]
		ptclSendFrame $frame
		set nbFrame [expr (($addrHi - $addrLo) / $protocol(frameLengthR)) +1]
	    } else {
		set status 0
		break
	    }
	} else {
	    set status 0
	    break
	}
	update
    }
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBlankCheck {addrLo addrHi {memory "01"}} {
    #dbgBeginProc [info level [info level]]
    global waitTime readframe display_data retryPossible dongle sendframe
    set retryPossible 1
    set waitTime(standard) 10000
    set frame [append frame ":05" $display_data "00" $memory [format %04X "0x$addrLo"] [format %04X "0x$addrHi"]]
    #dbgShowVar "assembled frame: $frame"
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status == 1]
    }
    if {$status == 1} then {
	if {[string length $readframe] == 15} then {
	    set status [string range $readframe end-5 end-2]
	} else {
	    set status -1
	}
    }
    if {$status == 0} then {
	set status -2
    }
    set waitTime(standard) 3000
    #dbgShowVar "status $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock0 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command sendframe retryPossible dongle
    set waitTime(standard) 10000
    set retryPossible 1
    set frame [append frame ":02" $write_command "000000"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set waitTime(standard) 10000
    set frame [append frame ":02" $write_command "000020"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set waitTime(standard) 10000
    set frame [append frame ":02" $write_command "000040"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclFullChipErase {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set waitTime(standard) 10000
    set frame [append frame ":02" $write_command "0000FF"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    set loadConfig(programDevice) "setupProgramDevice"
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBSB {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "000100" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSBV {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "000101" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "000105FE"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "000105FC"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteEB {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "000106" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC1 {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "00011C" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC2 {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "00011D" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC3 {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "00011E" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteNNB {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "00011F" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteCRIS {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set frame [append frame ":03" $write_command "000120" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		#build the checksum frame: dongle is the command identifier 
		#of dongle and checksum  management    
		#sendframe is the penultimate sent  frame 
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwByte {{data "X"}} {
    #dbgBeginProc [info level [info level]]
    global write_command waitTime retryPossible dongle sendframe
    set retryPossible 1
    if {$data == "X"} then {
	set data [format %02X [expr [expr 0x$::deviceArray(hsb) & 0x3F] | [expr 0x$::deviceArray(x2Fuse) << 7] | [expr 0x$::deviceArray(bljbFuse) << 6]]]
    }
    set frame [append frame ":03" $write_command "000200" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwReset {} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set status 1
    set frame [append frame ":02" $write_command "000300"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteLJMP {address} {
    #dbgBeginProc [info level [info level]]
    global waitTime write_command retryPossible dongle sendframe
    set retryPossible 1
    set status 1
    set frame [append frame ":04" $write_command "000301" $address]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBootlVer {} {
    #dbgBeginProc [info level [info level]]
    global waitTime rs232standard read_command readframe retryPossible dongle sendframe
    set p "bootlVer"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000000"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set c1 [string index $readframe end-3]
	set c2 [string index $readframe end-2]
	set ::deviceArray($p) "1.$c1.$c2"
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)" 
	setBootlVerDepFeatures "CAN" ${c1}${c2}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId1 {} {
    #dbgBeginProc [info level [info level]]
    global testFlag waitTime read_command readframe retryPossible dongle sendframe
    set p "deviceBootId1"
    set status 1
    set retryPossible 1
    if {$testFlag(readDevBootId1)} then {
	set frame [append frame ":02" $read_command "000001"]
	set lFrame [list]
	for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	    lappend lFrame [string range $frame $i [expr $i + 1]]
	}
	append frame [checkSum $lFrame]
	ptclSendFrame $frame
	set status [ptclGetAck $waitTime(standard) $frame]
	if {$status != 1} then {
	    if {$retryPossible} then {
		if {$status == -2} then {
		    set retryPossible 0
		    ptclSendFrame $frame
		    set status [ptclGetAck $waitTime(standard) $frame]
		} elseif {$status == -1} {
		    set retryPossible 0
		    set status [ptclChecksum]
		} else {
		    set status 0
		}
	    } else {
		set status 0
	    }
	    set status [expr $status==1]
	}
	if {$status == 1} then {
	    set ::deviceArray($p) [string range $readframe end-3 end-2]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId2 {} {
    #dbgBeginProc [info level [info level]]
    global testFlag waitTime read_command readframe retryPossible dongle sendframe
    set p "deviceBootId2"
    set status 1
    set retryPossible 1
    if {$testFlag(readDevBootId2)} then {
	set frame [append frame ":02" $read_command "000002"]
	set lFrame [list]
	for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	    lappend lFrame [string range $frame $i [expr $i + 1]]
	}
	append frame [checkSum $lFrame]
	ptclSendFrame $frame
	set status [ptclGetAck $waitTime(standard) $frame]
	if {$status != 1} then {
	    if {$retryPossible} then {
		if {$status == -2} then {
		    set retryPossible 0
		    ptclSendFrame $frame
		    set status [ptclGetAck $waitTime(standard) $frame]
		} elseif {$status == -1} {
		    set retryPossible 0
		    set status [ptclChecksum]
		} else {
		    set status 0
		}
	    } else {
		set status 0
	    }
	    set status [expr $status==1]
	}
	if {$status == 1} then {
	    set ::deviceArray($p) [string range $readframe end-3 end-2]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBSB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "bsb"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000100"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSBV {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "sbv"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000101"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSSB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime logFileId expAnsw read_command readframe retryPossible dongle sendframe
    set p "ssb"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000105"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(level) X
	foreach lev {0 1 2} {
	    foreach i $expAnsw(readSSBlev$lev) {
		if {$::deviceArray(ssb) == $i} then {
		    set ::deviceArray(level) $lev
		}
	    }
	}
	#dbgShowVar "::deviceArray(level) = $::deviceArray(level)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadEB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "eb"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000106"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadManufId {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "manufId"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000130"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "deviceId1"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000131"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "deviceId2"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000160"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId3 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "deviceId3"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000161"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "btc1"
    set retryPossible 1
    set frame [append frame ":02" $read_command "00011C"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "btc2"
    set retryPossible 1
    set frame [append frame ":02" $read_command "00011D"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC3 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "btc3"
    set retryPossible 1
    set frame [append frame ":02" $read_command "00011E"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadNNB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p "nnbProg"
    set retryPossible 1
    set frame [append frame ":02" $read_command "00011F"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadCRIS {} {
    #dbgBeginProc [info level [info level]]
    global waitTime read_command readframe retryPossible dongle sendframe
    set p crisProg
    set retryPossible 1
    set frame [append frame ":02" $read_command "000120"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadHwByte {} {
    #dbgBeginProc [info level [info level]]
    global rs232standard waitTime read_command readframe retryPossible dongle sendframe
    set p "hsb"
    set retryPossible 1
    set frame [append frame ":02" $read_command "000200"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status != 1} then {
	if {$retryPossible} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set status [ptclChecksum]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(x2Fuse) [expr (0x$::deviceArray(hsb) | 0x7F) >> 7]
	set ::deviceArray(bljbFuse) [expr ((0x$::deviceArray(hsb) | 0xBF) & 0x7F) >> 6]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSetPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global bootloaderVerDependent
    global waitTime write_command retryPossible dongle sendframe
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set d0 01
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    set retryPossible 1
	    set frame ""
	    set frame [append frame ":03" $write_command "00" $d0 $d1 $::deviceArray(${p}_config)]
	    set lFrame [list]
	    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
		lappend lFrame [string range $frame $i [expr $i + 1]]
	    }
	    append frame [checkSum $lFrame]
	    ptclSendFrame $frame
	    set status [ptclGetAck $waitTime(standard) $frame]
	    if {$status != 1} then {
		if {$retryPossible} then {
		    if {$status == -2} then {
			set retryPossible 0
			ptclSendFrame $frame
			set status [ptclGetAck $waitTime(standard) $frame]
		    } elseif {$status == -1} {
			set retryPossible 0
			set status [ptclChecksum]
		    } else {
			set status 0
		    }
		} else {
		    set status 0
		}
		set status [expr $status==1]
	    }
	    if {! $status} then {
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global bootloaderVerDependent
    global testFlag waitTime read_command readframe retryPossible dongle sendframe
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set d0 01
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    set retryPossible 1
	    set frame ""
	    set frame [append frame ":02" $read_command "00" $d0 $d1]
	    set lFrame [list]
	    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
		lappend lFrame [string range $frame $i [expr $i + 1]]
	    }
	    append frame [checkSum $lFrame]
	    ptclSendFrame $frame
	    set status [ptclGetAck $waitTime(standard) $frame]
	    if {$status != 1} then {
		if {$retryPossible} then {
		    if {$status == -2} then {
			set retryPossible 0
			ptclSendFrame $frame
			set status [ptclGetAck $waitTime(standard) $frame]
		    } elseif {$status == -1} {
			set retryPossible 0
			set status [ptclChecksum]
		    } else {
			set status 0
		    }
		} else {
		    set status 0
		}
		set status [expr $status==1]
	    }
	    if {$status == 1} then {
		set ::deviceArray(${p}_config) [string range $readframe end-3 end-2]
		#dbgShowVar "::deviceArray(${p}_config) = \
			$::deviceArray(${p}_config)"	
	    } else {
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclChecksum {} {
    #dbgBeginProc [info level [info level]]
    global waitTime dongle sendframe
    set status 1
    set frame [append frame1 ":00" $dongle "00"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $sendframe]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReset {} {
    #dbgBeginProc [info level [info level]]
    global waitTime dongle
    set status 1
    set frame [append frame ":00" $dongle "01"]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclInitDongle {bitrate protocol CRIS} {
    #dbgBeginProc [info level [info level]]
    global waitTime readframe dongle sendframe retryPossible
    set status 1
    set retryPossible 1
    set frame [append frame ":07" $dongle "02" $bitrate $protocol $CRIS]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    append frame [checkSum $lFrame]
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard) $frame]
    #dbgShowInfo "status $status"   
    if {$status != 1} then {
	if {$retryPossible==1} then {
	    if {$status == -2} then {
		set retryPossible 0
		ptclSendFrame $frame
		set status [ptclGetAck $waitTime(standard) $frame]
	    } elseif {$status == -1} {
		set retryPossible 0
		set frame1 [append frame1 ":00" $dongle "0002"]
		ptclSendFrame $frame1
		set status [ptclGetAck $waitTime(standard) $sendframe]
	    } else {
		set status 0
	    }
	} else {
	    set status 0
	}
	set status [expr $status==1]
    }
    if {$status == 1} then {
	set status [string range $readframe end-2 end-2]
    }
    if {$status==1} then {
	log_message "Dongle initialized"
	log_message "File > Load..."
    } else {
	log_message "Dongle Initialization Failed"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclStartBootloader {num_chip} {
    #dbgBeginProc [info level [info level]]
    global waitTime dongle
    set status 1
    set frame [append frame ":01" $dongle "03" $num_chip]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard) $frame]
    if {$status == 1} then {
	if {[string range $readframe 9 10] == $num_chip} then {
	    set status 1
	} else {
	    set status 0
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclCheckCanEntries {} {
    set status 1
    if {! [isValidHexaInput $::deviceArray(nnbProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(crisProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc1)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc2)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc3)]} then {
	set status 0
    }
    return $status
}
proc ptclReadCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclReadNNB]} then {
	    break
	}
	if {! [ptclReadCRIS]} then {
	    break
	}
	if {! [ptclReadBTC1]} then {
	    break
	}
	if {! [ptclReadBTC2]} then {
	    break
	}
	if {! [ptclReadBTC3]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclSetCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclCheckCanEntries]} then {
	    break
	}
	if {! [ptclWriteNNB $::deviceArray(nnbProg)]} then {
	    break
	}
	if {! [ptclWriteCRIS $::deviceArray(crisProg)]} then {
	    break
	}
	if {! [ptclWriteBTC1 $::deviceArray(btc1)]} then {
	    break
	}
	if {! [ptclWriteBTC2 $::deviceArray(btc2)]} then {
	    break
	}
	if {! [ptclWriteBTC3 $::deviceArray(btc3)]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclStartAppli {reset_button} {
    #dbgBeginProc [info level [info level]]
    if {$reset_button} then {
	set status [ptclWriteHwReset]
    } else {
	set status [ptclWriteLJMP 0000]
    }
    updateGUI onAnyCommunicationOff
    updateGUI onCanNodeSelectionClosed
    #dbgEndProc [info level [info level]]
    return $status
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global protocol
if {! [info exists protocol(frameLengthW)]} then {
    set protocol(frameLengthW) 16
    set protocol(frameLengthR) 16
}
proc ptclUpdateBuffer {rxBuffer} {
    global protocol
    #dbgBeginProc [info level [info level]]
    updateBuffer_C $rxBuffer $protocol(frameLengthR)
    #dbgEndProc [info level [info level]]
}
proc expectedSSBLevel {lev ssb} {
    global expAnsw
    if {[lsearch -exact $expAnsw(readSSBlev[subst $lev]Test) $ssb] != -1} then {
	return $ssb
    } else {
	return -1
    }
}
proc ptclInitRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates port baud baudList prot waitTime extraTimeOut loadConfig projDir
    log_message "Selected protocol : $prot Rs232"
    log_message "Initializing Rs232 communication..."
    set sync 0
    #dbgShowVar "port = $port"
    #dbgShowVar "baud = $baud"
    if {![info exists ::sio::devId]} then {
	if {! $flipStates(simul)} then {
	    set ::sio::devId [::sio::openDevice $port $baud async n 8 2 0]
	} else {
	    set ::sio::devId 1
	}
    }
    if {$::sio::devId != 0} then {
	set loadConfig(globals) "global port baud"
	set loadConfig(port) "set port $port"
	set loadConfig(baud) "set baud $baud"
	set loadConfig(initComm) "connectRS232 Standard"
	if {$::deviceArray(specialSynchro) == 0} then {
	    if {! $flipStates(simul)} then {
		::sio::setBaud $baud
		if {! $flipStates(connectOnlyRS232)} then {
		    set sync [::sio::autoBaudSync "U" 3000]
		} else {
		    set sync 0
		    set ::deviceArray(bootloaderId) "0000"
		}
	    } else {
		set sync 1
	    }
	    if {$sync == 1} then {
		set ::deviceArray(bootloaderId) $::sio::sioVars(bootloaderId)
		ptclReadBootlVer
		updateGUI onRs232CommunicationOn
		updateGUI onAnyCommunicationOn
		log_message "Rs232 communication initialized."
		log_message "File > Load..."
	    } elseif {$sync == -1} {
		ptclCancelRs232Comm
		updateGUI onRs232CommunicationOff
		updateGUI onAnyCommunicationOff
		set message "The board reply is not correct."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Communication Error."
	    } elseif {$sync == -2} {
		ptclCancelRs232Comm
		updateGUI onRs232CommunicationOff
		updateGUI onAnyCommunicationOff
		set message "Time out error."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Communication time out."
	    } else {
		updateGUI onRs232CommunicationOn
	    }
	    if {0} then {
		ptclCancelRs232Comm
		updateGUI onRs232CommunicationOff
		updateGUI onAnyCommunicationOff
		set message "Time out error."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Communication time out."
	    }
	} else {
	    if {! $flipStates(simul)} then {
		::sio::setBaud $baud
		startExtraTimeOutCounter 10000
		while {($sync != 1) &&($extraTimeOut != -1)} {
		    set sync [::sio::autoBaudSync "U" 100]
		}
	    } else {
		set ::deviceArray(bootloaderId) "0001"
		set extraTimeOut 0
		set sync 1
	    }
	    if {$extraTimeOut == -1} then {
		set sync -2
		#dbgShowError "  Special sync Time out."
		updateGUI onRs232CommunicationOff
		updateGUI onAnyCommunicationOff
		set message "Time out error."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Communication Time Out."
	    } else {
		if {$sync == 1} then {
		    set ::deviceArray(bootloaderId) $::sio::sioVars(bootloaderId)
		    stopExtraTimeOutCounter
		    updateGUI onRs232CommunicationOn
		    updateGUI onAnyCommunicationOn
		    log_message "Rs232 Communication Synchronized"
		} else {
		    updateGUI onRs232CommunicationOff
		    updateGUI onAnyCommunicationOff
		    set message "The board answer is not correct."
		    messageBox "RS232 Communication" error $message
		    log_message "RS232 Communication Error"
		}
	    }
	}
    } else {
	unset ::sio::devId
	updateGUI onRs232CommunicationOff
	updateGUI onAnyCommunicationOff
	set sync -3
	set message "The RS232 port could not be opened."
	messageBox "RS232 Communication" error $message
	log_message "RS232 Communication could not be opened."
    }
    #dbgEndProc [info level [info level]]
    return $sync
}
proc ptclCancelRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    if {[info exists ::sio::devId]} then {
	::sio::closeDevice
	updateGUI onRs232CommunicationOff
	updateGUI onAnyCommunicationOff
    }
    #dbgEndProc [info level [info level]]
    return
}
proc ptclVerifyBuffer {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set LF [format %c 0x0A]
    while {[set equalPos [string first "=" $::sio::sioVars(RxBuffer)]] != -1} {
	set rxBufferLength [string length $::sio::sioVars(RxBuffer)]
	set addr [string range $::sio::sioVars(RxBuffer) [expr $equalPos - 4] [expr $equalPos - 1]]
	#dbgShowVar "addr = $addr"
	set limit1 [expr $equalPos + 2 * $protocol(frameLengthR)]
	set limit2 [expr $rxBufferLength - 2]
	if {$limit1 <= $limit2} then {
	    set limit $limit1
	} else {
	    set limit $limit2
	}
	for {set i [expr $equalPos + 1]; set j 0} {$i <= $limit} {incr i 2; incr j 1} {
	    if {[readBuffer [format %06X [expr 0x$addr + $j]]] != [string range $::sio::sioVars(RxBuffer) $i [expr $i + 1]]} then {
		return [expr -[expr 0x$addr + $j]]
	    }
	}
	set ::sio::sioVars(RxBuffer) [string replace $::sio::sioVars(RxBuffer) 0 $equalPos]
    }
    #dbgEndProc [info level [info level]]
    return 1
}
proc ptclWaitForDeviceData {addrLo addrHi} {
    #dbgBeginProc [info level [info level]]
    global extraTimeOutId extraTimeOut protocol errCode
    global flipStates tcl_platform
    set status 1
    set errCode 0
    set nBytes [expr $addrHi - $addrLo + 1]
    set rest [expr $nBytes % $protocol(frameLengthR)]
    if {$rest == 0} then {
	set nFrames [expr $nBytes / $protocol(frameLengthR)]
	set nChars [expr 21 + 1 + ($nFrames * (2 * $protocol(frameLengthR) + 6))]
    } else {
	set nFullFrames [expr ($nBytes - $rest) / $protocol(frameLengthR)]
	set nChars [expr 21 + 1 + ($nFullFrames * (2 * $protocol(frameLengthR) + 6)) + ($rest * 2) + 6]
    }
    #dbgShowVar "Expected number of chars = $nChars"
    while {1} {
	if {$::sio::sioVars(AbortTx) == 1} then {
	    stopExtraTimeOutCounter
	    if {$tcl_platform(platform) == "windows"} then {
		set errStr [fconfigure $::sio::devId -lasterror]
		#dbgShowError "Error reading serial port: $errStr"
		tk_messageBox -message "Error reading serial port: $errStr" -title "RS232 Message" -type ok -icon error
	    } else {
		#dbgShowError "Error reading serial port."
		tk_messageBox -message $err_id -title "RS232 Message" -type ok -icon error
	    }
	    set status 0
	    set errCode -17
	    break
	} elseif {[string first "L" $::sio::sioVars(RxBuffer)] != -1} {
	    stopExtraTimeOutCounter
	    set message "Security bit set.\n  Cannot access device data."
	    messageBox "Device Information" error $message
	    set status 0
	    set errCode -12
	    break
	} elseif {[string first "X" $::sio::sioVars(RxBuffer)] != -1} {
	    stopExtraTimeOutCounter
	    set message "Check sum error."
	    messageBox "Device Information" error $message
	    set status 0
	    set errCode -15
	    break
	} elseif {($::sio::sioVars(SerialEventOccured) == -1) ||($extraTimeOut == -1)} {
	    set message "Time out error."
	    messageBox "Device Information" error $message
	    set errCode -10
	    set status 0
	    break
	} elseif {[string length $::sio::sioVars(RxBuffer)] >= $nChars} {
	    #dbgShowVar "  RxBuffer Length = [string length $::sio::sioVars(RxBuffer)]"
	    stopExtraTimeOutCounter
	    break
	}
	update
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendFrame {frame} {
    #dbgBeginProc [info level [info level]]
    global waitTime flipStates
    set ::sio::sioVars(AbortTx) 0
    ::sio::clearRxBuffer
    startTimeOutCounter $waitTime(standard)
    if {! $flipStates(simul)} then {
	puts -nonewline $::sio::devId $frame
    }
    #dbgEndProc [info level [info level]]
    return $frame
}
proc ptclGetAck {t} {
    #dbgBeginProc [info level [info level]]
    global extraTimeOut errCode flipStates
    startExtraTimeOutCounter $t
    set status 1
    set errCode 0
    if {! $flipStates(simul)} then {
	while {[checkEnd_C $::sio::sioVars(RxBuffer)]} {
	    if {$extraTimeOut == -1} then {
		set message "Time Out Error."
		messageBox "Communication Information" error $message
		cmdsResetProgressBar
		set errCode -10
		set status 0
		break
	    }
	    update
	}
	if {$status} then {
	    stopExtraTimeOutCounter
	    set res [getAck_C $::sio::sioVars(RxBuffer)]
	    switch -exact $res {
	    X {
		    set message "Check sum error."
		    set errCode -15
		}
	    P -
	    L {
		    set message "Software Security Bit set.\n  Cannot access device data."
		    set errCode -12
		}
	    Z {
		    set message "CRC check error."
		    set errCode -16
		}
	    }
	    if {[info exists message]} then {
		messageBox "Device Information" error $message
		cmdsResetProgressBar
		set status 0
	    }
	}
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc sendEof {} {
    #dbgBeginProc [info level [info level]]
    global protocol waitTime
    startTimeOutCounter $waitTime(standard)
    puts -nonewline $::sio::devId $protocol(eof)
    flush $::sio::devId
    #dbgEndProc [info level [info level]]
    return
}
proc ptclSynchroRs232Comm {} {
    #dbgBeginProc [info level [info level]]
    global flipStates baud extraTimeOut waitTime
    set sync 0
    updateGUI onRs232CommunicationOff
    updateGUI onAnyCommunicationOff
    if {$::sio::devId == 0} then {
	log_message "RS232 Communication not opened"
    } else {
	if {! [info exists ::deviceArray(specialSynchro)]} then {
	    ::sio::setBaud $baud
	    set sync [::sio::autoBaudSync "U" $waitTime(standard)]
	    if {$sync == 1} then {
		set ::deviceArray(bootloaderId) $::sio::sioVars(bootloaderId)
		devcUpdateDeviceFrame
		updateGUI onRs232CommunicationOn
		updateGUI onAnyCommunicationOn
		log_message "Rs232 Communication Synchronized"
	    } elseif {$sync == -1} {
		set message "The board answer is not correct."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Communication Error."
	    } else {
		set message "Time out error."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Communication Time Out."
	    }
	} else {
	    startExtraTimeOutCounter 10000
	    while {($sync != 1) &&($extraTimeOut != -1)} {
		set sync [::sio::autoBaudSync "U" 100]
	    }
	    if {$extraTimeOut == -1} then {
		set sync -2
		#dbgShowError "  Special sync Time out."
		set message "Time out error."
		messageBox "RS232 Communication" error $message
		log_message "RS232 Time Out."
	    } else {
		if {$sync == 1} then {
		    devcUpdateDeviceFrame
		    stopExtraTimeOutCounter
		    updateGUI onRs232CommunicationOn
		    updateGUI onAnyCommunicationOn
		    log_message "Rs232 Sync PASS."
		} else {
		    set message "The board answer is not correct."
		    messageBox "RS232 Communication" error $message
		    log_message "RS232 Sync FAIL."
		}
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $sync
}
proc wrongFrame {frame} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    ptclSendFrame $frame
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBuildDataFrame {addrLo addrHi recType} {
    #dbgBeginProc [info level [info level]]
    global temp
    set frame [ptclBuildDataFrame_C [format %d $addrLo] [format %d $addrHi] $recType]
    #dbgEndProc [info level [info level]]
    return $frame
}
proc ptclProgramData {addrLo addrHi {memory "00"}} {
    #dbgBeginProc [info level [info level]]
    global waitTime temp
    ptclSendFrame [ptclBuildDataFrame_C [format %d $addrLo] [format %d $addrHi] $memory]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
if {$::deviceArray(name) == "T89C51RD2"} then {
    proc ptclProgramData {addrLo addrHi {memory "00"}} {
	#dbgBeginProc [info level [info level]]
	global waitTime temp gui
	if {! $gui(flowErase)} then {
	    #dbgShowInfo "Executing special RD2 programming"
	    ptclSendFrame [ptclBuildDataFrameFF_C [format %d $addrLo] [format %d $addrHi] "00"]
	    set status [ptclGetAck $waitTime(standard)]
	    if {$status == 1} then {
		ptclSendFrame [ptclBuildDataFrame_C [format %d $addrLo] [format %d $addrHi] "00"]
		set status [ptclGetAck $waitTime(standard)]
	    }
	} else {
	    ptclSendFrame [ptclBuildDataFrame_C [format %d $addrLo] [format %d $addrHi] "00"]
	    set status [ptclGetAck $waitTime(standard)]
	}
	#dbgEndProc [info level [info level]]
	return $status
    }
}
proc ptclEraseBlock0 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    ptclSendFrame ":020000030100FA"
    set status [ptclGetAck $waitTime(standard)]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    ptclSendFrame ":020000030120DA"
    set status [ptclGetAck $waitTime(standard)]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    ptclSendFrame ":020000030140BA"
    set status [ptclGetAck $waitTime(standard)]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock3 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    ptclSendFrame ":0200000301807A"
    set status [ptclGetAck $waitTime(standard)]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock4 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    ptclSendFrame ":0200000301C03A"
    set status [ptclGetAck $waitTime(standard)]
    set waitTime(standard) 3000
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseSBVBSB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    ptclSendFrame ":020000030400F7"
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    ptclSendFrame ":020000030500F6"
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    ptclSendFrame ":020000030501F5"
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBSB {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":030000030600" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSBV {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":030000030601" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclFullChipErase {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set waitTime(standard) 10000
    ptclSendFrame ":0100000307F5"
    set status [ptclGetAck $waitTime(extended)]
    set waitTime(standard) 3000
    set loadConfig(programDevice) "setupProgramDevice"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteOscFuse {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":030000030A02" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSelBootFuse {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":030000030A01" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBLJBFuse {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":030000030A04" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteX2Fuse {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":030000030A08" $data]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBlock {addrLo addrHi {memory "00"} {action "update"}} {
    #dbgBeginProc [info level [info level]]
    global nAddrBits waitTime protocol buffer
    set status 1
    if {($::deviceArray(bootloaderId) == "0001") ||($::deviceArray(bootloaderId) == "0002")} then {
	set memory "03"
    }
    set frame [append frame ":05000004" [format %04X $addrLo] [format %04X $addrHi] $memory]
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    ptclSendFrame [append frame [checkSum $lFrame]]
    set waitTime(standard) 10000
    startExtraTimeOutCounter $waitTime(standard)
    set status [ptclWaitForDeviceData $addrLo $addrHi]
    set waitTime(standard) 3000
    if {$action == "update"} then {
	if {$status == 1} then {
	    ptclUpdateBuffer $::sio::sioVars(RxBuffer)
	}
    } else {
	set LF [format %c 0x0A]
	while {[set equalPos [string first "=" $::sio::sioVars(RxBuffer)]] != -1} {
	    set rxBufferLength [string length $::sio::sioVars(RxBuffer)]
	    set addr [string range $::sio::sioVars(RxBuffer) [expr $equalPos - 4] [expr $equalPos - 1]]
	    #dbgShowVar "addr = $addr"
	    set limit1 [expr $equalPos + 2 * $protocol(frameLengthR)]
	    set limit2 [expr $rxBufferLength - 2]
	    if {$limit1 <= $limit2} then {
		set limit $limit1
	    } else {
		set limit $limit2
	    }
	    for {set i [expr $equalPos + 1]; set j 0} {$i <= $limit} {incr i 2; incr j 1} {
		if {[readBuffer [format %06X [expr 0x$addr + $j]]] != [string range $::sio::sioVars(RxBuffer) $i [expr $i + 1]]} then {
		    set message "Memory Verify Fail at: [format %#06X [expr 0x$addr + $j]]"
		    log_message $message
		    actionsLog_message $message
		    cmdsResetProgressBar
		    #dbgShowInfo "Verify FAIL."
		    set status 0
		    break
		}
	    }
	    if {! $status} then {
		break
	    }
	    set ::sio::sioVars(RxBuffer) [string replace $::sio::sioVars(RxBuffer) 0 $equalPos]
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBlankCheck {addrLo addrHi} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set frame [append frame ":05000004" [format %04X "0x$addrLo"] [format %04X "0x$addrHi"] "01"]
    #dbgShowVar "assembled frame: $frame"
    set lFrame [list]
    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	lappend lFrame [string range $frame $i [expr $i + 1]]
    }
    set waitTime(standard) 10000
    ptclSendFrame [append frame [checkSum $lFrame]]
    set status [ptclGetAck $waitTime(standard)]
    set waitTime(standard) 3000
    if {$status} then {
	if {[string first "." $::sio::sioVars(RxBuffer)] == -1} then {
	    set status [string range $::sio::sioVars(RxBuffer) end-4 end-1]
	} else {
	    set status -1
	}
    } else {
	set status -2
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadEB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(eb)} then {
	set p "eb"
	ptclSendFrame ":020000050706EC"
	set status [ptclGetAck $waitTime(standard)]
	if {$status} then {
	    set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteEB {data} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(eb)} then {
	set frame [append frame ":030000030606" $data]
	set lFrame [list]
	for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
	    lappend lFrame [string range $frame $i [expr $i + 1]]
	}
	ptclSendFrame [append frame [checkSum $lFrame]]
	set status [ptclGetAck $waitTime(standard)]
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclStartAppli {reset} {
    #dbgBeginProc [info level [info level]]
    if {$reset} then {
	ptclSendFrame ":020000030300F8"
    } else {
	ptclSendFrame ":0400000303010000F5"
    }
    ptclCancelRs232Comm
    #dbgEndProc [info level [info level]]
    return
}
proc ptclReadManufId {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set p "manufId"
    ptclSendFrame ":020000050000F9"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId1 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set p "deviceId1"
    ptclSendFrame ":020000050001F8"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId2 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set p "deviceId2"
    ptclSendFrame ":020000050002F7"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId3 {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set p "deviceId3"
    ptclSendFrame ":020000050003F6"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSSB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime logFileId expAnsw
    set p "ssb"
    ptclSendFrame ":020000050700F2"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(level) X
	foreach i $expAnsw(readSSBlev0) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) 0
	    }
	}
	foreach i $expAnsw(readSSBlev1) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) 1
	    }
	}
	foreach i $expAnsw(readSSBlev2) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) 2
	    }
	}
	#dbgShowVar "::deviceArray(level) = $::deviceArray(level)"
    }
    updateGUI onSecurityLevelChange
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBSB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set p "bsb"
    ptclSendFrame ":020000050701F1"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSBV {} {
    #dbgBeginProc [info level [info level]]
    global waitTime
    set p "sbv"
    ptclSendFrame ":020000050702F0"
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadHwByte {} {
    #dbgBeginProc [info level [info level]]
    global rs232standard waitTime flipStates
    set status 1
    if {! $flipStates(simul)} then {
	set p "hsb"
	ptclSendFrame $rs232standard(readHwByte)
	set status [ptclGetAck $waitTime(standard)]
	if {$status} then {
	    set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	    if {[info exists ::deviceArray(selBootFuse)]} then {
		set ::deviceArray(selBootFuse) [expr ((0x$::deviceArray(hsb) | 0xEF) & 0x1F) >> 4]
	    }
	    if {[info exists ::deviceArray(x2Fuse)]} then {
		set ::deviceArray(x2Fuse) [expr (0x$::deviceArray(hsb) | 0x7F) >> 7]
	    }
	    if {[info exists ::deviceArray(bljbFuse)]} then {
		set ::deviceArray(bljbFuse) [expr ((0x$::deviceArray(hsb) | 0xBF) & 0x7F) >> 6]
	    }
	    if {[info exists ::deviceArray(oscFuse)]} then {
		set ::deviceArray(oscFuse) [expr ((0x$::deviceArray(hsb) | 0xDF) & 0x2F) >> 5]
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBootlVer {} {
    #dbgBeginProc [info level [info level]]
    global waitTime rs232standard
    ptclSendFrame $rs232standard(readBootlVer)
    set status [ptclGetAck $waitTime(standard)]
    if {$status} then {
	set c1 [string index $::sio::sioVars(RxBuffer) end-3]
	set c2 [string index $::sio::sioVars(RxBuffer) end-2]
	#dbgShowVar "minorPatch = ${c1}${c2}"
	setBootlVerDepFeatures "RS232_STANDARD" ${c1}${c2}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId1 {} {
    #dbgBeginProc [info level [info level]]
    global testFlag waitTime
    set p "deviceBootId1"
    set status 1
    if {$testFlag(readDevBootId1)} then {
	ptclSendFrame ":020000050E00EB"
	set status [ptclGetAck $waitTime(standard)]
	if {$status} then {
	    set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId2 {} {
    #dbgBeginProc [info level [info level]]
    global testFlag waitTime
    set p "deviceBootId2"
    set status 1
    if {$testFlag(readDevBootId2)} then {
	ptclSendFrame ":020000050E01EA"
	set status [ptclGetAck $waitTime(standard)]
	if {$status} then {
	    set ::deviceArray($p) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	foreach p {p1 p3 p4} data1 {03 04 05} cksum {EF EE ED} {
	    ptclSendFrame ":0200000507${data1}${cksum}"
	    set status [ptclGetAck $waitTime(standard)]
	    if {$status} then {
		set ::deviceArray(${p}_config) [string range $::sio::sioVars(RxBuffer) end-3 end-2]
		#dbgShowVar "::deviceArray(${p}_config) = $::deviceArray(${p}_config)"
	    } else {
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSetPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	foreach p {p1 p3 p4} d1 {02 03 04} {
	    set frame ""
	    set frame [append frame ":0300000306" ${d1} $::deviceArray(${p}_config)]
	    set lFrame [list]
	    for {set i 1} {$i <= [expr [string length $frame] - 2]} {incr i 2} {
		lappend lFrame [string range $frame $i [expr $i + 1]]
	    }
	    ptclSendFrame [append frame [checkSum $lFrame]]
	    set status [ptclGetAck $waitTime(standard)]
	    if {! $status} then {
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
proc USB_CAN_Close {hUSB_CAN} {
    USB_CAN_Close_C [format %08X $hUSB_CAN]
    return
}
proc USB_CAN_ResetPipe {hUSB_CAN pipeNum} {
    USB_CAN_ResetPipe_C [format %08X $hUSB_CAN] [format %02X $pipeNum]
    return
}
proc USB_CAN_ResetDevice {hUSB_CAN} {
    USB_CAN_ResetDevice_C [format %08X $hUSB_CAN]
    return
}
proc USB_CAN_ReadPipe00 {hUSB_CAN setupPacket size} {
    global bufferPipe00read
    set status [USB_CAN_ReadPipe00_C [format %08X $hUSB_CAN] [format %016X $setupPacket] [format %08X $size]]
    return $status
}
proc USB_CAN_WritePipe00 {hUSB_CAN setupPacket size} {
    global bufferPipe00write
    set status [USB_CAN_WritePipe00_C [format %08X $hUSB_CAN] [format %016X $setupPacket] [format %08X $size]]
    return $status
}
proc USB_CAN_StopTransferPipe00 {hUSB_CAN} {
    USB_CAN_StopTransferPipe00_C [format %08X $hUSB_CAN]
    return
}
proc USB_CAN_ReadPipe81 {hUSB_CAN} {
    global bufferPipe81read usbConst
    set bufferPipe81read ""
    set status [USB_CAN_ReadPipe81_C [format %08X $hUSB_CAN] [format %08X 64]]
    return $status
}
proc USB_CAN_StopTransferPipe81 {hUSB_CAN} {
    USB_CAN_StopTransferPipe81_C [format %08X $hUSB_CAN]
    return
}
proc USB_CAN_WritePipe02 {hUSB_CAN} {
    global bufferPipe02write
    set size [expr [string length $bufferPipe02write] / 2]
    set status [USB_CAN_WritePipe02_C [format %08X $hUSB_CAN] [format %08X $size]]
    return $status
}
proc USB_CAN_StopTransferPipe02 {hUSB_CAN} {
    USB_CAN_StopTransferPipe02_C [format %08X $hUSB_CAN]
    return
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global canProtocol protocol retryPossible
global select_node prog_start prog_data display_data write_command read_command ciError dongle
source $projDir/tcl/protocol/usb/usb_can_lib.tcl
source $projDir/tcl/protocol/usb/usb_can_utils.tcl
set canProtocol(id_select_node) 0000
set canProtocol(id_prog_start) 0001
set canProtocol(id_prog_data) 0002
set canProtocol(id_display_data) 0003
set canProtocol(id_write_command) 0004
set canProtocol(id_read_command) 0005
set canProtocol(id_error) 0006
set canProtocol(dongle) FFFF
#Format command identifier ready to send for all the frame of atmel protocol
set select_node [format %04X [expr $canProtocol(id_select_node) - 0x$::deviceArray(crisConnect)0]]
set prog_start [format %04X [expr $canProtocol(id_prog_start) - 0x$::deviceArray(crisConnect)0]]
set prog_data [format %04X [expr $canProtocol(id_prog_data) - 0x$::deviceArray(crisConnect)0]]
set display_data [format %04X [expr $canProtocol(id_display_data) - 0x$::deviceArray(crisConnect)0]]
set write_command [format %04X [expr $canProtocol(id_write_command) - 0x$::deviceArray(crisConnect)0]]
set read_command [format %04X [expr $canProtocol(id_read_command) - 0x$::deviceArray(crisConnect)0]]
set ciError [format %04X [expr $canProtocol(id_error) - 0x$::deviceArray(crisConnect)0]]
set dongle [format %04X 0x$canProtocol(dongle)]
if {! [info exists protocol(frameLengthW)]} then {
    set protocol(frameLengthW) 512
    set protocol(frameLengthR) 512
}
proc ptclInitCANinterface {} {
    global canBaud flipStates canProtocol
    #dbgBeginProc [info level [info level]]
    set status 1
    if {$flipStates(rs232Comm) == "on"} then {
	catch [ptclCancelRs232Comm]
    }
    if {$flipStates(canNode) == "open"} then {
	ptclSelectNode
    }
    if {$flipStates(canComm) == "on"} then {
	ptclCancelCANComm
    }
    .f_status.l_message configure -bg red -fg yellow -text "Initializing the CAN interface..."
    update idletasks
    set res [USB_CAN_LocateAndOpenDevice]
    set status [format "%01d" $res]
    #dbgShowInfo "USB status  > $status"
    if {$status > 0} then {
	set status 1
    }
    if {$status == 1} then {
	#set dongle parameters 
	set CRIS [format %08X 0x$::deviceArray(crisConnect)]
	set bitrate [format %04X [string range $canBaud 0 end-1]]
	set protocol "00"
	set status [ptclInitDongle $bitrate $protocol $CRIS]
    }
    if {$status == 0} then {
	init dongle failed
	#Close the USB COM
	USB_CAN_Close $hUSB_CAN
	set status 0
    }
    .f_status.l_message configure -bg white -fg black
    if {$status==1} then {
	set flipStates(canComm) "on"
	log_message "Select CAN Node..."
    } else {
	set flipStates(canComm) "off"
	log_message "CAN Init Fail"
    }
    updateGUI onCanCommStatusModified
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendFrame {frame} {
    #dbgBeginProc [info level [info level]]
    global bufferPipe02write hUSB_CAN
    #reset Pipe 81 
    USB_CAN_ResetPipe $hUSB_CAN 81
    #is frame  modulo 64
    #we send a dummyData more
    #because ZLP is not implemented on Jungo Driver
    if {[expr [string length $frame] % 64]==0} then {
	set frame [append frame "FF"]
	#dbgShowInfo "frame  > $frame"
    }
    set bufferPipe02write $frame
    #send the frame on USB line
    #dbgShowInfo "hUSB_CAN  > $hUSB_CAN"
    USB_CAN_WritePipe02 $hUSB_CAN
    #dbgEndProc [info level [info level]]
    return $frame
}
proc ptclGetAck {} {
    #dbgBeginProc [info level [info level]]
    global errCode readframe dongle ciError
    global bufferPipe81read hUSB_CAN
    set status 0
    set errCode 0
    while {$status == 0} {
	set status [USB_CAN_ReadPipe81 $hUSB_CAN]
	#dbgShowInfo "status  > $status"
	update
    }
    if {$status == -1} then {
	#TIME OUT occured!!!!!!!!!!!
	set message "Time Out Error."
	cmdsResetProgressBar
	set errCode -10
    }
    if {$status == 1} then {
	set readframe $bufferPipe81read
	#dbgShowInfo "readframe  > $readframe"
	set id [string range $readframe 4 7]
	#dbgShowInfo "id  > $id"
	#dbgShowInfo "ciError  > $ciError"
	if {$id == $ciError} then {
	    #error message
	    set message "Software Security Bit set.\n  Cannot access device data."
	    set errCode -12
	    set status 0
	}
    }
    if {[info exists message]} then {
	messageBox "Communication Information" error $message
	cmdsResetProgressBar
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclCancelCANComm {} {
    #dbgBeginProc [info level [info level]]    
    global hUSB_CAN flipStates canProtocol
    if {$flipStates(canNode) == "open"} then {
	ptclSelectNode
    }
    if {! $flipStates(simul)} then {
	USB_CAN_Close $hUSB_CAN
	set status 1
    } else {
	set status 1
    }
    if {$status} then {
	log_message "CAN interface disabled"
	set flipStates(canComm) "off"
	updateGUI onAnyCommunicationOff
	updateGUI onCanCommStatusModified
	if {0} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack forget .main.f_buffer.b_memSelect
	    }
	}
    } else {
	log_message "Board Cancel Fail"
    }
    #dbgEndProc [info level [info level]]
    return 1
}
proc ptclUpdateOrCompareBuffer {addr6digit action} {
    #dbgBeginProc [info level [info level]]
    global readframe
    set addr 1
    set len 0x[string range $readframe 0 3]
    for {set i 0; set j 10} {$i < $len} {incr i; incr j 2} {
	if {$action == "update"} then {
	    writeBuffer [format "%06X" [expr $addr6digit + $i]] [string range $readframe $j [expr $j + 1]]
	} else {
	    set addr -1
	    if {[readBuffer [format "%06X" [expr $addr6digit + $i]]] != [string range $readframe $j [expr $j + 1]]} then {
		set addr [format "%#06X" [expr $addr6digit + $i]]
		set message "Memory Verify Fail at: $addr"
		log_message $message
		actionsLog_message "Memory Verify Fail at: $addr"
		cmdsResetProgressBar
		#dbgShowInfo "Verify FAIL."
		break
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $addr
}
#modifications en cours pour l'USB
proc ptclSelectNode {} {
    #dbgBeginProc [info level [info level]]
    global flipStates canProtocol readframe
    global dongle select_node canBaud
    set status 1
    set CRIS [format %08X 0x$::deviceArray(crisConnect)]
    set bitrate [format %04X [string range $canBaud 0 end-1]]
    set protocol "00"
    ptclInitDongle $bitrate $protocol $CRIS
    set frame [append frame "0001" $select_node "00" $::deviceArray(nnbConnect)]
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray(bootlId) [string range $readframe 10 11]
	set canProtocol(commState) [string range $readframe 12 13]
	if {$canProtocol(commState) == "01"} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
	    }
	    updateGUI onAnyCommunicationOn
	    updateGUI onCanNodeSelectionOpened
	    log_message "CAN node $::deviceArray(nnbConnect) opened."
	} else {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack forget .main.f_buffer.b_memSelect
	    }
	    updateGUI onAnyCommunicationOff
	    updateGUI onCanNodeSelectionClosed
	    log_message "CAN node $::deviceArray(nnbConnect) closed."
	}
    } else {
	set flipStates(anyComm) "off"
	updateGUI onAnyCommunicationOff
	updateGUI onCanNodeSelectionClosed
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSendIdProgStart {addLo addHi {memory "00"}} {
    #dbgBeginProc [info level [info level]]
    global buffer canProtocol prog_start
    set frame [append frame "0005" $prog_start "00" $memory [format %04X 0x$addLo] [format %04X 0x$addHi]]
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgramData {addLo addHi dummyArg} {
    #dbgBeginProc [info level [info level]]
    global temp prog_data readframe dongle sendframe
    #dbgShowVar "addLo  > $addLo"
    #dbgShowVar "addHi  > $addHi"
    set len [format "%04X" [expr $addHi - $addLo + 1]]
    set frame [append frame $len $prog_data "00"]
    for {set i $addLo} {$i <= $addHi} {incr i} {
	set frame ${frame}[readBuffer [format "%06X" $i]]
    }
    #dbgShowVar "frame = $frame"
    #dbgShowInfo "FRAME  > $frame"
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	if {[string index $readframe end] == 0} then {
	    set status 1
	} elseif {[string index $readframe end] == 1} {
	    set status 0
	} elseif {[string index $readframe end] == 2} {
	    set status 2
	}
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBlock {addrLo addrHi {memory "00"} {action "update"}} {
    #dbgBeginProc [info level [info level]]
    global display_data protocol readframe
    #Flip asks to read memories by 1024 bytes Block
    #USB protocol asks to read  memories by 1024 bytes Block
    set nbFrame [expr (($addrHi - $addrLo) / $protocol(frameLengthR)) +1]
    #dbgShowVar "nbFrame $nbFrame"
    #initialize the addrLow toread the first Frame
    set addrLow $addrLo
    while {$nbFrame >0} {
	#find the addrHig
	if {[expr ($addrHi - $addrLow)+1] > $protocol(frameLengthR)} then {
	    set addrHig [expr ($addrLow + $protocol(frameLengthR))-1]
	} else {
	    set addrHig $addrHi
	}
	#bonne boucle
	#initialize the temporary variables
	set tempFrame ""
	set status 1
	set leng 128
	set frame ""
	set frame [append frame "0005" $display_data "00" $memory [format %04X $addrLow] [format %04X $addrHig]]
	ptclSendFrame $frame
	#Read all the packets
	#we read until we have  complete frame
	while {$leng == 128} {
	    set status [ptclGetAck]
	    if {$status==-1} then {
		#time out occured
		set nbFrame 0
		break
	    } else {
		set leng [string length $readframe]
		append tempFrame $readframe
		#dbgShowVar "tempFrame $tempFrame"
	    }
	    update
	}
	#bonne boucle	
	#set tempFrame in readframe because  readframe 
	#is used to update Flip buffer
	set readframe $tempFrame
	#dbgShowVar "readframe before compare $readframe"
	if {$status == 1} then {
	    set failAddr [ptclUpdateOrCompareBuffer [format "%#06X" $addrLow] $action]
	    if {(($failAddr == 1) &&($action=="update")) ||(($failAddr == -1) &&($action=="compare"))} then {
		set status 1
	    } else {
		set status 0
		#dbgShowInfo "break flip"
		break
	    }
	}
	#the frame asked is correctly read so
	#so we initialize the next addrLow
	set addrLow [expr $addrHig+1]
	incr nbFrame -1
	update
    }
    #Return 1 or 0 if status !=1
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBlankCheck {addrLo addrHi {memory "01"}} {
    #dbgBeginProc [info level [info level]]
    global readframe display_data dongle
    set frame [append frame "0005" $display_data "00" $memory [format %04X "0x$addrLo"] [format %04X "0x$addrHi"]]
    #dbgShowVar "assembled frame: $frame"
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 0 || $status==-1} then {
	set status -2
    }
    if {$status == 1} then {
	if {[string length $readframe] == 14} then {
	    set status [string range $readframe end-3 end]
	} else {
	    set status -1
	}
    }
    #dbgShowVar "status $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock0 {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0002" $write_command "000000"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock1 {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0002" $write_command "000020"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock2 {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0002" $write_command "000040"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclFullChipErase {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0002" $write_command "0000FF"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set loadConfig(programDevice) "setupProgramDevice"
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBSB {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "000100" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSBV {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "000101" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev1 {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "000105FE"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev2 {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "000105FC"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteEB {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "000106" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC1 {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "00011C" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC2 {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "00011D" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteBTC3 {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "00011E" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteNNB {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "00011F" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteCRIS {data} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set frame [append frame "0003" $write_command "000120" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwByte {{data "X"}} {
    #dbgBeginProc [info level [info level]]
    global write_command
    if {$data == "X"} then {
	set data [format %02X [expr [expr 0x$::deviceArray(hsb) & 0x3F] | [expr 0x$::deviceArray(x2Fuse) << 7] | [expr 0x$::deviceArray(bljbFuse) << 6]]]
    }
    set frame [append frame "0003" $write_command "000200" $data]
    ptclSendFrame $frame
    set status [ptclGetAck]
    set status [expr $status==1]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwReset {} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set status 1
    set frame [append frame "0002" $write_command "000300"]
    ptclSendFrame $frame
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteLJMP {address} {
    #dbgBeginProc [info level [info level]]
    global write_command
    set status 1
    set frame [append frame "0004" $write_command "000301" $address]
    ptclSendFrame $frame
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBootlVer {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "bootlVer"
    set frame [append frame "0002" $read_command "000000"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set c1 [string index $readframe end-1]
	set c2 [string index $readframe end]
	set ::deviceArray($p) "1.$c1.$c2"
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)" 
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId1 {} {
    #dbgBeginProc [info level [info level]]
    global testFlag read_command readframe
    set p "deviceBootId1"
    set status 1
    if {$testFlag(readDevBootId1)} then {
	set frame [append frame "0002" $read_command "000001"]
	ptclSendFrame $frame
	set status [ptclGetAck]
	if {$status == 1} then {
	    set ::deviceArray($p) [string range $readframe end-1 end]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	} else {
	    set status 0
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId2 {} {
    #dbgBeginProc [info level [info level]]
    global testFlag read_command readframe
    set p "deviceBootId2"
    set status 1
    if {$testFlag(readDevBootId2)} then {
	set frame [append frame "0002" $read_command "000002"]
	ptclSendFrame $frame
	set status [ptclGetAck]
	if {$status == 1} then {
	    set ::deviceArray($p) [string range $readframe end-1 end]
	    #dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	} else {
	    set status 0
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBSB {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "bsb"
    set frame [append frame "0002" $read_command "000100"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSBV {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "sbv"
    set frame [append frame "0002" $read_command "000101"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSSB {} {
    #dbgBeginProc [info level [info level]]
    global expAnsw read_command readframe
    set p "ssb"
    set frame [append frame "0002" $read_command "000105"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(level) X
	foreach lev {0 1 2} {
	    foreach i $expAnsw(readSSBlev$lev) {
		if {$::deviceArray(ssb) == $i} then {
		    set ::deviceArray(level) $lev
		}
	    }
	}
	#dbgShowVar "::deviceArray(level) = $::deviceArray(level)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadEB {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "eb"
    set frame [append frame "0002" $read_command "000106"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadManufId {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "manufId"
    set frame [append frame "0002" $read_command "000130"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId1 {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "deviceId1"
    set frame [append frame "0002" $read_command "000131"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId2 {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "deviceId2"
    set frame [append frame "0002" $read_command "000160"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId3 {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "deviceId3"
    set frame [append frame "0002" $read_command "000161"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC1 {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "btc1"
    set frame [append frame "0002" $read_command "00011C"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC2 {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "btc2"
    set frame [append frame "0002" $read_command "00011D"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBTC3 {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "btc3"
    set frame [append frame "0002" $read_command "00011E"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadNNB {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "nnbProg"
    set frame [append frame "0002" $read_command "00011F"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadCRIS {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p crisProg
    set frame [append frame "0002" $read_command "000120"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadHwByte {} {
    #dbgBeginProc [info level [info level]]
    global read_command readframe
    set p "hsb"
    set frame [append frame "0002" $read_command "000200"]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	set ::deviceArray($p) [string range $readframe end-1 end]
	#dbgShowVar "::deviceArray($p) = $::deviceArray($p)"
	set ::deviceArray(x2Fuse) [expr (0x$::deviceArray(hsb) | 0x7F) >> 7]
	set ::deviceArray(bljbFuse) [expr ((0x$::deviceArray(hsb) | 0xBF) & 0x7F) >> 6]
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReset {} {
    #dbgBeginProc [info level [info level]]
    global dongle
    set status 1
    set frame [append frame "0000" $dongle "01"]
    ptclSendFrame $frame
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclInitDongle {bitrate protocol CRIS} {
    #dbgBeginProc [info level [info level]]
    global readframe dongle
    set status 1
    set frame [append frame "0007" $dongle "02" $bitrate $protocol $CRIS]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status==1} then {
	log_message "Dongle initialized"
	log_message "File > Load..."
    } else {
	set status 0
	log_message "Dongle Initialization Failed"
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclStartBootloader {num_chip} {
    #dbgBeginProc [info level [info level]]
    global dongle
    set status 1
    set frame [append frame "0001" $dongle "03" $num_chip]
    ptclSendFrame $frame
    set status [ptclGetAck]
    if {$status == 1} then {
	if {[string range $readframe 9 10] == $num_chip} then {
	    set status 1
	} else {
	    set status 0
	}
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclCheckCanEntries {} {
    set status 1
    if {! [isValidHexaInput $::deviceArray(nnbProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(crisProg)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc1)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc2)]} then {
	set status 0
    }
    if {! [isValidHexaInput $::deviceArray(btc3)]} then {
	set status 0
    }
    return $status
}
proc ptclReadCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclReadNNB]} then {
	    break
	}
	if {! [ptclReadCRIS]} then {
	    break
	}
	if {! [ptclReadBTC1]} then {
	    break
	}
	if {! [ptclReadBTC2]} then {
	    break
	}
	if {! [ptclReadBTC3]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclSetCanConfig {} {
    set status 0
    while {1} {
	if {! [ptclCheckCanEntries]} then {
	    break
	}
	if {! [ptclWriteNNB $::deviceArray(nnbProg)]} then {
	    break
	}
	if {! [ptclWriteCRIS $::deviceArray(crisProg)]} then {
	    break
	}
	if {! [ptclWriteBTC1 $::deviceArray(btc1)]} then {
	    break
	}
	if {! [ptclWriteBTC2 $::deviceArray(btc2)]} then {
	    break
	}
	if {! [ptclWriteBTC3 $::deviceArray(btc3)]} then {
	    break
	}
	set status 1
	break
    }
    return $status
}
proc ptclStartAppli {reset} {
    #dbgBeginProc [info level [info level]]
    if {$reset} then {
	set status [ptclWriteHwReset]
    } else {
	set status [ptclWriteLJMP 0000]
    }
    updateGUI onAnyCommunicationOff
    updateGUI onCanNodeSelectionClosed
    #dbgEndProc [info level [info level]]
    return $status
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
proc USB_CAN_LocateAndOpenDevice {} {
    global hUSB_CAN
    set hUSB_CAN [USB_CAN_LocateAndOpenDevice_C]
    return $hUSB_CAN
}
proc listProcs {} {
    foreach P [info procs USB*] {
	puts "$P\t\t[info args $P]"
    }
    return
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
proc USB_DFU_Close {hUSB_DFU} {
    #dbgBeginProc [info level [info level]]
    if {$hUSB_DFU > 0} then {
	USB_DFU_Close_C [format %08X $hUSB_DFU]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc USB_DFU_ResetPipe {hUSB_DFU pipeNum} {
    #dbgBeginProc [info level [info level]]
    if {$hUSB_DFU > 0} then {
	USB_DFU_ResetPipe_C [format %08X $hUSB_DFU] [format %02X $pipeNum]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc USB_DFU_ResetDevice {hUSB_DFU} {
    #dbgBeginProc [info level [info level]]
    if {$hUSB_DFU > 0} then {
	USB_DFU_ResetDevice_C [format %08X $hUSB_DFU]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc USB_DFU_ReadPipe00 {hUSB_DFU setupPacket size} {
    #dbgBeginProc [info level [info level]]
    if {$hUSB_DFU > 0} then {
	set status [USB_DFU_ReadPipe00_C [format %08X $hUSB_DFU] $setupPacket [format %08X $size]]
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc USB_DFU_WritePipe00 {hUSB_DFU setupPacket size} {
    #dbgBeginProc [info level [info level]]
    if {$hUSB_DFU > 0} then {
	set status [USB_DFU_WritePipe00_C [format %08X $hUSB_DFU] $setupPacket [format %08X $size]]
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc USB_DFU_StopTransferPipe00 {hUSB_DFU} {
    #dbgBeginProc [info level [info level]]
    if {$hUSB_DFU > 0} then {
	USB_DFU_StopTransferPipe00_C [format %08X $hUSB_DFU]
    }
    #dbgEndProc [info level [info level]]
    return
}
#dbgBeginSrc [info script]
global protocol dfuRequest projDir hUSB_DFU
global bStatus bState bStatusMessage dfuSuffix
source $projDir/tcl/protocol/usb/usb_dfu_lib.tcl
source $projDir/tcl/protocol/usb/usb_dfu_utils.tcl
set dfuRequest(detach) "2100"
set dfuRequest(dnload) "2101"
set dfuRequest(upload) "A102"
set dfuRequest(getStatus) "A103"
set dfuRequest(clrStatus) "2104"
set dfuRequest(getState) "A105"
set dfuRequest(abort) "2106"
set dfuRequest(interface) "0004"
set dfuRequest(pipe0Length) 32
set dfuRequest(wBlockMax) 0xFFFF
set dfuRequest(wBlock) $dfuRequest(wBlockMax)
set dfuSuffix(dwCRC) "00000000"
set dfuSuffix(bLength) "00"
set dfuSuffix(ucDfuSignature) "000000"
set dfuSuffix(bcdDFU) "0000"
set dfuSuffix(idVendor) "0000"
set dfuSuffix(idProduct) "0000"
set dfuSuffix(bcdDevice) "0000"
set protocol(frameLengthW) 2048
set protocol(frameLengthR) 2048
set protocol(blankCheck) "0301"
set protocol(progStart) "01MMYYYYZZZZ"
set protocol(displayData) "03MMYYYYZZZZ"
set protocol(eraseBlock0) "040000"
set protocol(eraseBlock1) "040020"
set protocol(eraseBlock2) "040040"
set protocol(eraseBlock3) "040080"
set protocol(eraseBlock4) "0400C0"
set protocol(fullErase) "0400FF"
set protocol(writeBSB) "040100"
set protocol(writeSBV) "040101"
set protocol(writeP1) "040102"
set protocol(writeP3) "040103"
set protocol(writeP4) "040104"
set protocol(writeSSB) "040105"
set protocol(writeEB) "040106"
set protocol(writeHWB) "040200"
set protocol(hwReset) "040300"
set protocol(ljmpAddress) "040301"
set protocol(readBootlVer) "050000"
set protocol(readBootId1) "050001"
set protocol(readBootId2) "050002"
set protocol(readBSB) "050100"
set protocol(readSBV) "050101"
set protocol(readP1) "050102"
set protocol(readP3) "050103"
set protocol(readP4) "050104"
set protocol(readSSB) "050105"
set protocol(readEB) "050106"
set protocol(readManufId) "050130"
set protocol(readDevId1) "050131"
set protocol(readDevId2) "050160"
set protocol(readDevId3) "050161"
set protocol(readHSB) "050200"
set bStatus(OK) 0x00
set bStatus(errTARGET) 0x01
set bStatus(errFILE) 0x02
set bStatus(errWRITE) 0x03
set bStatus(errERASE) 0x04
set bStatus(errCHECK_ERASED) 0x05
set bStatus(errPROG) 0x06
set bStatus(errVERIFY) 0x07
set bStatus(errADDRESS) 0x08
set bStatus(errNOTDONE) 0x09
set bStatus(errFIRMWARE) 0x0A
set bStatus(errVENDOR) 0x0B
set bStatus(errUSBR) 0x0C
set bStatus(errPOR) 0x0D
set bStatus(errUNKNOWN) 0x0E
set bStatus(errSTALLEDPK) 0x0F
set bStatus(errTIMEOUT) 0x10
set bStatus(errWRITEPIPE0) 0x11
set bStatusMessage($bStatus(errTARGET)) "File is not targeted for use by this device."
set bStatusMessage($bStatus(errFILE)) "File is for this device, but fails\n  some vendor-specific verification test."
set bStatusMessage($bStatus(errWRITE)) "Device is unable to write memory."
set bStatusMessage($bStatus(errERASE)) "Memory erase function failed."
set bStatusMessage($bStatus(errCHECK_ERASED)) "Memory erase check failed."
set bStatusMessage($bStatus(errPROG)) "Program memory function failed."
set bStatusMessage($bStatus(errVERIFY)) "Programmed memory failed verification."
set bStatusMessage($bStatus(errADDRESS)) "Cannot program memory due to received\n address which is out of range."
set bStatusMessage($bStatus(errNOTDONE)) "Received DFU_DNLOAD with wLength = 0 but\n device does not think it has all the data yet."
set bStatusMessage($bStatus(errFIRMWARE)) "Device's firmware is corrupted.\n It cannot return to run-time operations."
set bStatusMessage($bStatus(errVENDOR)) "iString indicates a vendor-specific error."
set bStatusMessage($bStatus(errUSBR)) "Device detected unexpected USB reset signaling."
set bStatusMessage($bStatus(errPOR)) "Device detected unexpected power on reset."
set bStatusMessage($bStatus(errUNKNOWN)) "Something went wrong, but the device\n does not know what it was."
set bStatusMessage($bStatus(errSTALLEDPK)) "Device stalled an unexpected request."
set bStatusMessage($bStatus(errTIMEOUT)) "Time Out error."
set bStatusMessage($bStatus(errWRITEPIPE0)) "Cannot write to the USB device Pipe 0."
set bState(appIDLE) 0x00
set bState(appDETACH) 0x01
set bState(dfuIDLE) 0x02
set bState(dfuDNLOADSYNC) 0x03
set bState(dfuDNBUSY) 0x04
set bState(dfuDNLOADIDLE) 0x05
set bState(dfuMANIFESTSYNC) 0x06
set bState(dfuMANIFEST) 0x07
set bState(dfuMANIFESTWAITRESET) 0x08
set bState(dfuUPLOADIDLE) 0x09
set bState(dfuERROR) 0x0A
namespace eval ::USB_DFU_SETUP:: {
    variable frame ""
    variable frameMaxLength 1024
    namespace export fclear fappend
}
namespace eval ::USB_DFU_OUT:: {
    variable frame ""
    variable frameMaxLength 1024
    namespace export fclear fappend
}
namespace eval ::USB_DFU_IN:: {
    variable frame ""
    variable frameMaxLength 1024
    namespace export fclear fappend
}
foreach NMSP {USB_DFU_SETUP USB_DFU_OUT USB_DFU_IN} {
    proc ::${NMSP}::fclear {} {
	#dbgBeginProc [info level [info level]]
	variable frame
	set frame ""
	#dbgEndProc [info level [info level]]
	return
    }
    proc ::${NMSP}::fappend {data} {
	#dbgBeginProc [info level [info level]]
	variable frame
	append frame $data
	#dbgEndProc [info level [info level]]
	return
    }
}
proc decrementBlockNum {} {
    global dfuRequest
    incr dfuRequest(wBlock) -1
    set dfuRequest(wBlock) [expr $dfuRequest(wBlock) % ($dfuRequest(wBlockMax) + 1)]
    return
}
proc ptclProgramData {addrLo addrHi {memory "00"}} {
    #dbgBeginProc [info level [info level]]
    global dfuRequest dfuSuffix hUSB_DFU bStatus
    global bStatusMessage protocol
    set nZeroBytePrefix [expr $addrLo % $dfuRequest(pipe0Length)]
    buildSetupPacket dnload [expr $dfuRequest(pipe0Length) + $nZeroBytePrefix + $addrHi - $addrLo + 1 + 16] 0
    set ::USB_DFU_OUT::frame [string replace $protocol(progStart) 2 3 $memory]
    set ::USB_DFU_OUT::frame [string replace $::USB_DFU_OUT::frame 4 7 [format %04X $addrLo]]
    set ::USB_DFU_OUT::frame [string replace $::USB_DFU_OUT::frame 8 end [format %04X $addrHi]]
    ::USB_DFU_OUT::fappend "0000000000000000000000000000000000000000000000000000"
    for {set i 1} {$i <= $nZeroBytePrefix} {incr i} {
	::USB_DFU_OUT::fappend "00"
    }
    ::USB_DFU_OUT::fappend [buildUsbDfuOutFrame_C [format %d $addrLo] [format %d $addrHi]]
    foreach field {bcdDevice idProduct idVendor bcdDFU ucDfuSignature bLength dwCRC} {
	::USB_DFU_OUT::fappend $dfuSuffix($field)
    }
    set outFrameSize [format "%#010X" [expr [string length $::USB_DFU_OUT::frame] / 2]]
    #dbgShowVar "OUT Packet = $::USB_DFU_OUT::frame"
    USB_DFU_WritePipe00 $hUSB_DFU $::USB_DFU_SETUP::frame $outFrameSize
    set s [getDfuStatus]
    if {$s == $bStatus(OK)} then {
	set status 1
    } else {
	messageBox "USB Status" error $bStatusMessage($s)
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBlock {addrLo addrHi {memory "00"} {action "update"}} {
    #dbgBeginProc [info level [info level]]
    global nAddrBits waitTime protocol buffer
    global bStatus hUSB_DFU bStatusMessage
    set status 1
    buildSetupPacket dnload [expr [string length $protocol(displayData)] / 2] 0
    set ::USB_DFU_OUT::frame [string replace $protocol(displayData) 2 3 $memory]
    set ::USB_DFU_OUT::frame [string replace $::USB_DFU_OUT::frame 4 7 [format %04X $addrLo]]
    set ::USB_DFU_OUT::frame [string replace $::USB_DFU_OUT::frame 8 end [format %04X $addrHi]]
    set outFrameSize [format "%#010X" [expr [string length $::USB_DFU_OUT::frame] / 2]]
    #dbgShowVar "OUT Packet = $::USB_DFU_OUT::frame"
    USB_DFU_WritePipe00 $hUSB_DFU $::USB_DFU_SETUP::frame $outFrameSize
    buildSetupPacket upload [expr $addrHi - $addrLo + 1] 0
    ::USB_DFU_IN::fclear
    USB_DFU_ReadPipe00 $hUSB_DFU $::USB_DFU_SETUP::frame [format "%#010X" [expr $addrHi - $addrLo + 1]]
    set temp $::USB_DFU_IN::frame
    set s [getDfuStatus]
    if {$s == $bStatus(OK)} then {
	set status 1
	set addr $addrLo
	if {$action == "update"} then {
	    ptclUpdateBuffer $temp $addr
	} else {
	    set usbReadFrameLength [string length $temp]
	    for {set i 0} {$i <= [expr $usbReadFrameLength - 1]} {incr i 2; incr addr 1} {
		#dbgShowVar "addr = $addr"
		if {[readBuffer [format %06X $addr]] != [string range $temp $i [expr $i + 1]]} then {
		    set message "Memory Verify Fail at: [format %#06X $addr]"
		    set buffer(verifyFail) [format "%#06X" $addr]
		    log_message $message
		    actionsLog_message $message
		    cmdsResetProgressBar
		    #dbgShowInfo "Verify FAIL."
		    set status 0
		    break
		} else {
		    set buffer(verifyFail) -1
		}
	    }
	}
    } else {
	messageBox "USB Status" error $bStatusMessage($s)
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclUpdateBuffer {frame addr} {
    #dbgBeginProc [info level [info level]]
    set nAddr [expr [string length $frame] / 2]
    set indexMax [expr [string length $frame] - 1]
    for {set i 0} {$i < $indexMax} {incr i 2; incr addr 1} {
	writeBuffer [format %06X $addr] [string range $frame $i [expr $i + 1]]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc ptclFullChipErase {} {
    #dbgBeginProc [info level [info level]]
    global protocol bStatus
    set status [bStatus2Boolean [ptclWriteByte $protocol(fullErase) "" 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclEraseBlock0 {} {
    return [ptclEraseBlock 0]
}
proc ptclEraseBlock1 {} {
    return [ptclEraseBlock 1]
}
proc ptclEraseBlock2 {} {
    return [ptclEraseBlock 2]
}
proc ptclEraseBlock3 {} {
    return [ptclEraseBlock 3]
}
proc ptclEraseBlock4 {} {
    return [ptclEraseBlock 4]
}
proc ptclEraseBlock block {
    #dbgBeginProc [info level [info level]]
    global protocol bStatus
    set status [bStatus2Boolean [ptclWriteByte $protocol(eraseBlock$block) "" 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclBlankCheck {addrLo addrHi} {
    #dbgBeginProc [info level [info level]]
    global protocol bStatus bStatusMessage hUSB_DFU
    set status [ptclWriteByte $protocol(blankCheck) [format %04X "0x$addrLo"][format %04X "0x$addrHi"] 1]
    if {$status == $bStatus(OK)} then {
	set status -1
    } elseif {$status == $bStatus(errCHECK_ERASED)} {
	buildSetupPacket upload 2 0
	::USB_DFU_IN::fclear
	USB_DFU_ReadPipe00 $hUSB_DFU $::USB_DFU_SETUP::frame [format "%#010X" 2]
	set status $::USB_DFU_IN::frame
    } else {
	messageBox "USB Status" error $bStatusMessage($status)
	set status -2
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc bStatus2Boolean {bs} {
    #dbgBeginProc [info level [info level]]
    global bStatus bStatusMessage
    if {$bs != $bStatus(OK)} then {
	messageBox "USB Status" error $bStatusMessage($bs)
	set status 0
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclSetPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent protocol
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	ptclWriteByte $protocol(writeP1) $::deviceArray(p1_config) 1
	ptclWriteByte $protocol(writeP3) $::deviceArray(p3_config) 1
	ptclWriteByte $protocol(writeP4) $::deviceArray(p4_config) 1
    }
    #dbgEndProc [info level [info level]]
    return
}
proc ptclWriteBSB {data} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set status [bStatus2Boolean [ptclWriteByte $protocol(writeBSB) $data 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSBV {data} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set status [bStatus2Boolean [ptclWriteByte $protocol(writeSBV) $data 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteSSB {data} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set status [bStatus2Boolean [ptclWriteByte $protocol(writeSSB) $data 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev1 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteSSB "FE"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclProgSSBlev2 {} {
    #dbgBeginProc [info level [info level]]
    set status [ptclWriteSSB "FC"]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteEB {data} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set status [bStatus2Boolean [ptclWriteByte $protocol(writeEB) $data 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteHwByte {{data "X"}} {
    #dbgBeginProc [info level [info level]]
    global protocol
    if {[info exists ::deviceArray(oscCtrl)]} then {
	if {$data == "X"} then {
	    set data [format %02X [expr [expr 0x$::deviceArray(hsb) & 0x0F] | [expr 0x$::deviceArray(x2Fuse) << 7] | [expr 0x$::deviceArray(bljbFuse) << 6] | [expr 0x$::deviceArray(oscCtrl) << 4]]]
	}
    } else {
	if {$data == "X"} then {
	    catch [set data [format %02X [expr [expr 0x$::deviceArray(hsb) & 0x3F] | [expr 0x$::deviceArray(x2Fuse) << 7] | [expr 0x$::deviceArray(bljbFuse) << 6]]]]
	}
    }
    set status [bStatus2Boolean [ptclWriteByte $protocol(writeHWB) $data 1]]
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclStartAppli {{reset 0}} {
    #dbgBeginProc [info level [info level]]
    global protocol
    if {$reset} then {
	set status [bStatus2Boolean [ptclWriteByte $protocol(hwReset) "" 0]]
    } else {
	set status [bStatus2Boolean [ptclWriteByte $protocol(ljmpAddress) "0000" 0]]
	if {$status} then {
	    set status [bStatus2Boolean [ptclWriteByte "" "" 0]]
	}
    }
    ptclCancelUSBComm
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclWriteByte {command {data ""} getStatus} {
    #dbgBeginProc [info level [info level]]
    global hUSB_DFU bStatus
    set stream $command
    append stream $data
    buildSetupPacket dnload [expr [string length $stream] / 2] 0
    ::USB_DFU_OUT::fclear
    ::USB_DFU_OUT::fappend $command
    ::USB_DFU_OUT::fappend $data
    #dbgShowVar "OUT Packet = $::USB_DFU_OUT::frame"
    set outFrameSize [format "%#010X" [expr [string length $::USB_DFU_OUT::frame] / 2]]
    if {[USB_DFU_WritePipe00 $hUSB_DFU $::USB_DFU_SETUP::frame $outFrameSize]} then {
	if {$getStatus} then {
	    set status [getDfuStatus]
	} else {
	    set status 0x00
	}
    } else {
	set status $bStatus(errWRITEPIPE0)
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc getDfuStatus {} {
    #dbgBeginProc [info level [info level]]
    global hUSB_DFU bState bStatus
    global timeout
    set timeout 0
    set timeoutId [after 12000 "set timeout 1"]
    buildSetupPacket getStatus 6 1
    set state unknown
    while {$state != $bState(dfuIDLE)} {
	::USB_DFU_IN::fclear
	USB_DFU_ReadPipe00 $hUSB_DFU $::USB_DFU_SETUP::frame [format "%#010X" 6]
	set state 0x[string range $::USB_DFU_IN::frame 8 9]
	if {$timeout} then {
	    break
	}
	update
    }
    if {$timeout} then {
	set status $bStatus(errTIMEOUT)
    } else {
	after cancel $timeoutId
	set status 0x[string range $::USB_DFU_IN::frame 0 1]
	if {$status != $bStatus(OK)} then {
	    buildSetupPacket clrStatus 0 1
	}
    }
    #dbgShowVar "DFU Status = $status"
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadEB {} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent protocol
    set status 1
    if {$bootloaderVerDependent(eb)} then {
	set byte [ptclReadByte $protocol(readEB)]
	if {$byte != -1} then {
	    set ::deviceArray(eb) $byte
	    set status 1
	} else {
	    set status 0
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadPortsConfig {} {
    #dbgBeginProc [info level [info level]]
    global waitTime bootloaderVerDependent protocol
    set status 1
    if {$bootloaderVerDependent(p1p3p4_config)} then {
	set byte [ptclReadByte $protocol(readP1)]
	if {$byte != -1} then {
	    set ::deviceArray(p1_config) $byte
	} else {
	    return 0
	}
	set byte [ptclReadByte $protocol(readP3)]
	if {$byte != -1} then {
	    set ::deviceArray(p3_config) $byte
	} else {
	    return 0
	}
	set byte [ptclReadByte $protocol(readP4)]
	if {$byte != -1} then {
	    set ::deviceArray(p4_config) $byte
	} else {
	    return 0
	}
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBootlVer {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readBootlVer)]
    if {$byte != -1} then {
	set c1 [string index $byte 0]
	set c2 [string index $byte 1]
	set ::deviceArray(bootlVer) "1.$c1.$c2"
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId1 {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readBootId1)]
    if {$byte != -1} then {
	set ::deviceArray(deviceBootId1) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDevBootId2 {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readBootId2)]
    if {$byte != -1} then {
	set ::deviceArray(deviceBootId2) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadBSB {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readBSB)]
    if {$byte != -1} then {
	set ::deviceArray(bsb) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSBV {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readSBV)]
    if {$byte != -1} then {
	set ::deviceArray(sbv) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadSSB {} {
    #dbgBeginProc [info level [info level]]
    global protocol expAnsw
    set byte [ptclReadByte $protocol(readSSB)]
    if {$byte != -1} then {
	set ::deviceArray(ssb) $byte
	foreach i $expAnsw(readSSBlev0) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) 0
	    }
	}
	foreach i $expAnsw(readSSBlev1) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) 1
	    }
	}
	foreach i $expAnsw(readSSBlev2) {
	    if {$::deviceArray(ssb) == $i} then {
		set ::deviceArray(level) 2
	    }
	}
	#dbgShowVar "::deviceArray(level) = $::deviceArray(level)"
	set status 1
    } else {
	set status 0
    }
    updateGUI onSecurityLevelChange
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadManufId {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readManufId)]
    if {$byte != -1} then {
	set ::deviceArray(manufId) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId1 {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readDevId1)]
    if {$byte != -1} then {
	set ::deviceArray(deviceId1) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId2 {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readDevId2)]
    if {$byte != -1} then {
	set ::deviceArray(deviceId2) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadDeviceId3 {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readDevId3)]
    if {$byte != -1} then {
	set ::deviceArray(deviceId3) $byte
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadHwByte {} {
    #dbgBeginProc [info level [info level]]
    global protocol
    set byte [ptclReadByte $protocol(readHSB)]
    if {$byte != -1} then {
	set ::deviceArray(hsb) $byte
	set ::deviceArray(x2Fuse) [expr (0x$::deviceArray(hsb) | 0x7F) >> 7]
	set ::deviceArray(bljbFuse) [expr ((0x$::deviceArray(hsb) | 0xBF) & 0x7F) >> 6]
	if {[info exists ::deviceArray(oscCtrl)]} then {
	    set ::deviceArray(oscCtrl) [expr (0x$::deviceArray(hsb) & 0x30) >> 4]
	}
	set status 1
    } else {
	set status 0
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ptclReadByte {command} {
    #dbgBeginProc [info level [info level]]
    global hUSB_DFU
    buildSetupPacket dnload [expr [string length $command] / 2] 0
    ::USB_DFU_OUT::fclear
    ::USB_DFU_OUT::fappend $command
    set outFrameSize [format "%#010X" [expr [string length $::USB_DFU_OUT::frame] / 2]]
    if {[USB_DFU_WritePipe00 $hUSB_DFU $::USB_DFU_SETUP::frame $outFrameSize]} then {
	buildSetupPacket upload 1 0
	::USB_DFU_IN::fclear
	if {[USB_DFU_ReadPipe00 $hUSB_DFU $::USB_DFU_SETUP::frame [format "%#010X" 1]]} then {
	    set byte $::USB_DFU_IN::frame
	} else {
	    set byte -1
	}
    } else {
	set byte -1
    }
    #dbgEndProc [info level [info level]]
    return $byte
}
proc buildSetupPacket {bRequest length noBlockValue} {
    #dbgBeginProc [info level [info level]]
    global dfuRequest protocol
    ::USB_DFU_SETUP::fclear
    ::USB_DFU_SETUP::fappend $dfuRequest($bRequest)
    if {$noBlockValue} then {
	::USB_DFU_SETUP::fappend "0000"
	::USB_DFU_SETUP::fappend [bigEndian $dfuRequest(interface)]
	::USB_DFU_SETUP::fappend [bigEndian [format %04X $length]]
    } else {
	::USB_DFU_SETUP::fappend [bigEndian [format %04X $dfuRequest(wBlock)]]
	::USB_DFU_SETUP::fappend [bigEndian $dfuRequest(interface)]
	::USB_DFU_SETUP::fappend [bigEndian [format %04X $length]]
	decrementBlockNum
    }
    #dbgShowVar "SETUP Packet = $::USB_DFU_SETUP::frame"
    #dbgEndProc [info level [info level]]
    return $::USB_DFU_SETUP::frame
}
proc tstDecBlockNum {} {
    global dfuRequest
    for {set i 1} {$i <= [expr $dfuRequest(wBlockMax) + 10]} {incr i} {
	puts $dfuRequest(wBlock)
	decrementBlockNum
    }
}
proc ptclCancelUSBComm {} {
    global hUSB_DFU
    USB_DFU_Close $hUSB_DFU
    updateGUI onUsbCommunicationOff
    updateGUI onAnyCommunicationOff
    return
}
proc bigEndian {word} {
    set hiByte [string range $word 0 1]
    set loByte [string range $word 2 3]
    set swp ${loByte}${hiByte}
    return $swp
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
proc USB_DFU_LocateAndOpenDevice {pId} {
    #dbgBeginProc [info level [info level]]
    global hUSB_DFU
    set hUSB_DFU [USB_DFU_LocateAndOpenDevice_C $pId]
    if {$hUSB_DFU == -1} then {
	messageBox "USB Device Connection" error "USB driver not loaded"
	updateGUI onUsbCommunicationOff
	updateGUI onAnyCommunicationOff
    } elseif {$hUSB_DFU == -2} {
	messageBox "USB Device Connection" error "Cannot open the USB device"
	updateGUI onUsbCommunicationOff
	updateGUI onAnyCommunicationOff
    } else {
	updateGUI onUsbCommunicationOn
	updateGUI onAnyCommunicationOn
    }
    #dbgEndProc [info level [info level]]
    return $hUSB_DFU
}
proc listProcs {} {
    foreach P [info procs USB*] {
	puts "$P [info args $P]"
    }
    return
}
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global buffer protocol expAnsw testFlag canProtocol waitTime doTestArray flipStates errCode
if {[lsearch [namespace children] ::tcltest] == -1} then {
    package require tcltest
    namespace import ::tcltest::*
}
set skipList {}
foreach test [array names doTestArray] {
    if {! $doTestArray($test)} then {
	append skipList " ${test}* "
    }
}
if {[info exists ::deviceArray(skipList)]} then {
    append skipList $::deviceArray(skipList)
}
set ::tcltest::skip $skipList
#dbgShowVar "skip = $::tcltest::skip"
set flipStates(mssgBox) 0
set ::tcltest::verbose "ps"
set PASS 1
set FAIL 0
cmdsReadSpecialBytes
debug_log "******************************************"
debug_log "********** CAN Standard TESTS ************"
debug_log "******************************************"
cmdsImportCurrentMemoryNameSpace "FLASH"
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg red]
debug_log "*************** XAF TESTS ****************"
test xaf-1.0 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.0 ==========="
log_message "test xaf-1.0 "
ptclFullChipErase
} $PASS
test xaf-1.1 {Write BSB = 0x55} {
#dbgShowInfo "============ test xaf-1.1 ==========="
log_message "test xaf-1.1 "
ptclWriteBSB "55"
} $PASS
test xaf-1.2 {Read BSB} {
#dbgShowInfo "============ test xaf-1.2 ==========="
log_message "test xaf-1.2 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.3 {Write SBV = 0x55} {
#dbgShowInfo "============ test xaf-1.3 ==========="
log_message "test xaf-1.3 "
ptclWriteSBV "55"
} $PASS
test xaf-1.4 {Read SBV} {
#dbgShowInfo "============ test xaf-1.4 ==========="
log_message "test xaf-1.4 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.5 {Write EB = 0x55} {
#dbgShowInfo "============ test xaf-1.5 ==========="
log_message "test xaf-1.5 "
ptclWriteEB "55"
} $PASS
test xaf-1.6 {Read EB} {
#dbgShowInfo "============ test xaf-1.6 ==========="
log_message "test xaf-1.6 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.7 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.7 ==========="
log_message "test xaf-1.7 "
ptclProgSSBlev1
} $PASS
test xaf-1.8 {Read SSB} {
#dbgShowInfo "============ test xaf-1.8 ==========="
log_message "test xaf-1.8 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test xaf-1.9 {Write BSB = 0xAA} {
#dbgShowInfo "============ test xaf-1.9 ==========="
log_message "test xaf-1.9 "
ptclWriteBSB "AA"
set errCode
} {-12}
test xaf-1.10 {Read BSB} {
#dbgShowInfo "============ test xaf-1.10 ==========="
log_message "test xaf-1.10 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.11 {Write SBV = 0xAA} {
#dbgShowInfo "============ test xaf-1.11 ==========="
log_message "test xaf-1.11 "
ptclWriteSBV "AA"
set errCode
} {-12}
test xaf-1.12 {Read SBV} {
#dbgShowInfo "============ test xaf-1.12 ==========="
log_message "test xaf-1.12 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.13 {Write EB = 0xAA} {
#dbgShowInfo "============ test xaf-1.13 ==========="
log_message "test xaf-1.13 "
ptclWriteEB "AA"
set errCode
} {-12}
test xaf-1.14 {Read EB} {
#dbgShowInfo "============ test xaf-1.14 ==========="
log_message "test xaf-1.14 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.15 {Write SSB = level 2} {
#dbgShowInfo "============ test xaf-1.15 ==========="
log_message "test xaf-1.15 "
ptclProgSSBlev2
} $PASS
test xaf-1.16 {Read SSB} {
#dbgShowInfo "============ test xaf-1.16 ==========="
log_message "test xaf-1.16 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.17 {Write BSB = 0x00} {
#dbgShowInfo "============ test xaf-1.17 ==========="
log_message "test xaf-1.17 "
ptclWriteBSB "00"
set errCode
} {-12}
test xaf-1.18 {Read BSB} {
#dbgShowInfo "============ test xaf-1.18 ==========="
log_message "test xaf-1.18 "
ptclReadBSB
set errCode
} {-12}
test xaf-1.19 {Write SBV = 0x00} {
#dbgShowInfo "============ test xaf-1.19 ==========="
log_message "test xaf-1.19 "
ptclWriteSBV "00"
set errCode
} {-12}
test xaf-1.20 {Read SBV} {
#dbgShowInfo "============ test xaf-1.20 ==========="
log_message "test xaf-1.20 "
ptclReadSBV
set errCode
} {-12}
test xaf-1.21 {Write EB = 0x00} {
#dbgShowInfo "============ test xaf-1.21 ==========="
log_message "test xaf-1.21 "
ptclWriteEB "00"
set errCode
} {-12}
test xaf-1.22 {Read EB} {
#dbgShowInfo "============ test xaf-1.22 ==========="
log_message "test xaf-1.22 "
ptclReadEB
set errCode
} {-12}
test xaf-1.23 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.23 ==========="
log_message "test xaf-1.23 "
ptclProgSSBlev1
set errCode
} {-12}
test xaf-1.24 {Read SSB} {
#dbgShowInfo "============ test xaf-1.24 ==========="
log_message "test xaf-1.24 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.25 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.25 ==========="
log_message "test xaf-1.25 "
ptclFullChipErase
} $PASS
test xaf-1.26 {Read BSB} {
#dbgShowInfo "============ test xaf-1.26 ==========="
log_message "test xaf-1.26 "
ptclReadBSB
set ::deviceArray(bsb)
} {FF}
test xaf-1.27 {Read SBV} {
#dbgShowInfo "============ test xaf-1.27 ==========="
log_message "test xaf-1.27 "
ptclReadSBV
set ::deviceArray(sbv)
} {FF}
test xaf-1.28 {Read EB} {
#dbgShowInfo "============ test xaf-1.28 ==========="
log_message "test xaf-1.28 "
ptclReadEB
set ::deviceArray(eb)
} {FF}
test xaf-1.29 {Read SSB} {
#dbgShowInfo "============ test xaf-1.29 ==========="
log_message "test xaf-1.29 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev0Test)
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg red]
debug_log "**************** FLASH *******************"
test flash-2.0 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.0 ==========="
log_message "test flash-2.0 "
ptclFullChipErase
} $PASS
test flash-2.1 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.1 ==========="
log_message "test flash-2.1 "
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.2 {Read from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.2 ==========="
log_message "test flash-2.2 "
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.3 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.3 ==========="
log_message "test flash-2.3 "
ptclFullChipErase
} $PASS
test flash-2.4 {Write AA at address 0X1FFF} {
#dbgShowInfo "============ test flash-2.4 ==========="
log_message "test flash-2.4 "
fillBuffer "001FFF" "001FFF" "AA"
cmdsDeviceProgram "001FFF" "001FFF"
} $PASS
test flash-2.5 {Read at address 0X1FFF} {
#dbgShowInfo "============ test flash-2.5 ==========="
log_message "test flash-2.5 "
cmdsReadAddrRange "001FFF" "001FFF"
checkBuffer "001FFF" "001FFF" "AA"
} $PASS
test flash-2.6 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.6 ==========="
log_message "test flash-2.6 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {1FFF}
test flash-2.7 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.7 ==========="
log_message "test flash-2.7 "
ptclFullChipErase
} $PASS
test flash-2.8 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.8 ==========="
log_message "test flash-2.8 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.9 {Write SSB = level 1} {
#dbgShowInfo "============ test flash-2.9 ==========="
log_message "test flash-2.9 "
ptclProgSSBlev1
} $PASS
test flash-2.10 {Read SSB} {
#dbgShowInfo "============ test flash-2.10 ==========="
log_message "test flash-2.10 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test flash-2.11 {Write AA at address 0X1FFF} {
#dbgShowInfo "============ test flash-2.11 ==========="
log_message "test flash-2.11 "
fillBuffer "001FFF" "001FFF" "AA"
cmdsDeviceProgram "001FFF" "001FFF"
set errCode
} {-12}
test flash-2.12 {Read at address 1FFF} {
#dbgShowInfo "============ test flash-2.12 ==========="
log_message "test flash-2.12 "
cmdsReadAddrRange "001FFF" "001FFF"
checkBuffer "001FFF" "001FFF" "FF"
} $PASS
test flash-2.13 {Write SSB = level 2} {
#dbgShowInfo "============ test flash-2.13 ==========="
log_message "test flash-2.13 "
ptclProgSSBlev2
} $PASS
test flash-2.14 {Read SSB} {
#dbgShowInfo "============ test flash-2.14 ==========="
log_message "test flash-2.14 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test flash-2.15 {Write AA at address 1FFF} {
#dbgShowInfo "============ test flash-2.15 ==========="
log_message "test flash-2.15 "
fillBuffer "001FFF" "001FFF" "AA"
cmdsDeviceProgram "001FFF" "001FFF"
set errCode
} {-12}
test flash-2.16 {Read at address 1FFF} {
#dbgShowInfo "============ test flash-2.16 ==========="
log_message "test flash-2.16 "
cmdsReadAddrRange "001FFF" "001FFF"
checkBuffer "001FFF" "001FFF" "AA"
set errCode
} {-12}
test flash-2.17 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.17 ==========="
log_message "test flash-2.17 "
ptclFullChipErase
} $PASS
test flash-2.18 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.18 ==========="
log_message "test flash-2.18 "
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.19 {Read from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.19 ==========="
log_message "test flash-2.19 "
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.20 {Erase Block 0} {
#dbgShowInfo "============ test flash-2.20 ==========="
log_message "test flash-2.20 "
ptclEraseBlock0
} $PASS
test flash-2.21 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.21 ==========="
log_message "test flash-2.21 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {2000}
test flash-2.22 {Erase Block 1} {
#dbgShowInfo "============ test flash-2.22 ==========="
log_message "test flash-2.22 "
ptclEraseBlock1
} $PASS
test flash-2.23 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23 ==========="
log_message "test flash-2.23 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {4000}
test flash-2.23.1 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23.1 ==========="
log_message "test flash-2.23.1"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.24 {Erase Block 2} {
#dbgShowInfo "============ test flash-2.24 ==========="
log_message "test flash-2.24 "
ptclEraseBlock2
} $PASS
test flash-2.25 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.25 ==========="
log_message "test flash-2.25 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.26 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.26 ==========="
log_message "test flash-2.26"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {8000}
test flash-2.27 {Erase Block 3} {
#dbgShowInfo "============ test flash-2.27 ==========="
log_message "test flash-2.27"
ptclEraseBlock3
} $PASS
test flash-2.28 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.28 ==========="
log_message "test flash-2.28"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {C000}
test flash-2.29 {Erase Block 4} {
#dbgShowInfo "============ test flash-2.29 ==========="
log_message "test flash-2.29"
ptclEraseBlock4
} $PASS
test flash-2.30 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.30 ==========="
log_message "test flash-2.30"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg red]
#dbgShowInfo  "***************** FUSE TESTS *******************"
test fuse-3.0 {Full Chip Erase} {
#dbgShowInfo "============ test fuse-3.0 ==========="
log_message "test fuse-3.0"
ptclFullChipErase
} $PASS
test fuse-3.1 {Write HSB = 0xFF} {
#dbgShowInfo "============ test fuse-3.1 ==========="
log_message "test fuse-3.1"
ptclWriteHwByte "FF"
} $PASS
test fuse-3.2 {Read HSB} {
#dbgShowInfo "============ test fuse-3.2 ==========="
log_message "test fuse-3.2"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {F0}
test fuse-3.3 {Write HSB = 0x0F} {
#dbgShowInfo "============ test fuse-3.3 ==========="
log_message "test fuse-3.3"
ptclWriteHwByte "0F"
} $PASS
test fuse-3.4 {Read HSB} {
#dbgShowInfo "============ test fuse-3.4 ==========="
log_message "test fuse-3.4"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {00}
test fuse-3.5 {Write SSB = level 1} {
#dbgShowInfo "============ test fuse-3.5 ==========="
log_message "test fuse-3.5"
ptclProgSSBlev1
} $PASS
test fuse-3.6 {Read SSB} {
#dbgShowInfo "============ test fuse-3.6 ==========="
log_message "test fuse-3.6"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test fuse-3.7 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.7 ==========="
log_message "test fuse-3.7"
ptclWriteHwByte "5F"
set errCode
} {-12}
test fuse-3.8 {Read HSB} {
#dbgShowInfo "============ test fuse-3.8 ==========="
log_message "test fuse-3.8"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {00}
test fuse-3.9 {Write SSB = level 2} {
#dbgShowInfo "============ test fuse-3.9 ==========="
log_message "test fuse-3.9"
ptclProgSSBlev2
} $PASS
test fuse-3.10 {Read SSB} {
#dbgShowInfo "============ test fuse-3.10 ==========="
log_message "test fuse-3.10"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test fuse-3.11 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.11 ==========="
log_message "test fuse-3.11"
ptclWriteHwByte "5F"
set errCode
} {-12}
test fuse-3.12 {Read HSB} {
#dbgShowInfo "============ test fuse-3.12 ==========="
log_message "test fuse-3.12"
ptclReadHwByte
set errCode
} {-12}
test fuse-3.13 {Full Chip Erase} {
#dbgShowInfo "============ test fuse-3.13 ==========="
log_message "test fuse-3.13"
ptclFullChipErase
} $PASS
test fuse-3.14 {Read HSB} {
#dbgShowInfo "============ test fuse-3.14 ==========="
log_message "test fuse-3.14"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {00}
test fuse-3.15 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.15 ==========="
log_message "test fuse-3.15"
ptclWriteHwByte "5F"
} $PASS
test fuse-3.16 {Read HSB} {
#dbgShowInfo "============ test fuse-3.16 ==========="
log_message "test fuse-3.16"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {50}
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg red]
debug_log "********* SPECIFIC INFORMATIONS **********"
test specific-4.0 {Full Chip Erase} {
#dbgShowInfo "============ test Specific-4.0 ==========="
log_message "test Specific-4.0"
ptclFullChipErase
} $PASS
test specific-4.1 {Read Bootloader Version} {
#dbgShowInfo "============ test Specific-4.1 ==========="
log_message "test Specific-4.1"
ptclReadBootlVer
} $PASS
test specific-4.2 {Read Device Boot Id 1} {
#dbgShowInfo "============ test Specific-4.2 ==========="
log_message "test Specific-4.2"
ptclReadDevBootId1
} $PASS
test specific-4.3 {Read Device Boot Id 2} {
#dbgShowInfo "============ test Specific-4.3 ==========="
log_message "test Specific-4.3"
ptclReadDevBootId2
} $PASS
test specific-4.4 {Read Manuf Id} {
#dbgShowInfo "============ test Specific-4.4 ==========="
log_message "test Specific-4.4"
ptclReadManufId
} $PASS
test specific-4.5 {Read Device Id 1} {
#dbgShowInfo "============ test Specific-4.5 ==========="
log_message "test Specific-4.5"
ptclReadDeviceId1
} $PASS
test specific-4.6 {Read Device Id 2} {
#dbgShowInfo "============ test Specific-4.6 ==========="
log_message "test Specific-4.6"
ptclReadDeviceId2
} $PASS
test specific-4.7 {Read Device Id 3} {
#dbgShowInfo "============ test Specific-4.7 ==========="
log_message "test Specific-4.7"
ptclReadDeviceId3
} $PASS
test specific-4.8 {Write SSB = level 2} {
#dbgShowInfo "============ test Specific-4.8 ==========="
log_message "test Specific-4.8"
ptclProgSSBlev2
} $PASS
test specific-4.9 {Read SSB} {
#dbgShowInfo "============ test Specific-4.9 ==========="
log_message "test Specific-4.9"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test specific-4.10 {Read Bootloader Version} {
#dbgShowInfo "============ test Specific-4.10 ==========="
log_message "test Specific-4.10"
ptclReadBootlVer
set errCode
} {-12}
test specific-4.11 {Read Device Boot Id 1} {
#dbgShowInfo "============ test Specific-4.11 ==========="
log_message "test Specific-4.11"
ptclReadDevBootId1
set errCode
} {-12}
test specific-4.12 {Read Device Boot Id 2} {
#dbgShowInfo "============ test Specific-4.12 ==========="
log_message "test Specific-4.12"
ptclReadDevBootId2
set errCode
} {-12}
test specific-4.13 {Read Manuf Id} {
#dbgShowInfo "============ test Specific-4.13 ==========="
log_message "test Specific-4.13"
ptclReadManufId
set errCode
} {-12}
test specific-4.14 {Read Device Id 1} {
#dbgShowInfo "============ test Specific-4.14 ==========="
log_message "test Specific-4.14"
ptclReadDeviceId1
set errCode
} {-12}
test specific-4.15 {Read Device Id 2} {
#dbgShowInfo "============ test Specific-4.15 ==========="
log_message "test Specific-4.15"
ptclReadDeviceId2
set errCode
} {-12}
test specific-4.16 {Read Device Id 3} {
#dbgShowInfo "============ test Specific-4.16 ==========="
log_message "test Specific-4.16"
ptclReadDeviceId3
set errCode
} {-12}
test specific-4.17 {Full Chip Erase} {
#dbgShowInfo "============ test Specific-4.17 ==========="
log_message "test Specific-4.17"
ptclFullChipErase
} $PASS
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg black]
if {[string first "EEPROM" [namespace children ::]] != -1} then {
    cmdsImportCurrentMemoryNameSpace "EEPROM"
    catch [.testSelectionDbox.f_skip.b_skip6 configure -fg red]
    #dbgShowInfo "**************** EEPROM *****************"
    test eeprom-6.0 {Fill EEPROM with 0xFF} {
#dbgShowInfo "============ test eeprom-6.0 ==========="
log_message "test eeprom-6.0"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.1 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.1 ==========="
log_message "test eeprom-6.1"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "FF"
} $PASS
    test eeprom-6.2 {Fill EEPROM with 0x00} {
#dbgShowInfo "============ test eeprom-6.2 ==========="
log_message "test eeprom-6.2"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.3 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.3 ==========="
log_message "test eeprom-6.3"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "00"
} $PASS
    test eeprom-6.4 {Fill EEPROM with 0x55} {
#dbgShowInfo "============ test eeprom-6.4 ==========="
log_message "test eeprom-6.4"
fillBuffer "000000" [readBuffer maxAddr] "55"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.5 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.5 ==========="
log_message "test eeprom-6.5"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "55"
} $PASS
    test eeprom-6.6 {Fill EEPROM with 0xAA} {
#dbgShowInfo "============ test eeprom-6.6 ==========="
log_message "test eeprom-6.6"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.7 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.7 ==========="
log_message "test eeprom-6.7"
fillBuffer "000000" [readBuffer maxAddr] "55"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "AA"
} $PASS
    test eeprom-6.8 {Fill EEPROM with 0xFF} {
#dbgShowInfo "============ test eeprom-6.8 ==========="
log_message "test eeprom-6.8"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.9 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.9 ==========="
log_message "test eeprom-6.9"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "FF"
} $PASS
    catch [.testSelectionDbox.f_skip.b_skip6 configure -fg black]
    cmdsImportCurrentMemoryNameSpace "FLASH"
}
::tcltest::cleanupTests
log_message "CANstd tests completed. Check the log file for errors."
cmdsRestoreSpecialBytes
set flipStates(mssgBox) 1
return
#dbgEndSrc [info script]    #dbgBeginSrc [info script]
global buffer
debug_log "file: /tests/non_regr.tcl"
if {[lsearch [namespace children] ::tcltest] == -1} then {
    package require tcltest
    namespace import ::tcltest::*
}
set ::tcltest::verbose "bps"
debug_log "******************************************"
debug_log "********* NON REGRESSION TESTS ***********"
debug_log "******************************************"
return
debug_log "********* INITIALIZATION TESTS ***********"
test initialization-1.0 {Check the buffer options after init} {
init
} {65556 0xFFFF}
test initialization-1.1 {Check the buffer first/last addresses contents after reset} {
resetBuffer
} {64 0xFFFF FF FF}
debug_log "************** FILE TESTS ****************"
test files-2.0 {Create the devices files list} {
buildDeviceFilesList
} {coyote.dat racoon.dat}
test files-2.1 {Create the devices list when files exist} {
buildDeviceList "coyote.dat racoon.dat"
} {coyote racoon}
test files-2.2 {Display warning when files do not exist} {
buildDeviceList "device1.no device2.no"
} 0
test files-2.3 {Check file pathname - empty path} {
checkFilePathname ""
} 0
test files-2.4 {Check file pathname - dir does not exist} {
checkFilePathname "/dummy/foo/crash.txt"
} -1
debug_log "******** DEVICE DEPENDENT TESTS **********"
set device coyote
test devices-3.0 {Check the device dependencies} {
cbOnDeviceSelection $device
} {deviceDependent deviceDependent normal}
test devices-3.1 {Device selected => update GUI dependencies} {
updateStatesAndGui $device
list [readBuffer sizeType] [readBuffer blankValueType]
} {deviceDependent deviceDependent}
::tcltest::cleanupTests
log_message "Non regression tests completed. Check the log file for errors."
debug_log "******************************************"
return
#dbgEndSrc [info script]                       #dbgBeginSrc [info script]
global buffer protocol expAnsw testFlag canProtocol waitTime doTestArray flipStates errCode
if {[lsearch [namespace children] ::tcltest] == -1} then {
    package require tcltest
    namespace import ::tcltest::*
}
set skipList {}
foreach test [array names doTestArray] {
    if {! $doTestArray($test)} then {
	append skipList " ${test}* "
    }
}
if {[info exists ::deviceArray(skipList)]} then {
    append skipList $::deviceArray(skipList)
}
set ::tcltest::skip $skipList
#dbgShowVar "skip = $::tcltest::skip"
set flipStates(mssgBox) 0
set ::tcltest::verbose "bps"
set PASS 1
set FAIL 0
cmdsReadSpecialBytes
debug_log "******************************************"
debug_log "********** CAN Standard TESTS ************"
debug_log "******************************************"
cmdsImportCurrentMemoryNameSpace "FLASH"
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg red]
debug_log "*************** XAF TESTS ****************"
test xaf-1.0 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.0 ==========="
log_message "test xaf-1.0 "
ptclFullChipErase
} $PASS
test xaf-1.1 {Write BSB = 0x55} {
#dbgShowInfo "============ test xaf-1.1 ==========="
log_message "test xaf-1.1 "
ptclWriteBSB "55"
} $PASS
test xaf-1.2 {Read BSB} {
#dbgShowInfo "============ test xaf-1.2 ==========="
log_message "test xaf-1.2 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.3 {Write SBV = 0x55} {
#dbgShowInfo "============ test xaf-1.3 ==========="
log_message "test xaf-1.3 "
ptclWriteSBV "55"
} $PASS
test xaf-1.4 {Read SBV} {
#dbgShowInfo "============ test xaf-1.4 ==========="
log_message "test xaf-1.4 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.5 {Write EB = 0x55} {
#dbgShowInfo "============ test xaf-1.5 ==========="
log_message "test xaf-1.5 "
ptclWriteEB "55"
} $PASS
test xaf-1.6 {Read EB} {
#dbgShowInfo "============ test xaf-1.6 ==========="
log_message "test xaf-1.6 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.7 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.7 ==========="
log_message "test xaf-1.7 "
ptclProgSSBlev1
} $PASS
test xaf-1.8 {Read SSB} {
#dbgShowInfo "============ test xaf-1.8 ==========="
log_message "test xaf-1.8 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test xaf-1.9 {Write BSB = 0xAA} {
#dbgShowInfo "============ test xaf-1.9 ==========="
log_message "test xaf-1.9 "
ptclWriteBSB "AA"
set errCode
} {-12}
test xaf-1.10 {Read BSB} {
#dbgShowInfo "============ test xaf-1.10 ==========="
log_message "test xaf-1.10 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.11 {Write SBV = 0xAA} {
#dbgShowInfo "============ test xaf-1.11 ==========="
log_message "test xaf-1.11 "
ptclWriteSBV "AA"
set errCode
} {-12}
test xaf-1.12 {Read SBV} {
#dbgShowInfo "============ test xaf-1.12 ==========="
log_message "test xaf-1.12 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.13 {Write EB = 0xAA} {
#dbgShowInfo "============ test xaf-1.13 ==========="
log_message "test xaf-1.13 "
ptclWriteEB "AA"
set errCode
} {-12}
test xaf-1.14 {Read EB} {
#dbgShowInfo "============ test xaf-1.14 ==========="
log_message "test xaf-1.14 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.15 {Write SSB = level 2} {
#dbgShowInfo "============ test xaf-1.15 ==========="
log_message "test xaf-1.15 "
ptclProgSSBlev2
} $PASS
test xaf-1.16 {Read SSB} {
#dbgShowInfo "============ test xaf-1.16 ==========="
log_message "test xaf-1.16 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.17 {Write BSB = 0x00} {
#dbgShowInfo "============ test xaf-1.17 ==========="
log_message "test xaf-1.17 "
ptclWriteBSB "00"
set errCode
} {-12}
test xaf-1.18 {Read BSB} {
#dbgShowInfo "============ test xaf-1.18 ==========="
log_message "test xaf-1.18 "
ptclReadBSB
set errCode
} {-12}
test xaf-1.19 {Write SBV = 0x00} {
#dbgShowInfo "============ test xaf-1.19 ==========="
log_message "test xaf-1.19 "
ptclWriteSBV "00"
set errCode
} {-12}
test xaf-1.20 {Read SBV} {
#dbgShowInfo "============ test xaf-1.20 ==========="
log_message "test xaf-1.20 "
ptclReadSBV
set errCode
} {-12}
test xaf-1.21 {Write EB = 0x00} {
#dbgShowInfo "============ test xaf-1.21 ==========="
log_message "test xaf-1.21 "
ptclWriteEB "00"
set errCode
} {-12}
test xaf-1.22 {Read EB} {
#dbgShowInfo "============ test xaf-1.22 ==========="
log_message "test xaf-1.22 "
ptclReadEB
set errCode
} {-12}
test xaf-1.23 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.23 ==========="
log_message "test xaf-1.23 "
ptclProgSSBlev1
set errCode
} {-12}
test xaf-1.24 {Read SSB} {
#dbgShowInfo "============ test xaf-1.24 ==========="
log_message "test xaf-1.24 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.25 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.25 ==========="
log_message "test xaf-1.25 "
ptclFullChipErase
} $PASS
test xaf-1.26 {Read BSB} {
#dbgShowInfo "============ test xaf-1.26 ==========="
log_message "test xaf-1.26 "
ptclReadBSB
set ::deviceArray(bsb)
} {FF}
test xaf-1.27 {Read SBV} {
#dbgShowInfo "============ test xaf-1.27 ==========="
log_message "test xaf-1.27 "
ptclReadSBV
set ::deviceArray(sbv)
} {FF}
test xaf-1.28 {Read EB} {
#dbgShowInfo "============ test xaf-1.28 ==========="
log_message "test xaf-1.28 "
ptclReadEB
set ::deviceArray(eb)
} {FF}
test xaf-1.29 {Read SSB} {
#dbgShowInfo "============ test xaf-1.29 ==========="
log_message "test xaf-1.29 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev0Test)
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg red]
debug_log "**************** FLASH *******************"
test flash-2.0 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.0 ==========="
log_message "test flash-2.0 "
ptclFullChipErase
} $PASS
test flash-2.1 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.1 ==========="
log_message "test flash-2.1 "
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.2 {Read from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.2 ==========="
log_message "test flash-2.2 "
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.3 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.3 ==========="
log_message "test flash-2.3 "
ptclFullChipErase
} $PASS
test flash-2.4 {Write AA at address 0X1FFF} {
#dbgShowInfo "============ test flash-2.4 ==========="
log_message "test flash-2.4 "
fillBuffer "001FFF" "001FFF" "AA"
cmdsDeviceProgram "001FFF" "001FFF"
} $PASS
test flash-2.5 {Read at address 0X1FFF} {
#dbgShowInfo "============ test flash-2.5 ==========="
log_message "test flash-2.5 "
cmdsReadAddrRange "001FFF" "001FFF"
checkBuffer "001FFF" "001FFF" "AA"
} $PASS
test flash-2.6 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.6 ==========="
log_message "test flash-2.6 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {1FFF}
test flash-2.7 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.7 ==========="
log_message "test flash-2.7 "
ptclFullChipErase
} $PASS
test flash-2.8 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.8 ==========="
log_message "test flash-2.8 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.9 {Write SSB = level 1} {
#dbgShowInfo "============ test flash-2.9 ==========="
log_message "test flash-2.9 "
ptclProgSSBlev1
} $PASS
test flash-2.10 {Read SSB} {
#dbgShowInfo "============ test flash-2.10 ==========="
log_message "test flash-2.10 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test flash-2.11 {Write AA at address 1FFF} {
#dbgShowInfo "============ test flash-2.11 ==========="
log_message "test flash-2.11 "
fillBuffer "001FFF" "001FFF" "AA"
cmdsDeviceProgram "001FFF" "001FFF"
set errCode
} {-12}
test flash-2.12 {Read at address 1FFF} {
#dbgShowInfo "============ test flash-2.12 ==========="
log_message "test flash-2.12 "
cmdsReadAddrRange "001FFF" "001FFF"
checkBuffer "001FFF" "001FFF" "AA"
} {001FFF}
test flash-2.13 {Write SSB = level 2} {
#dbgShowInfo "============ test flash-2.13 ==========="
log_message "test flash-2.13 "
ptclProgSSBlev2
} $PASS
test flash-2.14 {Read SSB} {
#dbgShowInfo "============ test flash-2.14 ==========="
log_message "test flash-2.14 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test flash-2.15 {Write AA at address 1FFF} {
#dbgShowInfo "============ test flash-2.15 ==========="
log_message "test flash-2.15 "
fillBuffer "001FFF" "001FFF" "AA"
cmdsDeviceProgram "001FFF" "001FFF"
set errCode
} {-12}
test flash-2.16 {Read at address 1FFF} {
#dbgShowInfo "============ test flash-2.16 ==========="
log_message "test flash-2.16 "
cmdsReadAddrRange "001FFF" "001FFF"
checkBuffer "001FFF" "001FFF" "AA"
set errCode
} {-12}
test flash-2.17 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.17 ==========="
log_message "test flash-2.17 "
ptclFullChipErase
} $PASS
test flash-2.18 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.18 ==========="
log_message "test flash-2.18 "
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.19 {Read from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.19 ==========="
log_message "test flash-2.19 "
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.20 {Erase Block 0} {
#dbgShowInfo "============ test flash-2.20 ==========="
log_message "test flash-2.20 "
ptclEraseBlock0
} $PASS
test flash-2.21 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.21 ==========="
log_message "test flash-2.21 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {2000}
test flash-2.22 {Erase Block 1} {
#dbgShowInfo "============ test flash-2.22 ==========="
log_message "test flash-2.22 "
ptclEraseBlock1
} $PASS
test flash-2.23 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23 ==========="
log_message "test flash-2.23 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {4000}
test flash-2.23.1 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23.1 ==========="
log_message "test flash-2.23.1"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.24 {Erase Block 2} {
#dbgShowInfo "============ test flash-2.24 ==========="
log_message "test flash-2.24 "
ptclEraseBlock2
} $PASS
test flash-2.25 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.25 ==========="
log_message "test flash-2.25 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.26 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.26 ==========="
log_message "test flash-2.26"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {8000}
test flash-2.27 {Erase Block 3} {
#dbgShowInfo "============ test flash-2.27 ==========="
log_message "test flash-2.27"
ptclEraseBlock3
} $PASS
test flash-2.28 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.28 ==========="
log_message "test flash-2.28"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {C000}
test flash-2.29 {Erase Block 4} {
#dbgShowInfo "============ test flash-2.29 ==========="
log_message "test flash-2.29"
ptclEraseBlock4
} $PASS
test flash-2.30 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.30 ==========="
log_message "test flash-2.30"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg red]
#dbgShowInfo  "***************** FUSE TESTS *******************"
test fuse-3.0 {Full Chip Erase} {
#dbgShowInfo "============ test fuse-3.0 ==========="
log_message "test fuse-3.0"
ptclFullChipErase
} $PASS
test fuse-3.1 {Write HSB = 0xFF} {
#dbgShowInfo "============ test fuse-3.1 ==========="
log_message "test fuse-3.1"
ptclWriteHwByte "FF"
} $PASS
test fuse-3.2 {Read HSB} {
#dbgShowInfo "============ test fuse-3.2 ==========="
log_message "test fuse-3.2"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {F0}
test fuse-3.3 {Write HSB = 0x0F} {
#dbgShowInfo "============ test fuse-3.3 ==========="
log_message "test fuse-3.3"
ptclWriteHwByte "0F"
} $PASS
test fuse-3.4 {Read HSB} {
#dbgShowInfo "============ test fuse-3.4 ==========="
log_message "test fuse-3.4"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {00}
test fuse-3.5 {Write SSB = level 1} {
#dbgShowInfo "============ test fuse-3.5 ==========="
log_message "test fuse-3.5"
ptclProgSSBlev1
} $PASS
test fuse-3.6 {Read SSB} {
#dbgShowInfo "============ test fuse-3.6 ==========="
log_message "test fuse-3.6"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test fuse-3.7 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.7 ==========="
log_message "test fuse-3.7"
ptclWriteHwByte "5F"
set errCode
} {-12}
test fuse-3.8 {Read HSB} {
#dbgShowInfo "============ test fuse-3.8 ==========="
log_message "test fuse-3.8"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {00}
test fuse-3.9 {Write SSB = level 2} {
#dbgShowInfo "============ test fuse-3.9 ==========="
log_message "test fuse-3.9"
ptclProgSSBlev2
} $PASS
test fuse-3.10 {Read SSB} {
#dbgShowInfo "============ test fuse-3.10 ==========="
log_message "test fuse-3.10"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test fuse-3.11 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.11 ==========="
log_message "test fuse-3.11"
ptclWriteHwByte "5F"
set errCode
} {-12}
test fuse-3.12 {Read HSB} {
#dbgShowInfo "============ test fuse-3.12 ==========="
log_message "test fuse-3.12"
ptclReadHwByte
set errCode
} {-12}
test fuse-3.13 {Full Chip Erase} {
#dbgShowInfo "============ test fuse-3.13 ==========="
log_message "test fuse-3.13"
ptclFullChipErase
} $PASS
test fuse-3.14 {Read HSB} {
#dbgShowInfo "============ test fuse-3.14 ==========="
log_message "test fuse-3.14"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {00}
test fuse-3.15 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.15 ==========="
log_message "test fuse-3.15"
ptclWriteHwByte "5F"
} $PASS
test fuse-3.16 {Read HSB} {
#dbgShowInfo "============ test fuse-3.16 ==========="
log_message "test fuse-3.16"
ptclReadHwByte
set result [format %02X [expr 0X$::deviceArray(hsb) & 0XF0]]
} {50}
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg red]
debug_log "********* SPECIFIC INFORMATIONS **********"
test specific-4.0 {Full Chip Erase} {
#dbgShowInfo "============ test Specific-4.0 ==========="
log_message "test Specific-4.0"
ptclFullChipErase
} $PASS
test specific-4.1 {Read Bootloader Version} {
#dbgShowInfo "============ test Specific-4.1 ==========="
log_message "test Specific-4.1"
ptclReadBootlVer
} $PASS
test specific-4.2 {Read Device Boot Id 1} {
#dbgShowInfo "============ test Specific-4.2 ==========="
log_message "test Specific-4.2"
ptclReadDevBootId1
} $PASS
test specific-4.3 {Read Device Boot Id 2} {
#dbgShowInfo "============ test Specific-4.3 ==========="
log_message "test Specific-4.3"
ptclReadDevBootId2
} $PASS
test specific-4.4 {Read Manuf Id} {
#dbgShowInfo "============ test Specific-4.4 ==========="
log_message "test Specific-4.4"
ptclReadManufId
} $PASS
test specific-4.5 {Read Device Id 1} {
#dbgShowInfo "============ test Specific-4.5 ==========="
log_message "test Specific-4.5"
ptclReadDeviceId1
} $PASS
test specific-4.6 {Read Device Id 2} {
#dbgShowInfo "============ test Specific-4.6 ==========="
log_message "test Specific-4.6"
ptclReadDeviceId2
} $PASS
test specific-4.7 {Read Device Id 3} {
#dbgShowInfo "============ test Specific-4.7 ==========="
log_message "test Specific-4.7"
ptclReadDeviceId3
} $PASS
test specific-4.8 {Write SSB = level 2} {
#dbgShowInfo "============ test Specific-4.8 ==========="
log_message "test Specific-4.8"
ptclProgSSBlev2
} $PASS
test specific-4.9 {Read SSB} {
#dbgShowInfo "============ test Specific-4.9 ==========="
log_message "test Specific-4.9"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test specific-4.10 {Read Bootloader Version} {
#dbgShowInfo "============ test Specific-4.10 ==========="
log_message "test Specific-4.10"
ptclReadBootlVer
set errCode
} {-12}
test specific-4.11 {Read Device Boot Id 1} {
#dbgShowInfo "============ test Specific-4.11 ==========="
log_message "test Specific-4.11"
ptclReadDevBootId1
set errCode
} {-12}
test specific-4.12 {Read Device Boot Id 2} {
#dbgShowInfo "============ test Specific-4.12 ==========="
log_message "test Specific-4.12"
ptclReadDevBootId2
set errCode
} {-12}
test specific-4.13 {Read Manuf Id} {
#dbgShowInfo "============ test Specific-4.13 ==========="
log_message "test Specific-4.13"
ptclReadManufId
set errCode
} {-12}
test specific-4.14 {Read Device Id 1} {
#dbgShowInfo "============ test Specific-4.14 ==========="
log_message "test Specific-4.14"
ptclReadDeviceId1
set errCode
} {-12}
test specific-4.15 {Read Device Id 2} {
#dbgShowInfo "============ test Specific-4.15 ==========="
log_message "test Specific-4.15"
ptclReadDeviceId2
set errCode
} {-12}
test specific-4.16 {Read Device Id 3} {
#dbgShowInfo "============ test Specific-4.16 ==========="
log_message "test Specific-4.16"
ptclReadDeviceId3
set errCode
} {-12}
test specific-4.17 {Full Chip Erase} {
#dbgShowInfo "============ test Specific-4.17 ==========="
log_message "test Specific-4.17"
ptclFullChipErase
} $PASS
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg black]
::tcltest::cleanupTests
log_message "CANstd tests completed. Check the log file for errors."
cmdsRestoreSpecialBytes
set flipStates(mssgBox) 1
return
#dbgEndSrc [info script]                          #dbgBeginSrc [info script]
global buffer protocol expAnsw testFlag flipStates waitTime doTestArray errCode
global bootloaderVerDependent
if {[lsearch [namespace children] ::tcltest] == -1} then {
    package require tcltest
    namespace import ::tcltest::*
}
set skipList {}
foreach test [array names doTestArray] {
    if {! $doTestArray($test)} then {
	append skipList " ${test}* "
    }
}
if {[info exists ::deviceArray(skipList)]} then {
    append skipList $::deviceArray(skipList)
}
set skipEB "  xaf-1.5  xaf-1.6  xaf-1.13  xaf-1.14  xaf-1.21  xaf-1.22  xaf-1.28 "
set skipEEPROM " eeprom-*"
if {! $bootloaderVerDependent(eb)} then {
    append skipList $skipEB
}
if {! $bootloaderVerDependent(eeprom)} then {
    append skipList $skipEEPROM
}
set ::tcltest::skip $skipList
#dbgShowVar "skip = $::tcltest::skip"
set flipStates(mssgBox) 0
set ::tcltest::verbose "bps"
set FAIL 0
set PASS 1
set DONTCARE 2
cmdsReadSpecialBytes
#dbgShowInfo "******************************************"
#dbgShowInfo "************ RS232STD TESTS **************"
#dbgShowInfo "******************************************"
set ::tcltest::testConstraints(constraint) 1
cmdsImportCurrentMemoryNameSpace "FLASH"
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg red]
#dbgShowInfo "*************** XAF TESTS ****************"
test xaf-1.0 {Full Chip Erase} {constraint} {
#dbgShowInfo "============ test xaf-1.0 ==========="
log_message "test xaf-1.0"
ptclFullChipErase
} $PASS
test xaf-1.1 {Write BSB = 0x55} {
#dbgShowInfo "============ test xaf-1.1 ==========="
log_message "test xaf-1.1"
ptclWriteBSB "55"
} $PASS
test xaf-1.2 {Read BSB} {
#dbgShowInfo "============ test xaf-1.2 ==========="
log_message "test xaf-1.2"
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.3 {Write SBV = 0x55} {
#dbgShowInfo "============ test xaf-1.3 ==========="
log_message "test xaf-1.3"
ptclWriteSBV "55"
} $PASS
test xaf-1.4 {Read SBV} {
#dbgShowInfo "============ test xaf-1.4 ==========="
log_message "test xaf-1.4"
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.5 {Write EB = 0x55} {
#dbgShowInfo "============ test xaf-1.5 ==========="
log_message "test xaf-1.5 "
ptclWriteEB "55"
} $PASS
test xaf-1.6 {Read EB} {
#dbgShowInfo "============ test xaf-1.6 ==========="
log_message "test xaf-1.6 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.7 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.7 ==========="
log_message "test xaf-1.7"
ptclProgSSBlev1
} $PASS
test xaf-1.8.1 {Read SSB} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.8.1 ==========="
log_message "test xaf-1.8.1"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1)
test xaf-1.8.2 {Read SSB} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.8.2 ==========="
log_message "test xaf-1.8.2"
ptclReadSSB
set ssb [format %02X [expr 0X0F & 0X$::deviceArray(ssb)]]
} $expAnsw(readSSBlev1Test)
test xaf-1.9 {Write BSB = 0xAA} {
#dbgShowInfo "============ test xaf-1.9 ==========="
log_message "test xaf-1.9"
ptclWriteBSB "AA"
set errCode
} {-12}
test xaf-1.10 {Read BSB} {
#dbgShowInfo "============ test xaf-1.10 ==========="
log_message "test xaf-1.10"
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.11 {Write SBV = 0xAA} {
#dbgShowInfo "============ test xaf-1.11 ==========="
log_message "test xaf-1.11"
ptclWriteSBV "AA"
set errCode
} {-12}
test xaf-1.12 {Read SBV} {
#dbgShowInfo "============ test xaf-1.12 ==========="
log_message "test xaf-1.12"
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.13 {Write EB = 0xAA} {
#dbgShowInfo "============ test xaf-1.13 ==========="
log_message "test xaf-1.13 "
ptclWriteEB "AA"
set errCode
} {-12}
test xaf-1.14 {Read EB} {
#dbgShowInfo "============ test xaf-1.14 ==========="
log_message "test xaf-1.14 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.15 {Write SSB = level 2} {
#dbgShowInfo "============ test xaf-1.15 ==========="
log_message "test xaf-1.15"
ptclProgSSBlev2
} $PASS
test xaf-1.16.1 {Read SSB} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.16.1 ==========="
log_message "test xaf-1.16.1"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.16.2 {Read SSB} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.16.2 ==========="
log_message "test xaf-1.16.2"
ptclReadSSB
set ssb [format %02X [expr 0X0F & 0X$::deviceArray(ssb)]]
} $expAnsw(readSSBlev2Test)
test xaf-1.17 {Write BSB = 0x00} {
#dbgShowInfo "============ test xaf-1.17 ==========="
log_message "test xaf-1.17"
ptclWriteBSB "00"
set errCode
} {-12}
test xaf-1.18 {Read BSB} {
#dbgShowInfo "============ test xaf-1.18 ==========="
log_message "test xaf-1.18"
ptclReadBSB
set errCode
} {-12}
test xaf-1.19 {Write SBV = 0x00} {
#dbgShowInfo "============ test xaf-1.19 ==========="
log_message "test xaf-1.19"
ptclWriteSBV "00"
set errCode
} {-12}
test xaf-1.20 {Read SBV} {
#dbgShowInfo "============ test xaf-1.20 ==========="
log_message "test xaf-1.20"
ptclReadSBV
set errCode
} {-12}
test xaf-1.21 {Write EB = 0x00} {
#dbgShowInfo "============ test xaf-1.21 ==========="
log_message "test xaf-1.21 "
ptclWriteEB "00"
set errCode
} {-12}
test xaf-1.22 {Read EB} {
#dbgShowInfo "============ test xaf-1.22 ==========="
log_message "test xaf-1.22 "
ptclReadEB
set errCode
} {-12}
test xaf-1.23 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.23 ==========="
log_message "test xaf-1.23"
ptclProgSSBlev1
set errCode
} {-12}
test xaf-1.24.1 {Read SSB} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.24.1 ==========="
log_message "test xaf-1.24.1"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.24.2 {Read SSB} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.24.2 ==========="
log_message "test xaf-1.24.2"
ptclReadSSB
set ssb [format %02X [expr 0X0F & 0X$::deviceArray(ssb)]]
} $expAnsw(readSSBlev2Test)
test xaf-1.25 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.25 ==========="
log_message "test xaf-1.25"
ptclFullChipErase
} $PASS
test xaf-1.26 {Read BSB} {
#dbgShowInfo "============ test xaf-1.26 ==========="
log_message "test xaf-1.26"
ptclReadBSB
set ::deviceArray(bsb)
} {FF}
test xaf-1.27 {Read SBV} {
#dbgShowInfo "============ test xaf-1.27 ==========="
log_message "test xaf-1.27"
ptclReadSBV
set ::deviceArray(sbv)
} $testFlag(sbv)
test xaf-1.28 {Read EB} {
#dbgShowInfo "============ test xaf-1.28 ==========="
log_message "test xaf-1.28 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.29.1 {Read SSB} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.29.1 ==========="
log_message "test xaf-1.29.1"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev0)
test xaf-1.29.2 {Read SSB} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test xaf-1.29.2 ==========="
log_message "test xaf-1.29.2"
ptclReadSSB
set ssb [format %02X [expr 0X0F & 0X$::deviceArray(ssb)]]
} $expAnsw(readSSBlev0Test)
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg red]
#dbgShowInfo "**************** FLASH *******************"
test flash-2.0 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.0 ==========="
log_message "test flash-2.0"
ptclFullChipErase
} $PASS
test flash-2.1 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.1 ==========="
log_message "test flash-2.1"
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.2.1 {Read from 0000 to [readBuffer maxAddr]} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.2.1 ==========="
log_message "test flash-2.2.1"
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.2.2 {Read from 0000 to [readBuffer maxAddr] - 3} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.2.2 ==========="
log_message "test flash-2.2.2"
cmdsDeviceVerify 0 [expr 0X[readBuffer maxAddr] - 0X3]
} $PASS
test flash-2.3 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.3 ==========="
log_message "test flash-2.3"
ptclFullChipErase
} $PASS
test flash-2.4 {Write AA at address 7FF} {
#dbgShowInfo "============ test flash-2.4 ==========="
log_message "test flash-2.4"
set x $::deviceArray(bootloaderId)
set ::deviceArray(bootloaderId) "0000"
fillBuffer "000000" "0007FE" "FF"
fillBuffer "0007FF" "0007FF" "AA"
set status [cmdsDeviceProgram "0007FF" "0007FF"]
set ::deviceArray(bootloaderId) $x
set status
} $PASS
test flash-2.5 {Read at address 07FF} {
#dbgShowInfo "============ test flash-2.5 ==========="
log_message "test flash-2.5"
cmdsReadAddrRange "0007FF" "0007FF"
checkBuffer "0007FF" "0007FF" "AA"
} $PASS
test flash-2.6 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.6 ==========="
log_message "test flash-2.6"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {07FF}
test flash-2.7 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.7 ==========="
log_message "test flash-2.7"
ptclFullChipErase
} $PASS
test flash-2.8 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.8 ==========="
log_message "test flash-2.8"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.9 {Write SSB = level 1} {
#dbgShowInfo "============ test flash-2.9 ==========="
log_message "test flash-2.9"
ptclProgSSBlev1
} $PASS
test flash-2.10.1 {Read SSB} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.10.1 ==========="
log_message "test flash-2.10.1"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1)
test flash-2.10.2 {Read SSB} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.10.2 ==========="
log_message "test flash-2.10.2"
ptclReadSSB
set ssb [format %02X [expr 0X0F & 0X$::deviceArray(ssb)]]
} $expAnsw(readSSBlev1Test)
test flash-2.11 {Write AA at address 07FF} {
#dbgShowInfo "============ test flash-2.11 ==========="
log_message "test flash-2.11"
fillBuffer "0007FF" "0007FF" "AA"
cmdsDeviceProgram "0007FF" "0007FF"
set errCode
} {-12}
test flash-2.12 {Read at address 07FF} {
#dbgShowInfo "============ test flash-2.12 ==========="
log_message "test flash-2.12"
cmdsReadAddrRange "0007FF" "0007FF"
checkBuffer "0007FF" "0007FF" "AA"
} {0007FF}
test flash-2.13 {Write SSB = level 2} {
#dbgShowInfo "============ test flash-2.13 ==========="
log_message "test flash-2.13"
ptclProgSSBlev2
} $PASS
test flash-2.14.1 {Read SSB} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.14.1 ==========="
log_message "test flash-2.14.1"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test flash-2.14.2 {Read SSB} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.14.2 ==========="
log_message "test flash-2.14.2"
ptclReadSSB
set ssb [format %02X [expr 0X0F & 0X$::deviceArray(ssb)]]
} $expAnsw(readSSBlev2Test)
test flash-2.15 {Write AA at address 07FF} {
#dbgShowInfo "============ test flash-2.15 ==========="
log_message "test flash-2.15"
fillBuffer "0007FF" "0007FF" "AA"
cmdsDeviceProgram "0007FF" "0007FF"
set errCode
} {-12}
test flash-2.16 {Read at address 07FF} {
#dbgShowInfo "============ test flash-2.16 ==========="
log_message "test flash-2.16"
cmdsReadAddrRange "0007FF" "0007FF"
set errCode
} {-12}
test flash-2.17 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.17 ==========="
log_message "test flash-2.17"
ptclFullChipErase
} $PASS
test flash-2.18 {Write AA from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.18 ==========="
log_message "test flash-2.18"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.19.1 {Read from 0000 to [readBuffer maxAddr]} {! bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.19.1 ==========="
log_message "test flash-2.19.1"
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.19.2 {Read from 0000 to [readBuffer maxAddr] - 3} {bootloaderId_0001_Only} {
#dbgShowInfo "============ test flash-2.19.2 ==========="
log_message "test flash-2.19.2"
cmdsDeviceVerify 0 [expr 0X[readBuffer maxAddr] - 0X3]
} $PASS
test flash-2.20 {Erase Block 0} {
#dbgShowInfo "============ test flash-2.20 ==========="
log_message "test flash-2.20"
ptclEraseBlock0
} $PASS
test flash-2.21 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.21 ==========="
log_message "test flash-2.21"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {2000}
test flash-2.22 {Erase Block 1} {
#dbgShowInfo "============ test flash-2.22 ==========="
log_message "test flash-2.22"
ptclEraseBlock1
} $PASS
test flash-2.23 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23 ==========="
log_message "test flash-2.23"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {4000}
test flash-2.23.1 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23.1 ==========="
log_message "test flash-2.23.1"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.24 {Erase Block 2} {
#dbgShowInfo "============ test flash-2.24 ==========="
log_message "test flash-2.24"
ptclEraseBlock2
} $PASS
test flash-2.25 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.25 ==========="
log_message "test flash-2.25"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.26 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.26 ==========="
log_message "test flash-2.26"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {8000}
test flash-2.27 {Erase Block 3} {
#dbgShowInfo "============ test flash-2.27 ==========="
log_message "test flash-2.27"
ptclEraseBlock3
} $PASS
test flash-2.28 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.28 ==========="
log_message "test flash-2.28"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {C000}
test flash-2.29 {Erase Block 4} {
#dbgShowInfo "============ test flash-2.29 ==========="
log_message "test flash-2.29"
ptclEraseBlock4
} $PASS
test flash-2.30 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.30 ==========="
log_message "test flash-2.30"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.31 {Write 00 at address 0000} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.31 ==========="
log_message "test flash-2.31"
fillBuffer "000000" "000000" "00"
cmdsDeviceProgram "000000" "000000"
set status $DONTCARE
} $DONTCARE
test flash-2.32 {Read addresses 0000 to 0003} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.32 ==========="
log_message "test flash-2.32"
cmdsReadAddrRange "000000" "000003"
if { [checkBuffer "000000" "000000" "00"] } {
checkBuffer "000001" "000003" "FF"
} else {
set status 0
}
} $PASS
test flash-2.33 {Blank Check} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.33 ==========="
log_message "test flash-2.33"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {0000}
test flash-2.34 {Full Chip Erase} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.34 ==========="
log_message "test flash-2.34"
ptclFullChipErase
} $PASS
test flash-2.35 {Blank Check} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.35 ==========="
log_message "test flash-2.35"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.36 {Write 55 at address 07FFF} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.36 ==========="
log_message "test flash-2.36"
set ::deviceArray(bootloaderId) "0000"
fillBuffer [readBuffer maxAddr] [readBuffer maxAddr] "55"
cmdsDeviceProgram [readBuffer maxAddr] [readBuffer maxAddr]
set ::deviceArray(bootloaderId) "0002"
set status $DONTCARE
} $DONTCARE
test flash-2.37 {Read from 07FFD to 07FFF} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.37 ==========="
log_message "test flash-2.37"
cmdsReadAddrRange "007FFD" "007FFF"
if { [checkBuffer "007FFD" "007FFE" "FF"] } {
checkBuffer "007FFF" "007FFF" "55"
} else {
set X 0
}
} $PASS
test flash-2.38 {Blank Check} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.38 ==========="
log_message "test flash-2.38"
ptclBlankCheck "000000" [readBuffer maxAddr]
} [format %04X 0X[readBuffer maxAddr]]
test flash-2.39 {Write memory with wrong CRC} {bootloaderId_0002_Only} {
#dbgShowInfo "============ test flash-2.39 ==========="
log_message "test flash-2.39"
set ::deviceArray(bootloaderId) "0000"
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
set ::deviceArray(bootloaderId) "0002"
set status [readBootloaderCrcCheck]
} $FAIL
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg red]
#dbgShowInfo "***************** FUSE *******************"
test fuse-3.0 {Full Chip Erase} {
#dbgShowInfo "============ fuse-3.0 ==========="
log_message "fuse-3.0"
ptclFullChipErase
} $PASS
test fuse-3.1 {Write SSB = level 2} {
#dbgShowInfo "============ fuse-3.1 ==========="
log_message "fuse-3.1"
ptclProgSSBlev2
} $PASS
test fuse-3.2 {Read SSB} {
#dbgShowInfo "============ fuse-3.2 ==========="
log_message "fuse-3.2"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test fuse-3.3 {Read Hardware Byte} {
#dbgShowInfo "============ fuse-3.3 ==========="
log_message "fuse-3.3"
ptclReadHwByte
set errCode
} {-12}
test fuse-3.4 {Full Chip Erase} {
#dbgShowInfo "============ fuse-3.4 ==========="
log_message "fuse-3.4"
ptclFullChipErase
} $PASS
test fuse-3.5 {Read Hardware Byte} {
#dbgShowInfo "============ fuse-3.5 ==========="
log_message "fuse-3.5"
ptclReadHwByte
} $PASS
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg red]
#dbgShowInfo "********* SPECIFIC INFORMATIONS **********"
test specific-4.0 {Full Chip Erase} {
#dbgShowInfo "============ specific-4.0 ==========="
log_message "specific-4.0"
ptclFullChipErase
} $PASS
test specific-4.1 {Read Bootloader Version} {
#dbgShowInfo "============ specific-4.1 ==========="
log_message "specific-4.1"
ptclReadBootlVer
} $PASS
test specific-4.2 {Read Device Boot Id 1} {
#dbgShowInfo "============ specific-4.2 ==========="
log_message "specific-4.2"
ptclReadDevBootId1
} $PASS
test specific-4.3 {Read Device Boot Id 2} {
#dbgShowInfo "============ specific-4.3 ==========="
log_message "specific-4.3"
ptclReadDevBootId2
} $PASS
test specific-4.4 {Read Manufacturer Code} {
#dbgShowInfo "============ specific-4.4 ==========="
log_message "specific-4.4"
ptclReadManufId
} $PASS
test specific-4.5 {Read Device Id 1} {
#dbgShowInfo "============ specific-4.5 ==========="
log_message "specific-4.5"
ptclReadDeviceId1
} $PASS
test specific-4.6 {Read Device Id 2} {
#dbgShowInfo "============ specific-4.6 ==========="
log_message "specific-4.6"
ptclReadDeviceId2
} $PASS
test specific-4.7 {Read Device Id 3} {
#dbgShowInfo "============ specific-4.7 ==========="
log_message "specific-4.7"
ptclReadDeviceId3
} $PASS
test specific-4.8 {Write SSB = level 2} {
#dbgShowInfo "============ specific-4.8 ==========="
log_message "specific-4.8"
ptclProgSSBlev2
} $PASS
test specific-4.9 {Read SSB} {
#dbgShowInfo "============ specific-4.9 ==========="
log_message "specific-4.9"
ptclReadSSB
} $PASS
test specific-4.10 {Read Bootloader Version} {
#dbgShowInfo "============ specific-4.10 ==========="
log_message "specific-4.10"
ptclReadBootlVer
} $PASS
test specific-4.11 {Read Device Boot Id 1} {
#dbgShowInfo "============ specific-4.11 ==========="
log_message "specific-4.11"
ptclReadDevBootId1
} $PASS
test specific-4.12 {Read Device Boot Id 2} {
#dbgShowInfo "============ specific-4.12 ==========="
log_message "specific-4.12"
ptclReadDevBootId2
} $PASS
test specific-4.13 {Read Manufacturer Code} {
#dbgShowInfo "============ specific-4.13 ==========="
log_message "specific-4.13"
ptclReadManufId
} $PASS
test specific-4.14 {Read Device Id 1} {
#dbgShowInfo "============ specific-4.14 ==========="
log_message "specific-4.14"
ptclReadDeviceId1
} $PASS
test specific-4.15 {Read Device Id 2} {
#dbgShowInfo "============ specific-4.15 ==========="
log_message "specific-4.15"
ptclReadDeviceId2
} $PASS
test specific-4.16 {Read Device Id 3} {
#dbgShowInfo "============ specific-4.16 ==========="
log_message "specific-4.16"
ptclReadDeviceId3
} $PASS
test specific-4.17 {Full Chip Erase} {
#dbgShowInfo "============ specific-4.17 ==========="
log_message "specific-4.17"
ptclFullChipErase
} $PASS
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip5 configure -fg red]
#dbgShowInfo "**************** CHECKSUM *****************"
test checksum-5.0 {Full Chip Erase} {
#dbgShowInfo "============ test checksum-5.0 ==========="
log_message "test checksum-5.0"
ptclFullChipErase
} $PASS
test checksum-5.1 {Write Program Data} {
#dbgShowInfo "============ test checksum-5.1 ==========="
log_message "test checksum-5.1"
ptclSendFrame ":010000005500"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.2 {Erase Block 0} {
#dbgShowInfo "============ test checksum-5.2 ==========="
log_message "test checksum-5.2"
ptclSendFrame ":02000003010000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.3 {Erase Block 1} {
#dbgShowInfo "============ test checksum-5.3 ==========="
log_message "test checksum-5.3"
ptclSendFrame ":02000003012000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.4 {Erase Block 2} {
#dbgShowInfo "============ test checksum-5.4 ==========="
log_message "test checksum-5.4"
ptclSendFrame ":02000003014000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.5 {Erase Block 3} {
#dbgShowInfo "============ test checksum-5.5 ==========="
log_message "test checksum-5.5"
ptclSendFrame ":02000003018000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.6 {Erase Block 4} {
#dbgShowInfo "============ test checksum-5.6 ==========="
log_message "test checksum-5.6"
ptclSendFrame ":0200000301C000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.7 {Erase SBV and BSB} {
#dbgShowInfo "============ test checksum-5.7 ==========="
log_message "test checksum-5.7"
ptclSendFrame ":02000003040000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.8 {Program SSB level 1} {
#dbgShowInfo "============ test checksum-5.8 ==========="
log_message "test checksum-5.8"
ptclSendFrame ":02000003050000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.9 {Program SSB level 2} {
#dbgShowInfo "============ test checksum-5.9 ==========="
log_message "test checksum-5.9"
ptclSendFrame ":02000003050100"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.10 {Program BSB} {
#dbgShowInfo "============ test checksum-5.10 ==========="
log_message "test checksum-5.10"
ptclSendFrame ":0300000306005500"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.11 {Program SBV} {
#dbgShowInfo "============ test checksum-5.11 ==========="
log_message "test checksum-5.11"
ptclSendFrame ":0300000306005500"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.12 {Full Chip Erase} {
#dbgShowInfo "============ test checksum-5.12 ==========="
log_message "test checksum-5.12"
ptclSendFrame ":010000030700"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.13 {Program Osc Fuse} {
#dbgShowInfo "============ test checksum-5.13 ==========="
log_message "test checksum-5.13"
ptclSendFrame ":030000030A025500"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.14 {Program BLJB Fuse} {
#dbgShowInfo "============ test checksum-5.14 ==========="
log_message "test checksum-5.14"
ptclSendFrame ":030000030A045500"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.15 {Program X2 Fuse} {
#dbgShowInfo "============ test checksum-5.15 ==========="
log_message "test checksum-5.15"
ptclSendFrame ":030000030A085500"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.16 {Display Data} {
#dbgShowInfo "============ test checksum-5.16 ==========="
log_message "test checksum-5.16"
ptclSendFrame ":05000004000055550000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.17 {Blank Check} {
#dbgShowInfo "============ test checksum-5.17 ==========="
log_message "test checksum-5.17"
ptclSendFrame ":05000004000055550100"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.18 {Read Manuf Id} {
#dbgShowInfo "============ test checksum-5.18 ==========="
log_message "test checksum-5.18"
ptclSendFrame ":02000005000000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.19 {Read Device Id 1} {
#dbgShowInfo "============ test checksum-5.19 ==========="
log_message "test checksum-5.19"
ptclSendFrame ":02000005000100"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.20 {Read Device Id 2} {
#dbgShowInfo "============ test checksum-5.20 ==========="
log_message "test checksum-5.20"
ptclSendFrame ":02000005000200"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.21 {Read Device Id 3} {
#dbgShowInfo "============ test checksum-5.21 ==========="
log_message "test checksum-5.21"
ptclSendFrame ":02000005000300"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.22 {Read SSB} {
#dbgShowInfo "============ test checksum-5.22 ==========="
log_message "test checksum-5.22"
ptclSendFrame ":02000005070000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.23 {Read BSB} {
#dbgShowInfo "============ test checksum-5.23 ==========="
log_message "test checksum-5.23"
ptclSendFrame ":02000005070100"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.24 {Read SBV} {
#dbgShowInfo "============ test checksum-5.24 ==========="
log_message "test checksum-5.24"
ptclSendFrame ":02000005070200"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.25 {Read Hardware Byte} {
#dbgShowInfo "============ test checksum-5.25 ==========="
log_message "test checksum-5.25"
ptclSendFrame ":02000005070300"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.26 {Read Bootloader Version} {
#dbgShowInfo "============ test checksum-5.26 ==========="
log_message "test checksum-5.26"
ptclSendFrame ":02000005080000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.27 {Read SSB} {
#dbgShowInfo "============ test checksum-5.27 ==========="
log_message "test checksum-5.27"
ptclSendFrame ":020000050B0000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.28 {Read Device Boot Id 1} {
#dbgShowInfo "============ test checksum-5.28 ==========="
log_message "test checksum-5.28"
ptclSendFrame ":020000050E0000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.29 {Read Device Boot Id 2} {
#dbgShowInfo "============ test checksum-5.29 ==========="
log_message "test checksum-5.29"
ptclSendFrame ":020000050E0100"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.30 {Read Bootloader Version} {
#dbgShowInfo "============ test checksum-5.30 ==========="
log_message "test checksum-5.30"
ptclSendFrame ":020000050F0000"
ptclGetAck 2000
set errCode
} {-15}
test checksum-5.31 {Full Chip Erase} {
#dbgShowInfo "============ test checksum-5.31 ==========="
log_message "test checksum-5.31"
ptclFullChipErase
} $PASS
catch [.testSelectionDbox.f_skip.b_skip5 configure -fg black]
if {[string first "EEPROM" [namespace children ::]] != -1} then {
    cmdsImportCurrentMemoryNameSpace "EEPROM"
    catch [.testSelectionDbox.f_skip.b_skip6 configure -fg red]
    #dbgShowInfo "**************** EEPROM *****************"
    test eeprom-6.0 {Fill EEPROM with 0xFF} {
#dbgShowInfo "============ test eeprom-6.0 ==========="
log_message "test eeprom-6.0"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.1 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.1 ==========="
log_message "test eeprom-6.1"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "FF"
} $PASS
    test eeprom-6.2 {Fill EEPROM with 0x00} {
#dbgShowInfo "============ test eeprom-6.2 ==========="
log_message "test eeprom-6.2"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.3 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.3 ==========="
log_message "test eeprom-6.3"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "00"
} $PASS
    test eeprom-6.4 {Fill EEPROM with 0x55} {
#dbgShowInfo "============ test eeprom-6.4 ==========="
log_message "test eeprom-6.4"
fillBuffer "000000" [readBuffer maxAddr] "55"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.5 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.5 ==========="
log_message "test eeprom-6.5"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "55"
} $PASS
    test eeprom-6.6 {Fill EEPROM with 0xAA} {
#dbgShowInfo "============ test eeprom-6.6 ==========="
log_message "test eeprom-6.6"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.7 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.7 ==========="
log_message "test eeprom-6.7"
fillBuffer "000000" [readBuffer maxAddr] "55"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "AA"
} $PASS
    test eeprom-6.8 {Fill EEPROM with 0xFF} {
#dbgShowInfo "============ test eeprom-6.8 ==========="
log_message "test eeprom-6.8"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.9 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.9 ==========="
log_message "test eeprom-6.9"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "FF"
} $PASS
    catch [.testSelectionDbox.f_skip.b_skip6 configure -fg black]
    cmdsImportCurrentMemoryNameSpace "FLASH"
}
::tcltest::cleanupTests
log_message "Rs232std tests completed. Check the log file for errors."
cmdsRestoreSpecialBytes
set flipStates(mssgBox) 1
return
#dbgEndSrc [info script]
#dbgBeginSrc [info script]
global buffer protocol expAnsw testFlag canProtocol waitTime doTestArray flipStates hUSB_DFU bStatus
if {[lsearch [namespace children] ::tcltest] == -1} then {
    package require tcltest
    namespace import ::tcltest::*
}
set skipList {}
foreach test [array names doTestArray] {
    if {! $doTestArray($test)} then {
	append skipList " ${test}* "
    }
}
if {[info exists ::deviceArray(skipList)]} then {
    append skipList $::deviceArray(skipList)
}
set ::tcltest::skip $skipList
#dbgShowVar "skip = $::tcltest::skip"
set flipStates(mssgBox) 0
set ::tcltest::verbose "ps"
set PASS 1
set FAIL 0
cmdsReadSpecialBytes
debug_log "**********************************************"
debug_log "********** USB DFU Standard TESTS ************"
debug_log "**********************************************"
cmdsImportCurrentMemoryNameSpace [lindex $::deviceArray(memoryList) 0]
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg red]
debug_log "*************** XAF TESTS ****************"
test xaf-1.0 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.0 ==========="
log_message "test xaf-1.0 "
ptclFullChipErase
} $PASS
test xaf-1.1 {Write BSB = 0x55} {
#dbgShowInfo "============ test xaf-1.1 ==========="
log_message "test xaf-1.1 "
ptclWriteBSB "55"
} $PASS
test xaf-1.2 {Read BSB} {
#dbgShowInfo "============ test xaf-1.2 ==========="
log_message "test xaf-1.2 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.3 {Write SBV = 0x55} {
#dbgShowInfo "============ test xaf-1.3 ==========="
log_message "test xaf-1.3 "
ptclWriteSBV "55"
} $PASS
test xaf-1.4 {Read SBV} {
#dbgShowInfo "============ test xaf-1.4 ==========="
log_message "test xaf-1.4 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.5 {Write EB = 0x55} {
#dbgShowInfo "============ test xaf-1.5 ==========="
log_message "test xaf-1.5 "
ptclWriteEB "55"
} $PASS
test xaf-1.6 {Read EB} {
#dbgShowInfo "============ test xaf-1.6 ==========="
log_message "test xaf-1.6 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.6.1 {Write P1_CF = 0x55} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.6.1 ==========="
log_message "test xaf-1.6.1"
ptclWriteByte $protocol(writeP1) "55" 1
} $bStatus(OK)
test xaf-1.6.2 {Read P1_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.6.2 ==========="
log_message "test xaf-1.6.2"
ptclReadByte $protocol(readP1)
} {55}
test xaf-1.6.3 {Write P3_CF = 0x55} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.6.3 ==========="
log_message "test xaf-1.6.3"
ptclWriteByte $protocol(writeP3) "55" 1
} $bStatus(OK)
test xaf-1.6.4 {Read P3_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.6.4 ==========="
log_message "test xaf-1.6.4"
ptclReadByte $protocol(readP3)
} {55}
test xaf-1.6.5 {Write P4_CF = 0x55} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.6.5 ==========="
log_message "test xaf-1.6.5"
ptclWriteByte $protocol(writeP4) "55" 1
} $bStatus(OK)
test xaf-1.6.6 {Read P4_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.6.6 ==========="
log_message "test xaf-1.6.6"
ptclReadByte $protocol(readP4)
} {55}
test xaf-1.7 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.7 ==========="
log_message "test xaf-1.7 "
ptclProgSSBlev1
} $PASS
test xaf-1.8 {Read SSB} {
#dbgShowInfo "============ test xaf-1.8 ==========="
log_message "test xaf-1.8 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test xaf-1.9 {Write BSB = 0xAA} {
#dbgShowInfo "============ test xaf-1.9 ==========="
log_message "test xaf-1.9 "
ptclWriteBSB "AA"
} $FAIL
test xaf-1.10 {Read BSB} {
#dbgShowInfo "============ test xaf-1.10 ==========="
log_message "test xaf-1.10 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.11 {Write SBV = 0xAA} {
#dbgShowInfo "============ test xaf-1.11 ==========="
log_message "test xaf-1.11 "
ptclWriteSBV "AA"
} $FAIL
test xaf-1.12 {Read SBV} {
#dbgShowInfo "============ test xaf-1.12 ==========="
log_message "test xaf-1.12 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.13 {Write EB = 0xAA} {
#dbgShowInfo "============ test xaf-1.13 ==========="
log_message "test xaf-1.13 "
ptclWriteEB "AA"
} $FAIL
test xaf-1.14 {Read EB} {
#dbgShowInfo "============ test xaf-1.14 ==========="
log_message "test xaf-1.14 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.14.1 {Write P1_CF = 0xAA} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.14.1 ==========="
log_message "test xaf-1.14.1"
ptclWriteByte $protocol(writeP1) "AA" 1
} $bStatus(errWRITE)
test xaf-1.14.2 {Read P1_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.14.2 ==========="
log_message "test xaf-1.14.2"
ptclReadByte $protocol(readP1)
} {55}
test xaf-1.14.3 {Write P3_CF = 0xAA} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.14.3 ==========="
log_message "test xaf-1.14.3"
ptclWriteByte $protocol(writeP3) "AA" 1
} $bStatus(errWRITE)
test xaf-1.14.4 {Read P3_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.14.4 ==========="
log_message "test xaf-1.14.4"
ptclReadByte $protocol(readP3)
} {55}
test xaf-1.14.5 {Write P4_CF = 0xAA} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.14.5 ==========="
log_message "test xaf-1.14.5"
ptclWriteByte $protocol(writeP4) "AA" 1
} $bStatus(errWRITE)
test xaf-1.14.6 {Read P4_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.14.6 ==========="
log_message "test xaf-1.14.6"
ptclReadByte $protocol(readP4)
} {55}
test xaf-1.15 {Write SSB = level 2} {
#dbgShowInfo "============ test xaf-1.15 ==========="
log_message "test xaf-1.15 "
ptclProgSSBlev2
} $PASS
test xaf-1.16 {Read SSB} {
#dbgShowInfo "============ test xaf-1.16 ==========="
log_message "test xaf-1.16 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.17 {Write BSB = 0x00} {
#dbgShowInfo "============ test xaf-1.17 ==========="
log_message "test xaf-1.17 "
ptclWriteBSB "00"
} $FAIL
test xaf-1.18 {Read BSB} {
#dbgShowInfo "============ test xaf-1.18 ==========="
log_message "test xaf-1.18 "
ptclReadBSB
set ::deviceArray(bsb)
} {55}
test xaf-1.19 {Write SBV = 0x00} {
#dbgShowInfo "============ test xaf-1.19 ==========="
log_message "test xaf-1.19 "
ptclWriteSBV "00"
} $FAIL
test xaf-1.20 {Read SBV} {
#dbgShowInfo "============ test xaf-1.20 ==========="
log_message "test xaf-1.20 "
ptclReadSBV
set ::deviceArray(sbv)
} {55}
test xaf-1.21 {Write EB = 0x00} {
#dbgShowInfo "============ test xaf-1.21 ==========="
log_message "test xaf-1.21 "
ptclWriteEB "00"
} $FAIL
test xaf-1.22 {Read EB} {
#dbgShowInfo "============ test xaf-1.22 ==========="
log_message "test xaf-1.22 "
ptclReadEB
set ::deviceArray(eb)
} {55}
test xaf-1.22.1 {Write P1_CF = 0xAA} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.22.1 ==========="
log_message "test xaf-1.22.1"
ptclWriteByte $protocol(writeP1) "AA" 1
} $bStatus(errWRITE)
test xaf-1.22.2 {Read P1_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.22.2 ==========="
log_message "test xaf-1.22.2"
ptclReadByte $protocol(readP1)
} {55}
test xaf-1.22.3 {Write P3_CF = 0xAA} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.22.3 ==========="
log_message "test xaf-1.22.3"
ptclWriteByte $protocol(writeP3) "AA" 1
} $bStatus(errWRITE)
test xaf-1.22.4 {Read P3_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.22.4 ==========="
log_message "test xaf-1.22.4"
ptclReadByte $protocol(readP3)
} {55}
test xaf-1.22.5 {Write P4_CF = 0xAA} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.22.5 ==========="
log_message "test xaf-1.22.5"
ptclWriteByte $protocol(writeP4) "AA" 1
} $bStatus(errWRITE)
test xaf-1.22.6 {Read P4_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.22.6 ==========="
log_message "test xaf-1.22.6"
ptclReadByte $protocol(readP4)
} {55}
test xaf-1.23 {Write SSB = level 1} {
#dbgShowInfo "============ test xaf-1.23 ==========="
log_message "test xaf-1.23 "
ptclProgSSBlev1
} $FAIL
test xaf-1.24 {Read SSB} {
#dbgShowInfo "============ test xaf-1.24 ==========="
log_message "test xaf-1.24 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test xaf-1.25 {Full Chip Erase} {
#dbgShowInfo "============ test xaf-1.25 ==========="
log_message "test xaf-1.25 "
ptclFullChipErase
} $PASS
test xaf-1.26 {Read BSB} {
#dbgShowInfo "============ test xaf-1.26 ==========="
log_message "test xaf-1.26 "
ptclReadBSB
set ::deviceArray(bsb)
} {FF}
test xaf-1.27 {Read SBV} {
#dbgShowInfo "============ test xaf-1.27 ==========="
log_message "test xaf-1.27 "
ptclReadSBV
set ::deviceArray(sbv)
} {FF}
test xaf-1.28 {Read EB} {
#dbgShowInfo "============ test xaf-1.28 ==========="
log_message "test xaf-1.28 "
ptclReadEB
set ::deviceArray(eb)
} {FF}
test xaf-1.28.1 {Read P1_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.28.1 ==========="
log_message "test xaf-1.28.1"
ptclReadByte $protocol(readP1)
} {55}
test xaf-1.28.2 {Read P3_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.28.2 ==========="
log_message "test xaf-1.28.2"
ptclReadByte $protocol(readP3)
} {55}
test xaf-1.28.3 {Read P4_CF} {[string equal $::deviceArray(name) "AT89C5131"]} {
#dbgShowInfo "============ test xaf-1.28.3 ==========="
log_message "test xaf-1.28.3"
ptclReadByte $protocol(readP4)
} {55}
test xaf-1.29 {Read SSB} {
#dbgShowInfo "============ test xaf-1.29 ==========="
log_message "test xaf-1.29 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev0Test)
catch [.testSelectionDbox.f_skip.b_skip1 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg red]
debug_log "**************** FLASH *******************"
test flash-2.0 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.0 ==========="
log_message "test flash-2.0 "
ptclFullChipErase
} $PASS
test flash-2.1 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.1 ==========="
log_message "test flash-2.1 "
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.2 {Read from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.2 ==========="
log_message "test flash-2.2 "
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.3 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.3 ==========="
log_message "test flash-2.3 "
ptclFullChipErase
} $PASS
test flash-2.4 {Write AA at address 0X5555} {
#dbgShowInfo "============ test flash-2.4 ==========="
log_message "test flash-2.4 "
fillBuffer "005555" "005555" "AA"
cmdsDeviceProgram "005555" "005555"
} $PASS
test flash-2.5 {Read at address 0X5555} {
#dbgShowInfo "============ test flash-2.5 ==========="
log_message "test flash-2.5 "
cmdsReadAddrRange "005555" "005555"
checkBuffer "005555" "005555" "AA"
} $PASS
test flash-2.6 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.6 ==========="
log_message "test flash-2.6 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {5555}
test flash-2.7 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.7 ==========="
log_message "test flash-2.7 "
ptclFullChipErase
} $PASS
test flash-2.8 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.8 ==========="
log_message "test flash-2.8 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.9 {Write SSB = level 1} {
#dbgShowInfo "============ test flash-2.9 ==========="
log_message "test flash-2.9 "
ptclProgSSBlev1
} $PASS
test flash-2.10 {Read SSB} {
#dbgShowInfo "============ test flash-2.10 ==========="
log_message "test flash-2.10 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test flash-2.11 {Write AA at address 0X5555} {
#dbgShowInfo "============ test flash-2.11 ==========="
log_message "test flash-2.11 "
fillBuffer "005555" "005555" "AA"
cmdsDeviceProgram "005555" "005555"
} $FAIL
test flash-2.12 {Read at address 0X5555} {
#dbgShowInfo "============ test flash-2.12 ==========="
log_message "test flash-2.12 "
cmdsReadAddrRange "005555" "005555"
checkBuffer "005555" "005555" "FF"
} $PASS
test flash-2.13 {Write SSB = level 2} {
#dbgShowInfo "============ test flash-2.13 ==========="
log_message "test flash-2.13 "
ptclProgSSBlev2
} $PASS
test flash-2.14 {Read SSB} {
#dbgShowInfo "============ test flash-2.14 ==========="
log_message "test flash-2.14 "
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test flash-2.15 {Write AA at address 005555} {
#dbgShowInfo "============ test flash-2.15 ==========="
log_message "test flash-2.15 "
fillBuffer "005555" "005555" "AA"
cmdsDeviceProgram "005555" "005555"
} $FAIL
test flash-2.16 {Read at address 005555} {
#dbgShowInfo "============ test flash-2.16 ==========="
log_message "test flash-2.16 "
fillBuffer "005555" "005555" "FF"
cmdsReadAddrRange "005555" "005555"
checkBuffer "005555" "005555" "AA"
} {005555}
test flash-2.17 {Full Chip Erase} {
#dbgShowInfo "============ test flash-2.17 ==========="
log_message "test flash-2.17 "
ptclFullChipErase
} $PASS
test flash-2.18 {Write randomize data from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.18 ==========="
log_message "test flash-2.18 "
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test flash-2.19 {Read from 0000 to [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.19 ==========="
log_message "test flash-2.19 "
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test flash-2.20 {Erase Block 0} {
#dbgShowInfo "============ test flash-2.20 ==========="
log_message "test flash-2.20 "
ptclEraseBlock0
} $PASS
test flash-2.21 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.21 ==========="
log_message "test flash-2.21 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {2000}
test flash-2.22 {Erase Block 1} {
#dbgShowInfo "============ test flash-2.22 ==========="
log_message "test flash-2.22 "
ptclEraseBlock1
} $PASS
test flash-2.23 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23 ==========="
log_message "test flash-2.23 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {4000}
test flash-2.23.1 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.23.1 ==========="
log_message "test flash-2.23.1"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.24 {Erase Block 2} {
#dbgShowInfo "============ test flash-2.24 ==========="
log_message "test flash-2.24 "
ptclEraseBlock2
} $PASS
test flash-2.25 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.25 ==========="
log_message "test flash-2.25 "
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
test flash-2.26 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.26 ==========="
log_message "test flash-2.26"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {8000}
test flash-2.27 {Erase Block 3} {
#dbgShowInfo "============ test flash-2.27 ==========="
log_message "test flash-2.27"
ptclEraseBlock3
} $PASS
test flash-2.28 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.28 ==========="
log_message "test flash-2.28"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {C000}
test flash-2.29 {Erase Block 4} {
#dbgShowInfo "============ test flash-2.29 ==========="
log_message "test flash-2.29"
ptclEraseBlock4
} $PASS
test flash-2.30 {Blank Check between 0000 and [readBuffer maxAddr]} {
#dbgShowInfo "============ test flash-2.30 ==========="
log_message "test flash-2.30"
ptclBlankCheck "000000" [readBuffer maxAddr]
} {-1}
catch [.testSelectionDbox.f_skip.b_skip2 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg red]
#dbgShowInfo  "***************** FUSE TESTS *******************"
test fuse-3.0 {Full Chip Erase} {
#dbgShowInfo "============ test fuse-3.0 ==========="
log_message "test fuse-3.0"
ptclFullChipErase
} $PASS
test fuse-3.1 {Write HSB = 0xFF} {
#dbgShowInfo "============ test fuse-3.1 ==========="
log_message "test fuse-3.1"
ptclWriteHwByte "FF"
} $PASS
test fuse-3.2 {Read HSB} {
#dbgShowInfo "============ test fuse-3.2 ==========="
log_message "test fuse-3.2"
ptclReadHwByte
set ::deviceArray(hsb)
} {FF}
test fuse-3.3 {Write HSB = 0x0F} {
#dbgShowInfo "============ test fuse-3.3 ==========="
log_message "test fuse-3.3"
ptclWriteHwByte "0F"
} $PASS
test fuse-3.4 {Read HSB} {
#dbgShowInfo "============ test fuse-3.4 ==========="
log_message "test fuse-3.4"
ptclReadHwByte
set ::deviceArray(hsb)
} {0F}
test fuse-3.5 {Write SSB = level 1} {
#dbgShowInfo "============ test fuse-3.5 ==========="
log_message "test fuse-3.5"
ptclProgSSBlev1
} $PASS
test fuse-3.6 {Read SSB} {
#dbgShowInfo "============ test fuse-3.6 ==========="
log_message "test fuse-3.6"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev1Test)
test fuse-3.7 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.7 ==========="
log_message "test fuse-3.7"
ptclWriteHwByte "5F"
} $FAIL
test fuse-3.8 {Read HSB} {
#dbgShowInfo "============ test fuse-3.8 ==========="
log_message "test fuse-3.8"
ptclReadHwByte
set ::deviceArray(hsb)
} {0F}
test fuse-3.9 {Write SSB = level 2} {
#dbgShowInfo "============ test fuse-3.9 ==========="
log_message "test fuse-3.9"
ptclProgSSBlev2
} $PASS
test fuse-3.10 {Read SSB} {
#dbgShowInfo "============ test fuse-3.10 ==========="
log_message "test fuse-3.10"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test fuse-3.11 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.11 ==========="
log_message "test fuse-3.11"
ptclWriteHwByte "5F"
} $FAIL
test fuse-3.12 {Read HSB} {
#dbgShowInfo "============ test fuse-3.12 ==========="
log_message "test fuse-3.12"
ptclReadHwByte
} $PASS
test fuse-3.13 {Full Chip Erase} {
#dbgShowInfo "============ test fuse-3.13 ==========="
log_message "test fuse-3.13"
ptclFullChipErase
} $PASS
test fuse-3.14 {Read HSB} {
#dbgShowInfo "============ test fuse-3.14 ==========="
log_message "test fuse-3.14"
ptclReadHwByte
set ::deviceArray(hsb)
} {0F}
test fuse-3.15 {Write HSB = 0x5F} {
#dbgShowInfo "============ test fuse-3.15 ==========="
log_message "test fuse-3.15"
ptclWriteHwByte "5F"
} $PASS
test fuse-3.16 {Read HSB} {
#dbgShowInfo "============ test fuse-3.16 ==========="
log_message "test fuse-3.16"
ptclReadHwByte
set ::deviceArray(hsb)
} {5F}
catch [.testSelectionDbox.f_skip.b_skip3 configure -fg black]
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg red]
debug_log "********* SPECIFIC INFORMATIONS **********"
test specific-4.0 {Full Chip Erase} {
#dbgShowInfo "============ test Specific-4.0 ==========="
log_message "test Specific-4.0"
ptclFullChipErase
} $PASS
test specific-4.1 {Read Bootloader Version} {
#dbgShowInfo "============ test Specific-4.1 ==========="
log_message "test Specific-4.1"
ptclReadBootlVer
} $PASS
test specific-4.2 {Read Device Boot Id 1} {
#dbgShowInfo "============ test Specific-4.2 ==========="
log_message "test Specific-4.2"
ptclReadDevBootId1
} $PASS
test specific-4.3 {Read Device Boot Id 2} {
#dbgShowInfo "============ test Specific-4.3 ==========="
log_message "test Specific-4.3"
ptclReadDevBootId2
} $PASS
test specific-4.4 {Read Manuf Id} {
#dbgShowInfo "============ test Specific-4.4 ==========="
log_message "test Specific-4.4"
ptclReadManufId
} $PASS
test specific-4.5 {Read Device Id 1} {
#dbgShowInfo "============ test Specific-4.5 ==========="
log_message "test Specific-4.5"
ptclReadDeviceId1
} $PASS
test specific-4.6 {Read Device Id 2} {
#dbgShowInfo "============ test Specific-4.6 ==========="
log_message "test Specific-4.6"
ptclReadDeviceId2
} $PASS
test specific-4.7 {Read Device Id 3} {
#dbgShowInfo "============ test Specific-4.7 ==========="
log_message "test Specific-4.7"
ptclReadDeviceId3
} $PASS
test specific-4.8 {Write SSB = level 2} {
#dbgShowInfo "============ test Specific-4.8 ==========="
log_message "test Specific-4.8"
ptclProgSSBlev2
} $PASS
test specific-4.9 {Read SSB} {
#dbgShowInfo "============ test Specific-4.9 ==========="
log_message "test Specific-4.9"
ptclReadSSB
set ::deviceArray(ssb)
} $expAnsw(readSSBlev2Test)
test specific-4.10 {Read Bootloader Version} {
#dbgShowInfo "============ test Specific-4.10 ==========="
log_message "test Specific-4.10"
ptclReadBootlVer
} $PASS
test specific-4.11 {Read Device Boot Id 1} {
#dbgShowInfo "============ test Specific-4.11 ==========="
log_message "test Specific-4.11"
ptclReadDevBootId1
} $PASS
test specific-4.12 {Read Device Boot Id 2} {
#dbgShowInfo "============ test Specific-4.12 ==========="
log_message "test Specific-4.12"
ptclReadDevBootId2
} $PASS
test specific-4.13 {Read Manuf Id} {
#dbgShowInfo "============ test Specific-4.13 ==========="
log_message "test Specific-4.13"
ptclReadManufId
} $PASS
test specific-4.14 {Read Device Id 1} {
#dbgShowInfo "============ test Specific-4.14 ==========="
log_message "test Specific-4.14"
ptclReadDeviceId1
} $PASS
test specific-4.15 {Read Device Id 2} {
#dbgShowInfo "============ test Specific-4.15 ==========="
log_message "test Specific-4.15"
ptclReadDeviceId2
} $PASS
test specific-4.16 {Read Device Id 3} {
#dbgShowInfo "============ test Specific-4.16 ==========="
log_message "test Specific-4.16"
ptclReadDeviceId3
} $PASS
test specific-4.17 {Full Chip Erase} {
#dbgShowInfo "============ test Specific-4.17 ==========="
log_message "test Specific-4.17"
ptclFullChipErase
} $PASS
test specific-5.0 {Full Chip Erase} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.0 ==========="
log_message "test Specific-5.0"
set flipStates(bufferInInitialState) 0
ptclFullChipErase
} $PASS
test specific-5.1 {Blank Check} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.1 ==========="
log_message "test Specific-5.1"
ptclBlankCheck "000000" [readBuffer maxAddr]
} -1
test specific-5.2 {Read Device Boot ID 1} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.2 ==========="
log_message "test Specific-5.2"
ptclReadDevBootId1
} $PASS
test specific-5.3 {Read Device Boot ID 2} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.3 ==========="
log_message "test Specific-5.3"
ptclReadDevBootId2
} $PASS
test specific-5.4 {Read Bootloader Version} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.4 ==========="
log_message "test Specific-5.4"
ptclReadBootlVer
} $PASS
test specific-5.5 {Write the whole CRAM} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.5 ==========="
log_message "test Specific-5.5"
randomizeBuffer
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
test specific-5.6 {Verify CRAM} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.6 ==========="
log_message "test Specific-5.6"
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
test specific-5.7 {Full Chip Erase} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.7 ==========="
log_message "test Specific-5.7"
ptclFullChipErase
} $PASS
test specific-5.8 {Blank Check} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.8 ==========="
log_message "test Specific-5.8"
ptclBlankCheck "000000" [readBuffer maxAddr]
} -1
test specific-5.9 {Write the CRAM partially} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.9 ==========="
log_message "test Specific-5.9"
resetBuffer
set flipStates(bufferInInitialState) 0
fillBuffer "000085" "00016D" "55"
cmdsDeviceProgram "000085" "00016D"
} $PASS
test specific-5.10 {Verify CRAM} {[string equal $::deviceArray(name) "AT8XC5122"]} {
#dbgShowInfo "============ test Specific-5.10 ==========="
log_message "test Specific-5.10"
cmdsDeviceVerify 0 [readBuffer maxAddr]
} $PASS
set ::tcltest::testConstraints(constraint) [expr [string equal $::deviceArray(name) "AT8XC5122"] || [string equal $::deviceArray(name) "AT89C5131"]]
test specific-5.11 {Full Chip Erase} {constraint} {
#dbgShowInfo "============ test Specific-5.11 ==========="
log_message "test Specific-5.11"
ptclFullChipErase
} $PASS
test specific-5.12 {Start Application step 1} {constraint} {
#dbgShowInfo "============ test Specific-5.12 ==========="
log_message "test Specific-5.12"
set index 0
foreach data $::deviceArray(startAppliTest) {
writeBuffer [format %06X $index] $data
incr index
}
set maxAddr [format %06X $index]
cmdsDeviceProgram "000000" $maxAddr
} $PASS
test specific-5.13 {Start Application step 2} {constraint} {
#dbgShowInfo "============ test Specific-5.13 ==========="
log_message "test Specific-5.13"
ptclStartAppli 0
} $PASS
test specific-5.14 {Start Application step 3} {constraint} {
#dbgShowInfo "============ test Specific-5.14 ==========="
log_message "test Specific-5.14"
after 4000
update
set hUSB_DFU [USB_DFU_LocateAndOpenDevice $::deviceArray(usb_dfu_default_product_id)]
if { ($hUSB_DFU != -1) && ($hUSB_DFU != -2) } {
set status $PASS
} else {
set status $FAIL
}
} $PASS
test specific-5.15 {Start Application step 4} {constraint} {
#dbgShowInfo "============ test Specific-5.15 ==========="
log_message "test Specific-5.15"
cmdsDeviceVerify 0 [readBuffer maxAddr]
set buffer(verifyFail)
} $::deviceArray(startAppliFailAddr)
test specific-5.16 {Full Chip Erase} {constraint} {
#dbgShowInfo "============ test Specific-5.16 ==========="
log_message "test Specific-5.16"
ptclFullChipErase
} $PASS
catch [.testSelectionDbox.f_skip.b_skip4 configure -fg black]
if {[string first "EEPROM" [namespace children ::]] != -1} then {
    cmdsImportCurrentMemoryNameSpace "EEPROM"
    catch [.testSelectionDbox.f_skip.b_skip6 configure -fg red]
    #dbgShowInfo "**************** EEPROM *****************"
    test eeprom-6.0 {Fill EEPROM with 0xFF} {
#dbgShowInfo "============ test eeprom-6.0 ==========="
log_message "test eeprom-6.0"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.1 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.1 ==========="
log_message "test eeprom-6.1"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "FF"
} $PASS
    test eeprom-6.2 {Fill EEPROM with 0x00} {
#dbgShowInfo "============ test eeprom-6.2 ==========="
log_message "test eeprom-6.2"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.3 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.3 ==========="
log_message "test eeprom-6.3"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "00"
} $PASS
    test eeprom-6.4 {Fill EEPROM with 0x55} {
#dbgShowInfo "============ test eeprom-6.4 ==========="
log_message "test eeprom-6.4"
fillBuffer "000000" [readBuffer maxAddr] "55"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.5 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.5 ==========="
log_message "test eeprom-6.5"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "55"
} $PASS
    test eeprom-6.6 {Fill EEPROM with 0xAA} {
#dbgShowInfo "============ test eeprom-6.6 ==========="
log_message "test eeprom-6.6"
fillBuffer "000000" [readBuffer maxAddr] "AA"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.7 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.7 ==========="
log_message "test eeprom-6.7"
fillBuffer "000000" [readBuffer maxAddr] "55"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "AA"
} $PASS
    test eeprom-6.8 {Fill EEPROM with 0xFF} {
#dbgShowInfo "============ test eeprom-6.8 ==========="
log_message "test eeprom-6.8"
fillBuffer "000000" [readBuffer maxAddr] "FF"
cmdsDeviceProgram "000000" [readBuffer maxAddr]
} $PASS
    test eeprom-6.9 {Verify the whole EEPROM} {
#dbgShowInfo "============ test eeprom-6.9 ==========="
log_message "test eeprom-6.9"
fillBuffer "000000" [readBuffer maxAddr] "00"
cmdsReadAddrRange "000000" [readBuffer maxAddr]
checkBuffer "000000" [readBuffer maxAddr] "FF"
} $PASS
    catch [.testSelectionDbox.f_skip.b_skip6 configure -fg black]
    cmdsImportCurrentMemoryNameSpace "FLASH"
}
::tcltest::cleanupTests
log_message "USB tests completed. Check the log file for errors."
cmdsRestoreSpecialBytes
set flipStates(mssgBox) 1
return
#dbgEndSrc [info script]           proc createMainToolBar {} {
global projDir
image create photo tool_device -file $projDir/images/selectdevice.gif
image create photo tool_connect -file $projDir/images/connect.gif
image create photo tool_help -file $projDir/images/help.gif
image create photo tool_erase -file $projDir/images/erase.gif
image create photo tool_loadhex -file $projDir/images/loadhex.gif
image create photo tool_savehex -file $projDir/images/savehex.gif
image create photo tool_blankcheck -file $projDir/images/blkcheck.gif
image create photo tool_program -file $projDir/images/program.gif
image create photo tool_read -file $projDir/images/deviceread.gif
image create photo tool_verify -file $projDir/images/verify.gif
image create photo tool_bufferedit -file $projDir/images/bufferedit.gif
frame .main.toolbar
set B .main.toolbar.device
button $B -image tool_device -width 50 -state normal -command {cbDboxWakeUp .deviceSelectDbox}
setBalloon $B "Select device"
set B .main.toolbar.connect
button $B -image tool_connect -width 50 -state disabled -command {popupCommMenu}
setBalloon $B "Set communication"
set B .main.toolbar.erase
button $B -image tool_erase -width 50 -state disabled -command {cbDboxWakeUp .deviceErase}
setBalloon $B "Erase device"
set B .main.toolbar.blankcheck
button $B -image tool_blankcheck -width 50 -state disabled -command {cbDboxWakeUp .blankCheckDBox}
setBalloon $B "Blank check device"
set B .main.toolbar.program
button $B -image tool_program -width 50 -state disabled -command {cmdsDeviceProgram}
setBalloon $B "Program device"
set B .main.toolbar.verify
button $B -image tool_verify -width 50 -state disabled -command {cmdsDeviceVerify}
setBalloon $B "Verify device"
set B .main.toolbar.read
button $B -image tool_read -width 50 -state disabled -command {cbDboxWakeUp .deviceReadDBox}
setBalloon $B "Read device"
set B .main.toolbar.bufferedit
button $B -image tool_bufferedit -width 50 -state disabled -command {cbDboxWakeUp .bufferEditWindow}
setBalloon $B "Edit buffer"
set B .main.toolbar.loadhex
button $B -image tool_loadhex -width 50 -state disabled -command {cbParseHexFile}
setBalloon $B "Load HEX file"
set B .main.toolbar.savehex
button $B -image tool_savehex -width 50 -state disabled -command {cbWriteHexFile}
setBalloon $B "Save HEX file"
set B .main.toolbar.help
button $B -image tool_help -width 50 -state normal -command {htmlView "Help" ./doc/flip_um.htm}
setBalloon $B "Help"
frame .main.toolbar.f_separator1 -width 20
frame .main.toolbar.f_separator2 -width 20
frame .main.toolbar.f_separator3 -width 20
pack configure .main.toolbar.device .main.toolbar.connect .main.toolbar.f_separator1 .main.toolbar.erase .main.toolbar.blankcheck .main.toolbar.program .main.toolbar.verify .main.toolbar.read .main.toolbar.f_separator2 .main.toolbar.bufferedit .main.toolbar.loadhex .main.toolbar.savehex .main.toolbar.f_separator3 .main.toolbar.help -side left -anchor w
}
proc createBufferToolBar {w} {
    global projDir
    image create photo tool_loadhex -file $projDir/images/loadhex.gif
    image create photo tool_savehex -file $projDir/images/savehex.gif
    image create photo tool_fill -file $projDir/images/fill.gif
    image create photo tool_goto -file $projDir/images/goto.gif
    image create photo tool_modify -file $projDir/images/modify.gif
    image create photo tool_reset -file $projDir/images/reset.gif
    image create photo tool_search -file $projDir/images/search.gif
    image create photo tool_program -file $projDir/images/program.gif
    image create photo tool_read -file $projDir/images/deviceread.gif
    image create photo tool_verify -file $projDir/images/verify.gif
    image create photo tool_help -file $projDir/images/help.gif
    frame $w.toolbar
    set B $w.toolbar.loadhex
    button $B -image tool_loadhex -width 40 -state normal -command {cbParseHexFile}
    setBalloon $B "Load HEX file"
    set B $w.toolbar.savehex
    button $B -image tool_savehex -width 40 -state normal -command {cbWriteHexFile}
    setBalloon $B "Save HEX file"
    set B $w.toolbar.fill
    button $B -image tool_fill -width 40 -state normal -command {set eValue .bufferFillDBox.f_addresses.f_value.e_value
	$eValue icursor end
	focus $eValue
	cbDboxWakeUp .bufferFillDBox}
    setBalloon $B "Fill buffer"
    set B $w.toolbar.goto
    button $B -image tool_goto -width 40 -state normal -command {set eData .bufferGotoDbox.f_address.e_address
	focus $eData
	cbDboxWakeUp .bufferGotoDbox}
    setBalloon $B "Buffer goto"
    set B $w.toolbar.modify
    button $B -image tool_modify -width 40 -state normal -command {set eData .bufferModifyDbox.f_addressData.e_data
	$eData icursor end
	focus $eData
	cbDboxWakeUp .bufferModifyDbox}
    setBalloon $B "Modify buffer"
    set B $w.toolbar.reset
    button $B -image tool_reset -width 40 -state normal -command {resetBuffer}
    setBalloon $B "Reset buffer"
    set B $w.toolbar.search
    button $B -image tool_search -width 40 -state normal -command {cbDboxWakeUp .bufferSearchDbox}
    setBalloon $B "Search buffer"
    set B $w.toolbar.read
    button $B -image tool_read -width 40 -state disabled -command {cbDboxWakeUp .deviceReadDBox}
    setBalloon $B "Read device"
    set B $w.toolbar.program
    button $B -image tool_program -width 40 -state disabled -command {cmdsDeviceProgram}
    setBalloon $B "Program device"
    set B $w.toolbar.verify
    button $B -image tool_verify -width 40 -state disabled -command {cmdsDeviceVerify}
    setBalloon $B "Verify device"
    set B $w.toolbar.help
    button $B -image tool_help -width 40 -state normal -command {htmlView "Help" ./doc/flip_um.htm}
    setBalloon $B "Help"
    frame $w.toolbar.f_separator1 -width 20
    frame $w.toolbar.f_separator2 -width 20
    frame $w.toolbar.f_separator3 -width 20
    pack $w.toolbar.loadhex $w.toolbar.savehex $w.toolbar.f_separator1 $w.toolbar.fill $w.toolbar.goto $w.toolbar.modify $w.toolbar.reset $w.toolbar.search $w.toolbar.f_separator2 $w.toolbar.program $w.toolbar.verify $w.toolbar.read $w.toolbar.f_separator3 $w.toolbar.help -side left -anchor w
}
proc updateGUI {event} {
    switch $event {
    onDeviceSelection {
	    onDeviceSelectionGUI
	}
    onAnyCommunicationOn {
	    onAnyCommunicationGUI normal
	}
    onAnyCommunicationOff {
	    onAnyCommunicationGUI disabled
	}
    onRs232CommunicationOn {
	    onRs232CommunicationGUI normal
	}
    onRs232CommunicationOff {
	    onRs232CommunicationGUI disabled
	}
    onUsbCommunicationOn {
	    onUsbCommunicationGUI normal
	}
    onUsbCommunicationOff {
	    onUsbCommunicationGUI disabled
	}
    onConfigFileLoaded {
	    onConfigFileLoadedGUI
	}
    onTestDebugChanged {
	    onTestDebugChangedGUI
	}
    onAddrProgRangeChange {
	    onAddrProgRangeChangeGUI
	}
    onBlankCheckOptionsChange {
	    onBlankCheckOptionsChangeGUI
	}
    onBufferSizeTypeChange {
	    onBufferSizeTypeChangeGUI
	}
    onInitialBufferContentsChange {
	    onInitialBufferContentsChangeGUI
	}
    onCanCommStatusModified {
	    onCanCommStatusModifiedGUI
	}
    onCanNodeSelectionOpened {
	    onCanNodeSelectionGUI open
	}
    onCanNodeSelectionClosed {
	    onCanNodeSelectionGUI closed
	}
    onSecurityLevelChange {
	    onSecurityLevelChangeGUI
	}
    onHsbModified {
	    onHsbModifiedGUI
	}
    onProtocolTestSelection {
	    onProtocolTestSelectionGUI
	}
    onRunOperations {
	    onRunOperationsGUI
	}
    onRunOperationsCompleted {
	    onRunOperationsCompletedGUI
	}
    onCANDongleSelection {
	    onCANDongleSelectionGUI
	}
    onDeviceActionStart {
	    onDeviceActionGUI disabled
	}
    onDeviceActionStop {
	    onDeviceActionGUI normal
	}
    default {
	    #dbgShowInfo "Invalid updateGUI argument" 
	}
    }
    update idletasks
    return
}
proc onUsbCommunicationGUI {state} {
    #dbgBeginProc [info level [info level]]
    global flipStates port baud projDir flipFont protcl bootloaderVerDependent
    if {$state == "normal"} then {
	set flipStates(usbComm) "on"
	catch [.f_status.l_comm configure -relief sunken -anchor w -borderwidth 1 -background grey -foreground black -text "USB" -font $flipFont]
	catch [.usbCommDbox.f_buttons.b_open configure -state disabled]
	catch [.usbCommDbox.f_buttons.b_close configure -state normal]
	set ::deviceArray(currentMemory) [lindex $::deviceArray(memoryList) 0]
	cmdsImportCurrentMemoryNameSpace $::deviceArray(currentMemory)
	if {$bootloaderVerDependent(startAppli)} then {
	    catch [.main.f_device.f_startApp.b_start configure -state normal -bg red -fg yellow]
	    catch [.main.f_device.f_buttons.b_exec configure -state normal -bg red -fg yellow]
	    catch [.main.f_device.f_startApp.b_reset configure -state normal]
	}
	if {$bootloaderVerDependent(eeprom)} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
		catch [.main.f_buffer.b_memSelect configure -state normal -text [lindex $::deviceArray(memoryButtonList) 0] -bg [lindex $::deviceArray(memoryColor) 0] -fg black]
	    }
	}
	updateGuiParameters
    } else {
	set flipStates(usbComm) "off"
	catch [.f_status.l_comm configure -relief sunken -anchor w -borderwidth 1 -background grey -foreground black -text "Comm. OFF" -font $flipFont]
	catch [.usbCommDbox.f_buttons.b_open configure -state normal]
	catch [.usbCommDbox.f_buttons.b_close configure -state disabled]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onDeviceActionGUI {state} {
    if {$state == "normal"} then {
	catch [.main.f_device.f_buttons.b_exec configure -state $state -bg red -fg yellow]
    } else {
	catch [.main.f_device.f_buttons.b_exec configure -state $state -bg grey]
    }
    set f .deviceReadDBox.f_buttons
    if {[winfo exists $f]} then {
	catch [$f.b_read configure -state $state]
	catch [$f.b_reset configure -state $state]
    }
    set f .main.f_flow.f_buttons
    if {[winfo exists $f]} then {
	catch [$f.b_run configure -state $state]
	catch [$f.b_clear configure -state $state]
    }
    set f .main.f_device.f_buttons
    if {[winfo exists $f]} then {
	catch [$f.b_update configure -state $state]
	catch [$f.b_write configure -state $state]
    }
    set f .deviceErase.f_buttons
    if {[winfo exists $f]} then {
	catch [$f.b_erase configure -state $state]
    }
    set f .blankCheckDBox.f_buttons
    if {[winfo exists $f]} then {
	catch [$f.b_check configure -state $state]
	catch [$f.b_reset configure -state $state]
    }
    return
}
proc onCANDongleSelectionGUI {} {
    global canProtocol canPort
    if {($canProtocol(hardware) == "SYSTEC") ||($canProtocol(hardware) == "ATMEL_USB")} then {
	set canPort "USB"
	catch [.canSetup.f_main.f_1.f_3.l_port configure -state normal]
	catch [.canSetup.f_main.f_1.f_3.portSelect configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.l_slot configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s1 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.l_channel configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c1 configure -state disabled]
    } elseif {$canProtocol(hardware) == "CANAC2"} {
	catch [.canSetup.f_main.f_20.f_21.l_slot configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s1 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.l_channel configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c1 configure -state disabled]
	catch [.canSetup.f_main.f_1.f_3.l_port configure -state disabled]
	catch [.canSetup.f_main.f_1.f_3.portSelect configure -state disabled]
    } elseif {$canProtocol(hardware) == "CANCARDX"} {
	catch [.canSetup.f_main.f_20.f_21.l_slot configure -state normal]
	catch [.canSetup.f_main.f_20.f_21.b_s0 configure -state normal]
	catch [.canSetup.f_main.f_20.f_21.b_s1 configure -state normal]
	catch [.canSetup.f_main.f_20.f_22.l_channel configure -state normal]
	catch [.canSetup.f_main.f_20.f_22.b_c0 configure -state normal]
	catch [.canSetup.f_main.f_20.f_22.b_c1 configure -state normal]
	catch [.canSetup.f_main.f_1.f_3.l_port configure -state disabled]
	catch [.canSetup.f_main.f_1.f_3.portSelect configure -state disabled]
    } elseif {$canProtocol(hardware) == "CANPARI"} {
	catch [.canSetup.f_main.f_20.f_21.l_slot configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s1 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.l_channel configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c1 configure -state disabled]
	catch [.canSetup.f_main.f_1.f_3.l_port configure -state normal]
	catch [.canSetup.f_main.f_1.f_3.portSelect configure -state normal]
    } else {
	set canPort "LPT1"
	catch [.canSetup.f_main.f_20.f_21.l_slot configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_21.b_s1 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.l_channel configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c0 configure -state disabled]
	catch [.canSetup.f_main.f_20.f_22.b_c1 configure -state disabled]
	catch [.canSetup.f_main.f_1.f_3.l_port configure -state normal]
	catch [.canSetup.f_main.f_1.f_3.portSelect configure -state normal]
    }
    return
}
proc onRunOperationsGUI {} {
    #dbgBeginProc [info level [info level]]
    global color
    cmdsClearOperations 1
    focus .
    set ff .main.f_flow
    set bRun $ff.f_buttons.b_run
    set bClear $ff.f_buttons.b_clear
    set bErase $ff.f_operations.b_erase
    set bBlankCheck $ff.f_operations.b_blankCheck
    set bProgram $ff.f_operations.b_program
    set bVerify $ff.f_operations.b_verify
    set bSpecialBytes $ff.f_operations.b_specialBytes
    set fd .main.f_device
    if {[winfo exists $fd.f_fuses.b_osc]} then {
	set bOsc $fd.f_fuses.b_osc
    }
    if {[winfo exists $fd.f_fuses.b_bljb]} then {
	set bBLJB $fd.f_fuses.b_bljb
    }
    if {[winfo exists $fd.f_fuses.b_x2]} then {
	set bX2 $fd.f_fuses.b_x2
    }
    set eSBV $fd.f_bsb_sbv.f_sbv.e_sbv
    set eBSB $fd.f_bsb_sbv.f_bsb.e_bsb
    if {[winfo exists $fd.f_bsb_sbv.f_bsb.e_eb]} then {
	set eEB $fd.f_bsb_sbv.f_bsb.e_eb
    }
    foreach i {0 1 2} {
	set wdgt $fd.f_ssb.f_level$i.b_level$i
	if {[winfo exists $wdgt]} then {
	    set bLev$i $wdgt
	}
    }
    foreach i {0 1 2} {
	set wdgt $fd.f_ssb.f_level.b_level$i
	if {[winfo exists $wdgt]} then {
	    set bLev$i $wdgt
	}
    }
    set bRead $fd.f_buttons.b_update
    set bWrite $fd.f_buttons.b_write
    set mFile .menubar.file
    set mBuffer .menubar.buffer
    set mDevice .menubar.device
    set mSettings .menubar.settings
    set mHelp .menubar.help
    set buttons_List [list $bRun $bClear $bRead $bWrite]
    if {[info exists bLev0]} then {
	lappend buttons_List $bLev0
    }
    if {[info exists bLev1]} then {
	lappend buttons_List $bLev1
    }
    if {[info exists bLev2]} then {
	lappend buttons_List $bLev2
    }
    if {[info exists bOsc]} then {
	lappend buttons_List $bOsc
    }
    if {[info exists bBLJB]} then {
	lappend buttons_List $bBLJB
    }
    if {[info exists bX2]} then {
	lappend buttons_List $bX2
    }
    if {[info exists bEraseSBV]} then {
	lappend buttons_List $bEraseSBV
    }
    set checkbuttons_List [list $bErase $bBlankCheck $bProgram $bVerify $bSpecialBytes]
    if {[info exists eSBV]} then {
	lappend entries_List $eSBV
    }
    if {[info exists eBSB]} then {
	lappend entries_List $eBSB
    }
    if {[info exists eEB]} then {
	lappend entries_List $eEB
    }
    set menus_List [list $mFile $mBuffer $mDevice $mSettings $mHelp]
    foreach b $buttons_List {
	catch {$b configure -state disabled}
    }
    foreach e $entries_List {
	if {[winfo exists $e]} then {
	    catch {$e configure -takefocus 0 -state disabled}
	}
    }
    foreach m $menus_List {
	for {set i 0} {$i <= [$m index last]} {incr i} {
	    catch {$m entryconfigure $i -state disabled}
	}
    }
    update
    #update checkbuttons color before Run operations
    writeBuffer flowProgramColor $color(systemWindow)
    writeBuffer flowEraseColor $color(systemWindow)
    writeBuffer flowBlankCheckColor $color(systemWindow)
    writeBuffer flowProgramColor $color(systemWindow)
    writeBuffer flowVerifyColor $color(systemWindow)
    writeBuffer flowSpecialBytesColor $color(systemWindow)
    #dbgEndProc [info level [info level]]
    return
}
proc onRunOperationsCompletedGUI {} {
    #dbgBeginProc [info level [info level]]
    global saveArray gui bootloaderVerDependent
    set ff .main.f_flow
    set bRun $ff.f_buttons.b_run
    set bClear $ff.f_buttons.b_clear
    set bErase $ff.f_operations.b_erase
    set bBlankCheck $ff.f_operations.b_blankCheck
    set bProgram $ff.f_operations.b_program
    set bVerify $ff.f_operations.b_verify
    set bSpecialBytes $ff.f_operations.b_specialBytes
    set mFile .menubar.file
    set mBuffer .menubar.buffer
    set mDevice .menubar.device
    set mSettings .menubar.settings
    set mHelp .menubar.help
    set menus_List [list $mFile $mBuffer $mDevice $mSettings $mHelp]
    foreach menu $menus_List {
	for {set i 0} {$i <= [$menu index last]} {incr i} {
	    catch {$menu entryconfigure $i -state normal}
	}
    }
    set gui(flowErase) $saveArray(flowErase)
    set gui(flowBlankCheck) $saveArray(flowBlankCheck)
    set gui(flowProgram) $saveArray(flowProgram)
    set gui(flowVerify) $saveArray(flowVerify)
    set gui(flowSpecialBytes) $saveArray(flowSpecialBytes)
    modifyWidgetOption .main.f_device state normal
    if {[lsearch [buildSkipProcList] ptclReadSSB] == -1} then {
	updateGUI onSecurityLevelChange
    }
    if {[info exists bootloaderVerDependent(startAppli)]} then {
	if {! $bootloaderVerDependent(startAppli)} then {
	    catch [.main.f_device.f_startApp.b_start configure -state disabled]
	    catch [.main.f_device.f_buttons.b_exec configure -state disabled]
	}
    }
    updateGuiParameters
    catch [$bRun configure -state normal]
    catch [$bClear configure -state normal]
    update
    #dbgEndProc [info level [info level]]
    return
}
proc onEraseBlockWidgetChangeGUI {w} {
    global gui
    if {$w == "blocks"} then {
	foreach i {0 1 2 3 4} {
	    catch {.deviceErase.f_erase.f_blocks.b_block$i configure -state $gui(erasePossibleBlock$i)}
	}
    } else {
	foreach i {0 1 2 3 4} {
	    catch {.deviceErase.f_erase.f_blocks.b_block$i configure -state disabled}
	}
    }
    return
}
proc onProtocolTestSelectionGUI {} {
    #dbgBeginProc [info level [info level]]
    global testArray
    set wdgt ".testSelectionDbox.f_skip"
    if {$testArray(protocol)} then {
	modifyWidgetOption $wdgt state normal
    } else {
	modifyWidgetOption $wdgt state disabled
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onHsbModifiedGUI {} {
    #dbgBeginProc [info level [info level]]
    global flipStates
    if {$flipStates(simul)} then {
	return
    }
    if {([info exists ::deviceArray(hsb)]) &&($::deviceArray(hsb) != "XX")} then {
	set ::deviceArray(x2Fuse) [expr 0x$::deviceArray(hsb) >> 7]
	if {[info exists ::deviceArray(x2Fuse)]} then {
	    set decal 0x[format %X [expr $::deviceArray(x2Fuse) << 7]]
	}
	set var2 0x[format %X [expr (0x$::deviceArray(hsb)-$decal)]]
	set ::deviceArray(bljbFuse) [expr $var2 >> 6]
	if {[info exists ::deviceArray(bljbFuse)]} then {
	    set decal 0x[format %X [expr $::deviceArray(bljbFuse) << 6]]
	}
	if {[info exists ::deviceArray(oscFuse)]} then {
	    set var3 0x[format %X [expr ($var2-$decal)]]
	    set ::deviceArray(oscFuse) [expr $var3 >> 5]
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onSecurityLevelChangeGUI {} {
    #dbgBeginProc [info level [info level]]
    global expAnsw flipStates bootloaderVerDependent
    set dFrame ".main.f_device"
    if {[checkSecurityLevel] == 0} then {
	#dbgEndProc [info level [info level]]
	return 0
    }
    catch [set eBSB $dFrame.f_bsb_sbv.f_bsb.e_bsb]
    catch [set eSBV $dFrame.f_bsb_sbv.f_sbv.e_sbv]
    catch [set eEB $dFrame.f_bsb_sbv.f_bsb.e_eb]
    foreach i {0 1 2} {
	set wdgt $dFrame.f_ssb.f_level$i.b_level$i
	if {[winfo exists $wdgt]} then {
	    set bLevel$i $wdgt
	}
    }
    foreach i {0 1 2} {
	set wdgt $dFrame.f_ssb.f_level.b_level$i
	if {[winfo exists $wdgt]} then {
	    set bLevel$i $wdgt
	}
    }
    catch [set bUpdate $dFrame.f_buttons.b_update]
    catch [set bWrite $dFrame.f_buttons.b_write]
    catch [set bExec $dFrame.f_buttons.b_exec]
    catch [set bUartBypass $dFrame.f_bypass.cb_bypassUart]
    catch [set bI2cBypass $dFrame.f_bypass.cb_bypassI2c]
    catch [set bOsc $dFrame.f_fuses.b_osc]
    catch [set bBLJB $dFrame.f_fuses.b_bljb]
    catch [set bX2 $dFrame.f_fuses.b_x2]
    set buttonList [list]
    catch [lappend buttonList $bErase]
    catch [lappend buttonList $bUpdate]
    catch [lappend buttonList $bWrite]
    catch [lappend buttonList $bExec]
    set ssbButtonList [list]
    catch [lappend ssbButtonList $bLevel0]
    catch [lappend ssbButtonList $bLevel1]
    catch [lappend ssbButtonList $bLevel2]
    set entryList [list]
    catch [lappend entryList $eSBV]
    catch [lappend entryList $eBSB]
    catch [lappend entryList $eEB]
    set checkButtonList [list]
    catch [lappend checkButtonList $bOsc]
    catch [lappend checkButtonList $bBLJB]
    catch [lappend checkButtonList $bX2]
    if {$flipStates(simul)} then {
	set ::deviceArray(level) 0
    }
    if {$::deviceArray(level) == 0} then {
	foreach entry $entryList {
	    catch [$entry configure -takefocus 1 -state normal]
	}
	if {! $bootloaderVerDependent(eb)} then {
	    catch [.main.f_device.f_bsb_sbv.f_bsb.e_eb configure -state disabled]
	}
	foreach button $buttonList {
	    catch [$button configure -state normal]
	}
	foreach button $ssbButtonList {
	    catch [$button configure -state normal]
	}
	foreach chkButt $checkButtonList {
	    catch [$chkButt configure -state normal]
	}
    } elseif {$::deviceArray(level) == 1} {
	catch [$eSBV configure -takefocus 0 -state disabled]
	catch [$eBSB configure -takefocus 0 -state disabled]
	catch [$eEB configure -takefocus 0 -state disabled]
	catch [$bErase configure -state disabled]
	catch [$bLevel0 configure -state disabled]
	catch [$bLevel1 configure -state normal]
	catch [$bLevel2 configure -state normal]
	catch [$bUpdate configure -state normal]
	catch [$bWrite configure -state normal]
	foreach chkButt $checkButtonList {
	    catch [$chkButt configure -state disabled]
	}
    } elseif {$::deviceArray(level) == 2} {
	foreach entry $entryList {
	    catch [$entry configure -takefocus 0 -state disabled]
	}
	foreach button $buttonList {
	    catch [$button configure -state disabled]
	}
	foreach chkButt $checkButtonList {
	    catch [$chkButt configure -state disabled]
	}
	foreach button $ssbButtonList {
	    catch [$button configure -state disabled]
	}
    } else {
	if {! $flipStates(simul)} then {
	    set message "The security level value is not valid."
	    messageBox "Information" error $message
	    return 0
	}
    }
    if {([info exists ::deviceArray(ssb)]) &&($::deviceArray(ssb) == "XX")} then {
	set ::deviceArray(level) X
	catch [$bLevel2 configure -state disabled]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onCanNodeSelectionGUI {state} {
    #dbgBeginProc [info level [info level]]
    global canPort canBaud canProtocol flipStates port baud
    global protcl
    set flipStates(canNode) $state
    if {$state == "open"} then {
	if {$protcl == "CANStandard" || $protcl == "usbcan"} then {
	    catch [set fButtons .canSetup.f_b]
	    catch [focus .canSetup]
	    catch [.f_status.l_comm configure -text "$canPort / $canBaud  / $::deviceArray(nnbConnect) / $::deviceArray(crisConnect) "]
	    log_message "CAN node $::deviceArray(nnbConnect) opened."
	    catch [$fButtons.b_start configure -text "Node Disconnect"]
	}
	#david eseo
	if {($protcl == "rs232can") ||($protcl == "canview")} then {
	    set fButtons .rs232canSetup.f_b
	    catch [focus .rs232canSetup]
	    catch [.f_status.l_comm configure -text "$port / $baud  / $::deviceArray(nnbConnect) / $::deviceArray(crisConnect) "]
	    log_message "CAN node $::deviceArray(nnbConnect) opened."
	    catch [$fButtons.b_start configure -text "Node Disconnect"]
	}
	#fin david eseo  
	set ::deviceArray(currentMemory) [lindex $::deviceArray(memoryList) 0]
	cmdsImportCurrentMemoryNameSpace $::deviceArray(currentMemory)
	catch [.main.f_device.f_buttons.b_canconfig configure -state normal]
	catch [.main.f_device.f_startApp.b_start configure -state normal -bg red -fg yellow]
	catch [.main.f_device.f_buttons.b_exec configure -state normal -bg red -fg yellow]
	catch [.main.f_device.f_startApp.b_reset configure -state normal]
	catch [.main.f_buffer.b_memSelect configure -state normal -text [lindex $::deviceArray(memoryButtonList) 0] -bg [lindex $::deviceArray(memoryColor) 0] -fg black]
	if {[winfo exists .main.f_buffer.b_memSelect]} then {
	    pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
	}
	updateGuiParameters
    } else {
	if {$protcl == "CANStandard" || $protcl == "usbcan"} then {
	    catch [set fButtons .canSetup.f_b]
	    catch [focus .canSetup]
	    catch [.f_status.l_comm configure -text "$canPort / $canBaud  / $::deviceArray(nnbConnect) / $::deviceArray(crisConnect) "]
	    log_message "CAN node $::deviceArray(nnbConnect) closed."
	    catch [$fButtons.b_start configure -text "Node Connect"]
	}
	#david eseo
	if {($protcl == "rs232can") ||($protcl == "canview")} then {
	    set fButtons .rs232canSetup.f_b
	    catch [focus .rs232canSetup]
	    catch [.f_status.l_comm configure -text "$port / $baud  / $::deviceArray(nnbConnect) / $::deviceArray(crisConnect) "]
	    log_message "CAN node $::deviceArray(nnbConnect) closed."
	    catch [$fButtons.b_start configure -text "Node Connect"]
	}
	#fin david eseo  
	set ::deviceArray(currentMemory) [lindex $::deviceArray(memoryList) 0]
	cmdsImportCurrentMemoryNameSpace $::deviceArray(currentMemory)
	catch [.main.f_device.f_buttons.b_canconfig configure -state disabled]
	catch [.main.f_device.f_startApp.b_start configure -state disabled -bg grey]
	catch [.main.f_device.f_startApp.b_reset configure -state disabled]
	catch [.main.f_device.f_buttons.b_exec configure -state disabled -bg grey]
	catch [.main.f_buffer.b_memSelect configure -state disabled -text [lindex $::deviceArray(memoryButtonList) 0] -bg [lindex $::deviceArray(memoryColor) 0] -fg black]
	updateGuiParameters
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onCanCommStatusModifiedGUI {} {
    #dbgBeginProc [info level [info level]]
    global flipStates canPort canBaud canProtocol
    catch [set fButtons .canSetup.f_b]
    if {$flipStates(canComm) == "on"} then {
	catch [.f_status.l_comm configure -text "$canPort / $canBaud"]
	if {[winfo exists .canSetup]} then {
	    catch [$fButtons.b_init configure -text "Cancel CAN" -command {ptclCancelCANComm} -state normal]
	    catch [$fButtons.b_start configure -state normal]
	}
	set menuCAN ".menubar.settings.comm.select"
	foreach m {"ATMEL RS232" "RM CANview" "VECTOR" "IXXAT CANdy" "PEAK PCAN-DONGLE" "ATMEL USB" "SYSTEC USBCAN"} {
	    catch [$menuCAN entryconfigure [$menuCAN index $m] -state disabled]
	}
	if {$canProtocol(hardware) == "ATMEL_RS232"} then {
	    catch [$menuCAN entryconfigure [$menuCAN index "ATMEL RS232"] -state normal]
	} elseif {$canProtocol(hardware) == "CANVIEW"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "RM CANview"] -state normal]
	} elseif {$canProtocol(hardware) == "CANPARI"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "VECTOR"] -state normal]
	} elseif {$canProtocol(hardware) == "CANCARDX"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "VECTOR"] -state normal]
	} elseif {$canProtocol(hardware) == "CANDY"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "IXXAT CANdy"] -state normal]
	} elseif {$canProtocol(hardware) == "PEAK"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "PEAK PCAN-DONGLE"] -state normal]
	} elseif {$canProtocol(hardware) == "ATMEL_USB"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "ATMEL USB"] -state normal]
	} elseif {$canProtocol(hardware) == "SYSTEC"} {
	    catch [$menuCAN entryconfigure [$menuCAN index "SYSTEC USBCAN"] -state normal]
	}
    } else {
	catch [.f_status.l_comm configure -text "Comm. OFF"]
	if {[winfo exists .canSetup]} then {
	    catch [$fButtons.b_init configure -text "Init" -state normal -command {ptclInitCANinterface}]
	    catch [$fButtons.b_start configure -state disabled]
	}
	set menuCAN ".menubar.settings.comm.select"
	foreach m {"ATMEL RS232" "RM CANview" "VECTOR" "IXXAT CANdy" "PEAK PCAN-DONGLE" "SYSTEC USBCAN"} {
	    catch [$menuCAN entryconfigure [$menuCAN index $m] -state normal]
	}
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onInitialBufferContentsChangeGUI {} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    set w .bufferOptionsWindow
    catch [$w.f_bufferInit.f_bufferContentsValue.b_deviceDependent configure -text "[readDeviceArray blankValue] / $::deviceArray(name)" -state normal]
    set eBufferInitialContents .bufferOptionsWindow.f_bufferInit.f_bufferContentsValue.e_bufferBlankValue
    if {$gui(blankValueType) == "deviceDependent"} then {
	set gui(dDepBlankValue) [readDeviceArray blankValue]
	set gui(blankValue) $gui(dDepBlankValue)
	set gui(fillValue) $gui(blankValue)
	catch [$eBufferInitialContents configure -state disabled]
    } else {
	set gui(blankValue) $gui(uDefBlankValue)
	set gui(fillValue) $gui(blankValue)
	catch [$eBufferInitialContents configure -state normal]
    }
    catch [.main.f_buffer.l_bufferBlank configure -text "Blank:\t$gui(blankValue)"]
    #dbgEndProc [info level [info level]]
    return
}
proc onBufferSizeTypeChangeGUI {} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    set memorySize [readDeviceArray memorySize]
    #dbgShowVar "memory size = $memorySize"
    set w .bufferOptionsWindow
    catch [$w.f_bufferSize.f_bufferSizeValue.b_deviceDependent configure -text "$memorySize / $::deviceArray(name)" -state normal]
    set eBufferSize .bufferOptionsWindow.f_bufferSize.f_bufferSizeValue.e_bufferSizeValue
    if {$gui(sizeType) == "deviceDependent"} then {
	set gui(dDepSizeValue) $memorySize
	set gui(sizeValue) $memorySize
	if {[winfo exists $eBufferSize]} then {
	    catch [$eBufferSize configure -state disabled]
	}
    } else {
	set gui(sizeValue) $gui(uDefSizeValue)
	if {[winfo exists $eBufferSize]} then {
	    catch [$eBufferSize configure -state normal]
	}
    }
    set gui(maxAddr) [format $gui(infoFormat) [expr ($gui(sizeValue) * 1024) - 1]]
    set gui(numberOfLines) [expr ("0x$gui(maxAddr)" + 1) / 16]
    #dbgEndProc [info level [info level]]
    return
}
proc onBlankCheckOptionsChangeGUI {} {
    global gui
    writeBuffer blankCheckMin $gui(blankCheckMin)
    writeBuffer blankCheckMax $gui(blankCheckMax)
    return
}
proc onAddrProgRangeChangeGUI {} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    set memorySize [readBuffer sizeValue]
    #dbgShowVar "memory size = $memorySize"
    set gui(maxAddr) [format $gui(infoFormat) [expr ($memorySize * 1024) - 1]]
    set wdgtMin .bufferOptionsWindow.f_bufferRange.f_uDefined.e_bufferRangeMin
    set wdgtMax .bufferOptionsWindow.f_bufferRange.f_uDefined.e_bufferRangeMax
    if {$gui(rangeOnDeviceProg) == "lastLoad"} then {
	catch [$wdgtMin configure -state disabled]
	catch [$wdgtMax configure -state disabled]
	if {$gui(fileLoaded) == "no"} then {
	    set gui(lastLoadMinProgAddr) [format $gui(infoFormat) 0x000000]
	    set gui(lastLoadMaxProgAddr) [format $gui(infoFormat) 0x$gui(maxAddr)]
	}
	set gui(minProgAddr) [format $gui(infoFormat) 0x$gui(lastLoadMinProgAddr)]
	set gui(maxProgAddr) [format $gui(infoFormat) 0x$gui(lastLoadMaxProgAddr)]
    } elseif {$gui(rangeOnDeviceProg) == "whole"} {
	catch [$wdgtMin configure -state disabled]
	catch [$wdgtMax configure -state disabled]
	set gui(minProgAddr) [format $gui(infoFormat) 0x000000]
	set gui(maxProgAddr) [format $gui(infoFormat) 0x$gui(maxAddr)]
    } else {
	catch [$wdgtMin configure -state normal]
	catch [$wdgtMax configure -state normal]
	set gui(minProgAddr) [format $gui(infoFormat) 0x$gui(uDefMinProgAddr)]
	set gui(maxProgAddr) [format $gui(infoFormat) 0x$gui(uDefMaxProgAddr)]
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onTestDebugChangedGUI {} {
    #dbgBeginProc [info level [info level]]
    global testArray
    if {$testArray(debug) == "on"} then {
	#dbgCtrl on
    } else {
	#dbgCtrl off
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onConfigFileLoadedGUI {} {
    #dbgBeginProc [info level [info level]]
    global gui
    set menuF ".menubar.file"
    catch [$menuF entryconfigure [$menuF index "Execute Configuration File"] -state normal]
    foreach i {flowErase flowBlankCheck flowProgram flowVerify flowSpecialBytes} {
	set gui($i) 0
	#dbgShowVar "gui($i) = $gui([subst $i])"
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onRs232CommunicationGUI {state} {
    #dbgBeginProc [info level [info level]]
    global flipStates port baud projDir flipFont protcl bootloaderVerDependent
    if {$state == "normal"} then {
	set flipStates(rs232Comm) "on"
	if {[info exists ::deviceArray(bootloaderId)]} then {
	    if {[file exists $projDir/tcl/protocol/rs232_${::deviceArray(bootloaderId)}.tcl]} then {
		source $projDir/tcl/protocol/rs232_${::deviceArray(bootloaderId)}.tcl
	    }
	}
	catch [.f_status.l_comm configure -relief sunken -anchor w -borderwidth 1 -background grey -foreground black -text "$port / $baud" -font $flipFont]
	catch [.rs232CommDbox.f_buttons.b_connect configure -state disabled]
	catch [.rs232CommDbox.f_buttons.b_connectOnly configure -state disabled]
	catch [.rs232CommDbox.f_buttons.b_disconnect configure -state normal]
	catch [.rs232CommDbox.f_buttons.b_synchro configure -state normal]
	#Rs23canDBox update david eseo
	if {[winfo exists .rs232canSetup]} then {
	    catch [.rs232canSetup.f_b.b_comm configure -text "Cancel Comm" -command {ptclCancelRs232Comm} -state normal]
	    catch [.rs232canSetup.f_b.b_start configure -state normal]
	}
	#fin david eseo
	set ::deviceArray(currentMemory) [lindex $::deviceArray(memoryList) 0]
	cmdsImportCurrentMemoryNameSpace $::deviceArray(currentMemory)
	if {$bootloaderVerDependent(startAppli)} then {
	    catch [.main.f_device.f_startApp.b_start configure -state normal -bg red -fg yellow]
	    catch [.main.f_device.f_buttons.b_exec configure -state normal -bg red -fg yellow]
	    catch [.main.f_device.f_startApp.b_reset configure -state normal]
	}
	if {$bootloaderVerDependent(eeprom)} then {
	    if {[winfo exists .main.f_buffer.b_memSelect]} then {
		pack .main.f_buffer.b_memSelect -side bottom -expand 0 -pady 17
		catch [.main.f_buffer.b_memSelect configure -state normal -text [lindex $::deviceArray(memoryButtonList) 0] -bg [lindex $::deviceArray(memoryColor) 0] -fg black]
	    }
	}
	updateGuiParameters
    } else {
	set flipStates(rs232Comm) "off"
	catch [.f_status.l_comm configure -relief sunken -anchor w -borderwidth 1 -background grey -foreground black -text "Comm. OFF" -font $flipFont]
	catch [.rs232CommDbox.f_buttons.b_connect configure -state normal]
	catch [.rs232CommDbox.f_buttons.b_connectOnly configure -state normal]
	catch [.rs232CommDbox.f_buttons.b_disconnect configure -state disabled]
	catch [.rs232CommDbox.f_buttons.b_synchro configure -state disabled]
	#Rs232canDBox update david eseo
	if {[winfo exists .rs232canSetup]} then {
	    catch [.rs232canSetup.f_b.b_comm configure -text "Init Comm" -command {ptclInitComm} -state normal]
	    catch [.rs232canSetup.f_b.b_start configure -state disabled]
	}
	#fin david eseo
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onDeviceSelectionGUI {} {
    #dbgBeginProc [info level [info level]]
    updateGuiParameters
    set menuF ".menubar.file"
    foreach m {"Load HEX..." "Save HEX As..."} {
	catch [$menuF entryconfigure [$menuF index $m] -state normal]
    }
    catch [$menuF entryconfigure [$menuF index "Save Configuration As..."] -state normal]
    set menuB ".menubar.buffer"
    foreach m {"Edit" "Options"} {
	catch [$menuB entryconfigure [$menuB index $m] -state normal]
    }
    set commMenu ".menubar.settings.comm"
    foreach m {"RS232" "CAN" "USB"} {
	catch [$commMenu entryconfigure [$commMenu index $m] -state disabled]
    }
    foreach item $::deviceArray(communicationList) {
	catch [$commMenu entryconfigure [$commMenu index $item] -state normal]
    }
    if {! [winfo exists .rs232CommDbox]} then {
	drawRs232CommDbox $::deviceArray(RS232ProtocolsList)
    }
    bind . <F3> {}
    if {[llength $::deviceArray(communicationList)] == 1} then {
	if {$::deviceArray(communicationList) == "RS232"} then {
	    bind . <F3> {initProtocol "RS232Standard"
		cbDboxWakeUp .rs232CommDbox}
	} elseif {$::deviceArray(communicationList) == "CAN"} {
	    bind . <F3> {initProtocol "CANStandard"
		cbDboxWakeUp .canSetup}
	} elseif {$::deviceArray(communicationList) == "USB"} {
	    bind . <F3> {
		initProtocol "USB_DFU"
	    }
	}
    } else {
	bind . <F3> {popupCommMenu}
    }
    foreach w {connect bufferedit loadhex savehex} {
	.main.toolbar.$w configure -state normal
    }
    if {[winfo exists .main.f_device.f_crc.b_crc]} then {
	.main.f_device.f_crc.b_crc configure -state normal
    }
    #dbgEndProc [info level [info level]]
    return
}
proc onAnyCommunicationGUI {state} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates protcl bootloaderVerDependent
    if {$state == "normal"} then {
	set flipStates(anyComm) "on"
	catch [.deviceErase.f_erase.f_blocks.b_blockErase configure -state $gui(erasePossibleBlocks)]
	if {$gui(eraseType) == "blocks"} then {
	    foreach i {0 1 2 3 4} {
		catch [.deviceErase.f_erase.f_blocks.b_block$i configure -state $gui(erasePossibleBlock$i)]
	    }
	} else {
	    foreach i {0 1 2 3 4} {
		catch [.deviceErase.f_erase.f_blocks.b_block$i configure -state disabled]
	    }
	}
	set gui(erase) [readBuffer erase]
	set gui(blankCheck) [readBuffer blankCheck]
	modifyWidgetOption .main.f_device state normal
	if {$protcl == "RS232Standard"} then {
	    if {$::deviceArray(name) != "T89C51AC2"} then {
		catch [.main.f_device.f_buttons.b_canconfig configure -state disabled]
	    }
	}
	if {! $bootloaderVerDependent(startAppli)} then {
	    catch [.main.f_device.f_startApp.b_start configure -state disabled -bg grey]
	    catch [.main.f_device.f_startApp.b_reset configure -state disabled]
	    catch [.main.f_device.f_buttons.b_exec configure -state disabled -bg grey]
	}
	if {! $bootloaderVerDependent(eb)} then {
	    catch [.main.f_device.f_bsb_sbv.f_bsb.e_eb configure -state disabled]
	}
	foreach w {erase blankcheck program verify read} {
	    .main.toolbar.$w configure -state normal
	}
	foreach w {program verify read} {
	    .bufferEditWindow.f_editBuffer.toolbar.$w configure -state normal
	}
	if {! $flipStates(connectOnlyRS232)} then {
	    devcUpdateDeviceFrame
	}
	updateGuiParameters
    } else {
	set flipStates(anyComm) "off"
	set gui(erase) disabled
	set gui(blankCheck) disabled
	if {[info exists ::deviceArray(manufId)]} then {
	    set ::deviceArray(manufId) "XX"
	}
	if {[info exists ::deviceArray(deviceId1)]} then {
	    set ::deviceArray(deviceId1) "XX"
	}
	if {[info exists ::deviceArray(deviceId2)]} then {
	    set ::deviceArray(deviceId2) "XX"
	}
	if {[info exists ::deviceArray(deviceId3)]} then {
	    set ::deviceArray(deviceId3) "XX"
	}
	if {[info exists ::deviceArray(deviceBootId1)]} then {
	    set ::deviceArray(deviceBootId1) "XX"
	}
	if {[info exists ::deviceArray(deviceBootId2)]} then {
	    set ::deviceArray(deviceBootId2) "XX"
	}
	if {[info exists ::deviceArray(hsb)]} then {
	    set ::deviceArray(hsb) "XX"
	}
	if {[info exists ::deviceArray(bootlVer)]} then {
	    set ::deviceArray(bootlVer) "X.X.X"
	}
	if {[info exists ::deviceArray(sbv)]} then {
	    set ::deviceArray(sbv) "XX"
	}
	if {[info exists ::deviceArray(bsb)]} then {
	    set ::deviceArray(bsb) "XX"
	}
	if {[info exists ::deviceArray(eb)]} then {
	    set ::deviceArray(eb) "XX"
	}
	if {[info exists ::deviceArray(ssb)]} then {
	    set ::deviceArray(ssb) "XX"
	}
	if {[info exists ::deviceArray(crc)]} then {
	    set ::deviceArray(crc) "XXXX"
	}
	if {[info exists ::deviceArray(p1_config)]} then {
	    set ::deviceArray(p1_config) "XX"
	}
	if {[info exists ::deviceArray(p3_config)]} then {
	    set ::deviceArray(p3_config) "XX"
	}
	if {[info exists ::deviceArray(p4_config)]} then {
	    set ::deviceArray(p4_config) "XX"
	}
	modifyWidgetOption .main.f_device state disabled
	catch [.main.f_device.f_startApp.b_start configure -bg grey]
	catch [.main.f_device.f_buttons.b_exec configure -bg grey]
	cmdsClearOperations "colorOnly"
	if {[winfo exists .main.f_buffer.b_memSelect]} then {
	    pack forget .main.f_buffer.b_memSelect
	}
	foreach w {erase blankcheck program verify read} {
	    .main.toolbar.$w configure -state disabled
	}
	foreach w {program verify read} {
	    .bufferEditWindow.f_editBuffer.toolbar.$w configure -state disabled
	}
    }
    set menuD ".menubar.device"
    catch [$menuD entryconfigure [$menuD index "Erase..."] -state $gui(erase)]
    catch [$menuD entryconfigure [$menuD index "Blank Check..."] -state $gui(blankCheck)]
    foreach m {"Read..." "Program" "Verify"} {
	catch [$menuD entryconfigure [$menuD index $m] -state $state]
    }
    set menuBuffD ".bufferEditWindow.menubar.device"
    foreach m {"Read" "Program" "Verify"} {
	catch [$menuBuffD entryconfigure [$menuBuffD index $m] -state $state]
    }
    modifyWidgetOption ".main.f_flow" state $state
    set opFrame ".main.f_flow.f_operations"
    catch [$opFrame.b_erase configure -state $gui(erase)]
    catch [$opFrame.b_blankCheck configure -state $gui(blankCheck)]
    #dbgEndProc [info level [info level]]
    return
}
proc modifyWidgetOption {wdgt opt value} {
    foreach W [winfo children $wdgt] {
	catch [$W configure -$opt $value]
	modifyWidgetOption $W $opt $value
    }
    return
}
proc updateGuiParameters {} {
    #dbgBeginProc [info level [info level]]
    global gui flipStates
    set index [lsearch $::deviceArray(memoryList) $::deviceArray(currentMemory)]
    set bgColor [lrange $::deviceArray(memoryColor) $index $index]
    set bMemorySelect .main.f_buffer.b_memSelect
    if {[winfo exists $bMemorySelect]} then {
	if {[winfo viewable $bMemorySelect]} then {
	    catch [$bMemorySelect configure -text $::deviceArray(currentMemoryButton) -bg $bgColor]
	    catch [.bufferEditWindow.f_editBuffer.f_txt.text configure -bg $bgColor]
	    catch [.main.f_buffer.l_bufferInfoTitle configure -bg $bgColor -text "$::deviceArray(currentMemory) Buffer Information"]
	    catch [.main.f_flow.l_flow configure -bg $bgColor]
	    wm title .bufferOptionsWindow "$::deviceArray(currentMemory) Buffer Options"
	} else {
	    catch [.main.f_buffer.l_bufferInfoTitle configure -bg [.main cget -background] -text "Buffer Information"]
	    catch [.main.f_flow.l_flow configure -bg [.main cget -background]]
	}
    } else {
	catch [.main.f_buffer.l_bufferInfoTitle configure -bg [.main cget -background] -text "Buffer Information"]
	catch [.main.f_flow.l_flow configure -bg [.main cget -background]]
    }
    set gui(uDefSizeValue) [readBuffer uDefSizeValue]
    set gui(dDepSizeValue) [readBuffer dDepSizeValue]
    set gui(sizeValue) $gui(dDepSizeValue)
    set gui(rangeOnDeviceProg) [readBuffer rangeOnDeviceProg]
    set frUdef .bufferOptionsWindow.f_bufferRange.f_uDefined
    if {$gui(rangeOnDeviceProg) == "userDefined"} then {
	catch [$frUdef.e_bufferRangeMin configure -state normal]
	catch [$frUdef.e_bufferRangeMax configure -state normal]
    } else {
	catch [$frUdef.e_bufferRangeMin configure -state disabled]
	catch [$frUdef.e_bufferRangeMax configure -state disabled]
    }
    set gui(fileLoaded) [readBuffer fileLoaded]
    set gui(sizeType) [readBuffer sizeType]
    updateGUI onBufferSizeTypeChange
    set gui(maxAddr) [readBuffer maxAddr]
    set gui(blankValueType) [readBuffer blankValueType]
    set gui(uDefBlankValue) [readBuffer uDefBlankValue]
    set gui(dDepBlankValue) [readBuffer dDepBlankValue]
    set gui(blankValue) [readDeviceArray blankValue]
    updateGUI onInitialBufferContentsChange
    set gui(resetBufferOnLoading) [readBuffer resetBufferOnLoading]
    set gui(uDefMinProgAddr) [format $gui(infoFormat) 0x[readBuffer uDefMinProgAddr]]
    set gui(uDefMaxProgAddr) [format $gui(infoFormat) 0x[readBuffer uDefMaxProgAddr]]
    set gui(lastLoadMinProgAddr) [readBuffer lastLoadMinProgAddr]
    set gui(lastLoadMaxProgAddr) [readBuffer lastLoadMaxProgAddr]
    if {([info exists ::deviceArray(bootloaderId)]) &&($::deviceArray(bootloaderId) == "0001")} then {
	set gui(minProgAddr) 0
	set gui(maxProgAddr) [format "%X" [expr [readDeviceArray memorySize] * 1024 - 1]]
    } else {
	set gui(minProgAddr) [readBuffer minProgAddr]
	set gui(maxProgAddr) [readBuffer maxProgAddr]
    }
    set gui(loadingOffset) [readBuffer loadingOffset]
    set gui(hexFileAddrOffset) [readBuffer hexFileAddrOffset]
    set gui(modifyAddress) [readBuffer modifyAddress]
    set gui(modifyData) [readBuffer modifyData]
    set gui(numberOfVisibleLines) [readBuffer numberOfVisibleLines]
    set gui(topDisplayedLine) [readBuffer topDisplayedLine]
    set gui(bottomDisplayedLine) [readBuffer bottomDisplayedLine]
    set gui(numberOfLines) [readBuffer numberOfLines]
    set gui(startFillAddr) [readBuffer startFillAddr]
    set gui(endFillAddr) [readBuffer endFillAddr]
    set gui(fillValue) [readBuffer fillValue]
    set gui(maxSize) [readBuffer maxSize]
    set gui(blankCheckMin) [readBuffer blankCheckMin]
    set gui(blankCheckMax) [readBuffer blankCheckMax]
    set gui(hexFileName) [readBuffer hexFileName]
    set gui(hexFileSize) [readBuffer hexFileSize]
    if {$gui(init)} then {
	set gui(minProgAddr) 0
	set gui(maxProgAddr) $gui(maxAddr)
    } elseif {$gui(rangeOnDeviceProg) == "lastLoad"} {
	set gui(minProgAddr) $gui(lastLoadMinProgAddr)
	set gui(maxProgAddr) $gui(lastLoadMaxProgAddr)
    }
    if {$flipStates(anyComm) == "on"} then {
	set gui(erase) [readBuffer erase]
	set gui(blankCheck) [readBuffer blankCheck]
    } else {
	set gui(erase) disabled
	set gui(blankCheck) disabled
    }
    set menuD ".menubar.device"
    catch [$menuD entryconfigure [$menuD index "Erase..."] -state $gui(erase)]
    catch [$menuD entryconfigure [$menuD index "Blank Check..."] -state $gui(blankCheck)]
    set opFrame ".main.f_flow.f_operations"
    catch [$opFrame.b_erase configure -state $gui(erase)]
    catch [$opFrame.b_blankCheck configure -state $gui(blankCheck)]
    set gui(eraseType) [readBuffer eraseType]
    set gui(erasePossibleBlocks) [readBuffer erasePossibleBlocks]
    set gui(erasePossibleBlock0) [readBuffer erasePossibleBlock0]
    set gui(erasePossibleBlock1) [readBuffer erasePossibleBlock1]
    set gui(erasePossibleBlock2) [readBuffer erasePossibleBlock2]
    set gui(erasePossibleBlock3) [readBuffer erasePossibleBlock3]
    set gui(erasePossibleBlock4) [readBuffer erasePossibleBlock4]
    set gui(eraseBlock0) [readBuffer eraseBlock0]
    set gui(eraseBlock1) [readBuffer eraseBlock1]
    set gui(eraseBlock2) [readBuffer eraseBlock2]
    set gui(eraseBlock3) [readBuffer eraseBlock3]
    set gui(eraseBlock4) [readBuffer eraseBlock4]
    set gui(startReadAddr) [readBuffer startReadAddr]
    set gui(endReadAddr) [readBuffer endReadAddr]
    catch [.main.f_buffer.l_bufferSize configure -text "Size:\t$gui(sizeValue) Kbytes"]
    catch [.main.f_buffer.l_bufferBlank configure -text "Blank:\t$gui(blankValue)"]
    catch [.main.f_buffer.l_range configure -text "Range:\t[format $gui(infoFormat) 0x$gui(minProgAddr)] - [format $gui(infoFormat) 0x$gui(maxProgAddr)]"]
    if {$gui(resetBufferOnLoading) == "yes"} then {
	catch [.main.f_buffer.l_bufferReset configure -text "Reset Before Loading"]
    } else {
	catch [.main.f_buffer.l_bufferReset configure -text "No Reset Before Loading"]
    }
    catch [.main.f_buffer.l_offset configure -text "Offset:\t[format $gui(infoFormat) 0x$gui(loadingOffset)]"]
    catch [.main.f_buffer.f_hexFile.l_fileN configure -text $gui(hexFileName)]
    catch [.main.f_buffer.f_hexFileSize.title.l_fileS configure -text $gui(hexFileSize) -fg blue]
    set ff .main.f_flow
    set bErase $ff.f_operations.b_erase
    set bBlankCheck $ff.f_operations.b_blankCheck
    set bProgram $ff.f_operations.b_program
    set bVerify $ff.f_operations.b_verify
    set bSpecialBytes $ff.f_operations.b_specialBytes
    set gui(flowErase) [readBuffer flowErase]
    set gui(flowBlankCheck) [readBuffer flowBlankCheck]
    set gui(flowProgram) [readBuffer flowProgram]
    set gui(flowVerify) [readBuffer flowVerify]
    set gui(flowSpecialBytes) [readBuffer flowSpecialBytes]
    set gui(flowEraseColor) [readBuffer flowEraseColor]
    set gui(flowBlankCheckColor) [readBuffer flowBlankCheckColor]
    set gui(flowProgramColor) [readBuffer flowProgramColor]
    set gui(flowVerifyColor) [readBuffer flowVerifyColor]
    set gui(flowSpecialBytesColor) [readBuffer flowSpecialBytesColor]
    catch [$bErase configure -selectcolor $gui(flowEraseColor)]
    catch [$bBlankCheck configure -selectcolor $gui(flowBlankCheckColor)]
    catch [$bProgram configure -selectcolor $gui(flowProgramColor)]
    catch [$bVerify configure -selectcolor $gui(flowVerifyColor)]
    catch [$bSpecialBytes configure -selectcolor $gui(flowSpecialBytesColor)]
    updateBufferChecksum
    updateBufferWidget 0.0
    set gui(init) 0
    #dbgEndProc [info level [info level]]
    return
}
package provide about
namespace eval ::about {
    namespace export showAbout
}
if {[lsearch [namespace children] ::libtk] == -1} then {
    package require libtk
    namespace import libtk::*
}
proc ::about::showAbout {args} {
    set w ::about::createAboutPriv
    upvar #0 $w data
    global ::libtk::atmelBlue
    #dbgBeginProc [info level [info level]]
    set info_bgcol $atmelBlue
    set info_fgcol white
    if {[lsearch [font names] "defaultFont"] == -1} then {
	setSystemFonts
    }
    set specs {
{-title " "}
{-version " "}
{-copyright " "}
{-authors " "}
{-comment " "}
{-url " "}
{-logo " " }
}
    parseOptions $w $specs $args
    if {[winfo exists .about]} then {
	wm deiconify .about
	return
    }
    set about [toplevel .about -borderwidth 10]
    wm title $about "About"
    wm resizable $about 0 0
    wm protocol .about WM_DELETE_WINDOW {set about_ok 1}
    grab $about
    focus .about
    set about_fr [frame $about.frame -relief groove -borderwidth 2]
    if {$data(-logo) != " "} then {
	label $about_fr.logo -image [image create photo -file $data(-logo)] -relief flat -borderwidth 2 -background white
	pack $about_fr.logo -fill both -expand true -padx 2 -pady 1
    }
    if {($data(-title) != " ") ||($data(-version) != " ")} then {
	label $about_fr.title -text "$data(-title) $data(-version)" -font defaultFont18b -fg white -bg black
	pack $about_fr.title -fill both -expand true -ipadx 4 -ipady 4 -padx 2 -pady 1
    }
    set there_is_info false
    frame $about_fr.info -bg $info_bgcol
    if {$data(-copyright) != " "} then {
	label $about_fr.info.copyright -text $data(-copyright) -font defaultFont12b -fg $info_fgcol -bg $info_bgcol
	pack $about_fr.info.copyright -anchor w -pady 4
	set there_is_info true
    }
    if {$data(-authors) != " "} then {
	frame $about_fr.info.authors -bg $info_bgcol
	label $about_fr.info.authors.title -text "Authors:" -font defaultFont12b -justify left -fg $info_fgcol -bg $info_bgcol
	label $about_fr.info.authors.contents -text $data(-authors) -font defaultFont12 -justify left -foreground $info_fgcol -background $info_bgcol
	pack $about_fr.info.authors.title -side left
	pack $about_fr.info.authors.contents -side right
	pack $about_fr.info.authors -anchor w -pady 4
	set there_is_info true
    }
    if {$data(-comment) != " "} then {
	set CharNb [string length $data(-comment)]
	if {$CharNb < 60} then {
	    set h 1
	    set w $CharNb
	} else {
	    set h [expr $CharNb / 60 + 1]
	    set w 60
	}
	text $about_fr.info.comment -font defaultFont10 -wrap word -foreground $info_fgcol -background $info_bgcol -relief flat -borderwidth 0 -highlightthickness 0 -selectborderwidth 0 -selectbackground $info_bgcol -selectforeground $info_fgcol -height $h -width $w
	$about_fr.info.comment insert end $data(-comment)
	$about_fr.info.comment tag add InfoText 1.0 end
	$about_fr.info.comment tag configure InfoText -justify left
	$about_fr.info.comment configure -state disabled
	pack $about_fr.info.comment -anchor w -pady 4
	set there_is_info true
    }
    if {$there_is_info == "true"} then {
	pack $about_fr.info -fill both -expand true -padx 2 -pady 1
    }
    if {$data(-url) != " "} then {
	text $about_fr.url -height 1 -width [string length $data(-url)] -relief flat -cursor hand2 -foreground blue -font defaultFont10
	$about_fr.url insert end $data(-url)
	$about_fr.url tag add UrlText 1.0 end
	$about_fr.url tag configure UrlText -justify center
	$about_fr.url configure -state disabled
	pack $about_fr.url -fill both -expand true -padx 2 -pady 1
	bind $about_fr.url <ButtonPress-1> [list wwwBrowser $data(-url)]
    }
    pack $about_fr -expand true -fill both
    frame $about.line -borderwidth 1 -height 2 -relief sunken -width 125
    pack $about.line -expand true -fill x -pady 10
    button $about.ok -text OK -command {set about_ok 1}
    pack $about.ok -side right
    bind $about <Return> {set about_ok 1}
    tkwait variable about_ok
    destroy $about
    #dbgEndProc [info level [info level]]
    return
}
package provide balloon
namespace eval ::balloon {
    namespace export setBalloon
}
bind Bulle <Enter> {
    set Bulle(set) 0
    set Bulle(first) 1
    set Bulle(id) [after 1000 {::balloon::Balloon %W $Bulle(%W) %X %Y}]
}
bind Bulle <Button> {
    set Bulle(first) 0
    ::balloon::KillBalloon
}
bind Bulle <Leave> {
    set Bulle(first) 0
    ::balloon::KillBalloon
}
bind Bulle <Motion> {
    if {$Bulle(set) == 0} then {
	after cancel $Bulle(id)
	set Bulle(id) [after 1000 {::balloon::Balloon %W $Bulle(%W) %X %Y}]
    }
}
proc ::balloon::setBalloon {target message} {
    global Bulle
    set Bulle($target) $message
    bindtags $target "[bindtags $target] Bulle"
}
proc ::balloon::KillBalloon {} {
    global Bulle
    after cancel $Bulle(id)
    if {[winfo exists .balloon] == 1} then {
	destroy .balloon
    }
    set Bulle(set) 0
}
proc ::balloon::Balloon {target message {cx 0} {cy 0}} {
    global Bulle
    if {$Bulle(first) == 1} then {
	set Bulle(first) 2
	if {$cx == 0 && $cy == 0} then {
	    set x [expr [winfo rootx $target] + ([winfo width $target]/2)]
	    set y [expr [winfo rooty $target] + [winfo height $target] + 4]
	} else {
	    set x [expr $cx + 4]
	    set y [expr $cy + 4]
	}
	catch [toplevel .balloon -bg black -screen [winfo screen $target]]
	catch [wm overrideredirect .balloon 1]
	label .balloon.l -text $message -relief flat -bg #ffffdd -fg black -padx 2 -pady 0 -anchor w
	catch [pack .balloon.l -side left -padx 1 -pady 1]
	catch [wm geometry .balloon +${x}+${y}]
	set Bulle(set) 1
    }
}
package require Tk 8.0
package provide combobox 2.0
namespace eval ::combobox {
    namespace export combobox
    variable widgetOptions
    variable widgetCommands
    variable scanCommands
    variable listCommands
}
proc ::combobox::combobox {w args} {
    variable widgetOptions
    variable widgetCommands
    variable scanCommands
    variable listCommands
    if {![info exists widgetOptions]} then {
	Init
    }
    eval Build $w $args
    SetBindings $w
    return $w
}
proc ::combobox::Init {} {
    variable widgetOptions
    variable widgetCommands
    variable scanCommands
    variable listCommands
    variable defaultEntryCursor
    array set widgetOptions [list -background {background          Background} -bd -borderwidth -bg -background -borderwidth {borderWidth         BorderWidth} -command {command Command} -commandstate {commandState        State} -cursor {cursor              Cursor} -editable {editable            Editable} -fg -foreground -font {font                Font} -foreground {foreground          Foreground} -height {height              Height} -highlightbackground\
      {highlightBackground HighlightBackground} -highlightcolor {highlightColor      HighlightColor} -highlightthickness {highlightThickness  HighlightThickness} -image {image               Image} -maxheight {maxHeight           Height} -relief {relief              Relief} -selectbackground {selectBackground    Foreground} -selectborderwidth {selectBorderWidth   BorderWidth} -selectforeground {selectForeground    Background} -state {state               State} -takefocus\
      {takeFocus           TakeFocus} -textvariable {textVariable        Variable} -value {value               Value} -width {width               Width} -xscrollcommand {xScrollCommand      ScrollCommand}]
    set widgetCommands [list bbox cget configure curselection delete get icursor index insert list scan selection xview select toggle open close]
    set listCommands [list delete get index insert size]
    set scanCommands [list mark dragto]
    if {[lsearch -exact [package names] "Tk"] != -1} then {
	if {$::tcl_platform(platform) == "windows"} then {
	    image create bitmap ::combobox::bimage -data {
#define down_arrow_width 12
#define down_arrow_height 12
static char down_arrow_bits[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xfc,0xf1,0xf8,0xf0,0x70,0xf0,0x20,0xf0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00;
}
}
	} else {
	    image create bitmap ::combobox::bimage -data {
#define down_arrow_width 15
#define down_arrow_height 15
static char down_arrow_bits[] = {
0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,
0x00,0x80,0xf8,0x8f,0xf0,0x87,0xe0,0x83,
0xc0,0x81,0x80,0x80,0x00,0x80,0x00,0x80,
0x00,0x80,0x00,0x80,0x00,0x80
}
}
	}
	set tmpWidget ".__tmp__"
	set count 0
	while {[winfo exists $tmpWidget] == 1} {
	    set tmpWidget ".__tmp__$count"
	    incr count
	}
	scrollbar $tmpWidget
	set sb_width [winfo reqwidth $tmpWidget]
	destroy $tmpWidget
	entry $tmpWidget
	foreach foo [$tmpWidget configure] {
	    if {[lindex $foo 0] == "-cursor"} then {
		set defaultEntryCursor [lindex $foo 4]
	    }
	    if {[llength $foo] == 5} then {
		set option [lindex $foo 1]
		set value [lindex $foo 4]
		option add *Combobox.$option $value widgetDefault
		if {[string compare $option "foreground"] == 0 || [string compare $option "background"] == 0 || [string compare $option "font"] == 0} then {
		    option add *Combobox*ComboboxListbox.$option $value widgetDefault
		}
	    }
	}
	destroy $tmpWidget
	option add *Combobox.cursor {}
	option add *Combobox.commandState normal widgetDefault
	option add *Combobox.editable 1 widgetDefault
	option add *Combobox.maxHeight 10 widgetDefault
	option add *Combobox.height 0
    }
    SetClassBindings
}
proc ::combobox::SetClassBindings {} {
    bind Combobox <Destroy> [list ::combobox::DestroyHandler %W]
    set this {[::combobox::convert %W -W]}
    bind Combobox <Any-ButtonPress> "$this close"
    bind Combobox <Any-ButtonRelease> "$this close"
    bind Combobox <FocusIn> {tkTabToWindow [::combobox::convert %W -W].entry}
    bind Combobox <Unmap> {[::combobox::convert %W -W] close}
    return ""
}
proc ::combobox::SetBindings {w} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    bindtags $widgets(entry) [concat $widgets(this) [bindtags $widgets(entry)]]
    bindtags $widgets(button) [concat $widgets(this) [bindtags $widgets(button)]]
    bind $widgets(entry) <Tab> "tkTabToWindow \[tk_focusNext $widgets(entry)\]; break"
    bind $widgets(entry) <Shift-Tab> "tkTabToWindow \[tk_focusPrev $widgets(this)\]; break"
    bind $widgets(button) <ButtonPress-1> [list $widgets(this) toggle]
    bind $widgets(entry) <B1-Enter> "break"
    bind $widgets(listbox) <ButtonRelease-1> "::combobox::Select $widgets(this) \[$widgets(listbox) nearest %y\]; break"
    bind $widgets(vsb) <ButtonPress-1> {continue}
    bind $widgets(vsb) <ButtonRelease-1> {continue}
    bind $widgets(listbox) <Any-Motion> {
	%W selection clear 0 end
	%W activate @%x,%y
	%W selection anchor @%x,%y
	%W selection set @%x,%y @%x,%y
    }
    foreach event [list <Up> <Down> <Tab> <Return> <Escape> <Next> <Prior> <Double-1> <1> <Any-KeyPress> <FocusIn> <FocusOut>] {
	bind $widgets(entry) $event "::combobox::HandleEvent $widgets(this) $event"
    }
}
proc ::combobox::Build {w args} {
    variable widgetOptions
    if {[winfo exists $w]} then {
	error "window name \"$w\" already exists"
    }
    namespace eval ::combobox::$w {
	variable ignoreTrace 0
	variable oldFocus {}
	variable oldGrab {}
	variable oldValue {}
	variable options
	variable this
	variable widgets
	set widgets(foo) foo ;# coerce into an array
	set options(foo) foo ;# coerce into an array
	unset widgets(foo)
	unset options(foo)
    }
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    set widgets(this) [frame $w -class Combobox -takefocus 0]
    set widgets(entry) [entry $w.entry -takefocus 1]
    set widgets(button) [label $w.button -takefocus 0]
    foreach name [array names widgetOptions] {
	if {[llength $widgetOptions($name)] == 1} then continue
	set optName [lindex $widgetOptions($name) 0]
	set optClass [lindex $widgetOptions($name) 1]
	set value [option get $w $optName $optClass]
	set options($name) $value
    }
    if {[info exists options(-value)] && [string length $options(-value)] == 0} then {
	unset options(-value)
    }
    set widgets(frame) ::combobox::${w}::$w
    pack $widgets(entry) -side left -fill both -expand yes
    pack $widgets(button) -side right -fill y -expand no
    array set options $args
    set widgets(popup) [toplevel $w.top]
    set widgets(listbox) [listbox $w.top.list]
    set widgets(vsb) [scrollbar $w.top.vsb]
    pack $widgets(listbox) -side left -fill both -expand y
    $widgets(vsb) configure -command "$widgets(listbox) yview" -highlightthickness 0
    $widgets(button) configure -highlightthickness 0 -borderwidth 1 -relief raised -width [expr {[winfo reqwidth $widgets(vsb)] - 2}]
    $widgets(entry) configure -borderwidth 0 -relief flat -highlightthickness 0
    $widgets(popup) configure -borderwidth 1 -relief sunken
    $widgets(listbox) configure -selectmode browse -background [$widgets(entry) cget -bg] -yscrollcommand "$widgets(vsb) set" -exportselection false -borderwidth 0
    wm overrideredirect $widgets(popup) 1
    wm transient $widgets(popup) [winfo toplevel $w]
    wm group $widgets(popup) [winfo parent $w]
    wm resizable $widgets(popup) 0 0
    wm withdraw $widgets(popup)
    rename ::$w $widgets(frame)
    proc ::$w {command args} "eval ::combobox::WidgetProc $w \$command \$args"
    if {[catch "::combobox::Configure $widgets(this) [array get options]" error]} then {
	catch {destroy $w}
	error $error
    }
    return ""
}
proc ::combobox::HandleEvent {w event} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    upvar ::combobox::${w}::oldValue oldValue
    switch $event {
    "<Any-KeyPress>" {
	    if {$options(-editable)} then {
		$widgets(listbox) see 0
		$widgets(listbox) selection clear 0 end
		$widgets(listbox) selection anchor 0
		$widgets(listbox) activate 0
	    }
	}
    "<FocusIn>" {
	    set oldValue [$widgets(entry) get]
	}
    "<FocusOut>" {
	    if {![winfo ismapped $widgets(popup)]} then {
		set newValue [$widgets(entry) get]
		if {$oldValue != $newValue} then {
		    CallCommand $widgets(this) $newValue
		}
	    }
	}
    "<1>" {
	    set editable [::combobox::GetBoolean $options(-editable)]
	    if {!$editable} then {
		if {[winfo ismapped $widgets(popup)]} then {
		    $widgets(this) close
		    return -code break

		} else {
		    if {$options(-state) != "disabled"} then {
			$widgets(this) open
			return -code break

		    }
		}
	    }
	}
    "<Double-1>" {
	    if {$options(-state) != "disabled"} then {
		$widgets(this) toggle
		return -code break

	    }
	}
    "<Tab>" {
	    if {[winfo ismapped $widgets(popup)]} then {
		::combobox::Find $widgets(this) 0
		return -code break

	    } else {
		::combobox::SetValue $widgets(this) [$widgets(this) get]
	    }
	}
    "<Escape>" {
	    if {[winfo ismapped $widgets(popup)]} then {
		$widgets(this) close
		return -code break

	    }
	}
    "<Return>" {
	    set newValue [$widgets(entry) get]
	    if {$oldValue != $newValue} then {
		CallCommand $widgets(this) $newValue
	    }
	    if {[winfo ismapped $widgets(popup)]} then {
		::combobox::Select $widgets(this) [$widgets(listbox) curselection]
		return -code break

	    }
	}
    "<Next>" {
	    $widgets(listbox) yview scroll 1 pages
	    set index [$widgets(listbox) index @0,0]
	    $widgets(listbox) see $index
	    $widgets(listbox) activate $index
	    $widgets(listbox) selection clear 0 end
	    $widgets(listbox) selection anchor $index
	    $widgets(listbox) selection set $index
	}
    "<Prior>" {
	    $widgets(listbox) yview scroll -1 pages
	    set index [$widgets(listbox) index @0,0]
	    $widgets(listbox) activate $index
	    $widgets(listbox) see $index
	    $widgets(listbox) selection clear 0 end
	    $widgets(listbox) selection anchor $index
	    $widgets(listbox) selection set $index
	}
    "<Down>" {
	    if {[winfo ismapped $widgets(popup)]} then {
		tkListboxUpDown $widgets(listbox) 1
		return -code break

	    } else {
		if {$options(-state) != "disabled"} then {
		    $widgets(this) open
		    return -code break

		}
	    }
	}
    "<Up>" {
	    if {[winfo ismapped $widgets(popup)]} then {
		tkListboxUpDown $widgets(listbox) -1
		return -code break

	    } else {
		if {$options(-state) != "disabled"} then {
		    $widgets(this) open
		    return -code break

		}
	    }
	}
    }
    return ""
}
proc ::combobox::DestroyHandler {w} {
    if {[string compare [winfo class $w] "Combobox"] == 0} then {
	upvar ::combobox::${w}::widgets widgets
	upvar ::combobox::${w}::options options
	namespace delete ::combobox::$w
	rename $w {}
    }
    return ""
}
proc ::combobox::Find {w {exact 0}} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    set pattern [$widgets(entry) get]
    if {[string length $pattern] == 0} then {
	$widgets(listbox) see 0
	$widgets(listbox) selection clear 0 end
	$widgets(listbox) selection anchor 0
	$widgets(listbox) activate 0
	return
    }
    set list [$widgets(listbox) get 0 end]
    set exactMatch -1
    if {$exact} then {
	set exactMatch [lsearch -exact $list $pattern]
    }
    set index -1
    while {$index == -1 && [string length $pattern]} {
	set index [lsearch -glob $list "$pattern*"]
	if {$index == -1} then {
	    regsub {.$} $pattern {} pattern
	}
    }
    set thisItem [lindex $list $index]
    if {$index != -1} then {
	set nextIndex [expr {$index + 1}]
	set nextItem [lindex $list $nextIndex]
	if {[string match $pattern* $nextItem]} then {
	    set marker [string length $pattern]
	    while {$marker <= [string length $pattern]} {
		set a [string index $thisItem $marker]
		set b [string index $nextItem $marker]
		if {[string compare $a $b] == 0} then {
		    append pattern $a
		    incr marker
		} else {
		    break
		}
	    }
	} else {
	    set marker [string length $pattern]
	}
    } else {
	set marker end
	set index 0
    }
    if {$exact && $exactMatch == -1} then {
	$widgets(listbox) selection clear 0 end
	$widgets(listbox) see $index
    } elseif {!$exact} {
	set oldstate [$widgets(entry) cget -state]
	$widgets(entry) configure -state normal
	$widgets(entry) delete 0 end
	$widgets(entry) insert end $thisItem
	$widgets(entry) selection clear
	$widgets(entry) selection range $marker end
	$widgets(listbox) activate $index
	$widgets(listbox) selection clear 0 end
	$widgets(listbox) selection anchor $index
	$widgets(listbox) selection set $index
	$widgets(listbox) see $index
	$widgets(entry) configure -state $oldstate
    }
}
proc ::combobox::Select {w index} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    catch {
	set data [$widgets(listbox) get [lindex $index 0]]
	::combobox::SetValue $widgets(this) $data
	$widgets(listbox) selection clear 0 end
	$widgets(listbox) selection anchor $index
	$widgets(listbox) selection set $index
	$widgets(entry) selection range 0 end
    }
    $widgets(this) close
    return ""
}
proc ::combobox::HandleScrollbar {w {action "unknown"}} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    if {$options(-height) == 0} then {
	set hlimit $options(-maxheight)
    } else {
	set hlimit $options(-height)
    }
    switch $action {
    "grow" {
	    if {$hlimit > 0 && [$widgets(listbox) size] > $hlimit} then {
		pack $widgets(vsb) -side right -fill y -expand n
	    }
	}
    "shrink" {
	    if {$hlimit > 0 && [$widgets(listbox) size] <= $hlimit} then {
		pack forget $widgets(vsb)
	    }
	}
    "crop" {
	    pack $widgets(vsb) -side right -fill y -expand n
	}
    default {
	    if {$hlimit > 0 && [$widgets(listbox) size] > $hlimit} then {
		pack $widgets(vsb) -side right -fill y -expand n
	    } else {
		pack forget $widgets(vsb)
	    }
	}
    }
    return ""
}
proc ::combobox::ComputeGeometry {w} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    if {$options(-height) == 0 && $options(-maxheight) != "0"} then {
	set nitems [$widgets(listbox) size]
	if {$nitems > $options(-maxheight)} then {
	    $widgets(listbox) configure -height $options(-maxheight)
	} else {
	    $widgets(listbox) configure -height 0
	}
	update idletasks
    }
    set bd [$widgets(popup) cget -borderwidth]
    set height [expr {[winfo reqheight $widgets(popup)] + $bd + $bd}]
    set width [winfo width $widgets(this)]
    set screenWidth [winfo screenwidth $widgets(this)]
    set screenHeight [winfo screenheight $widgets(this)]
    set rootx [winfo rootx $widgets(this)]
    set rooty [winfo rooty $widgets(this)]
    set vrootx [winfo vrootx $widgets(this)]
    set vrooty [winfo vrooty $widgets(this)]
    set x [expr {$rootx + $vrootx}]
    if {0} then {
	set rightEdge [expr {$x + $width}]
	if {$rightEdge > $screenWidth} then {
	    set x [expr {$screenWidth - $width}]
	}
	if {$x < 0} then {
	    set x 0
	}
    }
    set y [expr {$rooty + $vrooty + [winfo reqheight $widgets(this)] + 1}]
    set bottomEdge [expr {$y + $height}]
    if {$bottomEdge >= $screenHeight} then {
	set y [expr {($rooty - $height - 1) + $vrooty}]
	if {$y < 0} then {
	    if {$rooty > [expr {$screenHeight / 2}]} then {
		set y 1
		set height [expr {$rooty - 1 - $y}]
	    } else {
		set y [expr {$rooty + $vrooty + [winfo reqheight $widgets(this)] + 1}]
		set height [expr {$screenHeight - $y}]
	    }
	    HandleScrollbar $widgets(this) crop
	}
    }
    if {$y < 0} then {
	set y 0
	set height $screenheight
    }
    set geometry [format "=%dx%d+%d+%d" $width $height $x $y]
    return $geometry
}
proc ::combobox::DoInternalWidgetCommand {w subwidget command args} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    set subcommand $command
    set command [concat $widgets($subwidget) $command $args]
    if {[catch $command result]} then {
	regsub $widgets($subwidget) $result $widgets(this) result
	switch $subwidget,$subcommand {
	listbox,index {
		regsub "index" $result "list index" result
	    }
	listbox,insert {
		regsub "insert" $result "list insert" result
	    }
	listbox,delete {
		regsub "delete" $result "list delete" result
	    }
	listbox,get {
		regsub "get" $result "list get" result
	    }
	listbox,size {
		regsub "size" $result "list size" result
	    }
	}
	error $result
    } else {
	return $result
    }
}
proc ::combobox::WidgetProc {w command args} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    upvar ::combobox::${w}::oldFocus oldFocus
    upvar ::combobox::${w}::oldFocus oldGrab
    set command [::combobox::Canonize $w command $command]
    set doWidgetCommand [list ::combobox::DoInternalWidgetCommand $widgets(this)]
    if {$command == "list"} then {
	set command "list-[lindex $args 0]"
	set args [lrange $args 1 end]
    }
    set result ""
    switch $command {
    bbox -
    delete -
    get -
    icursor -
    index -
    insert -
    scan -
    selection -
    xview {
	    set result [eval $doWidgetCommand entry $command $args]
	}
    list-get {
	    set result [eval $doWidgetCommand listbox get $args]
	}
    list-index {
	    set result [eval $doWidgetCommand listbox index $args]
	}
    list-size {
	    set result [eval $doWidgetCommand listbox size $args]
	}
    select {
	    if {[llength $args] == 1} then {
		set index [lindex $args 0]
		set result [Select $widgets(this) $index]
	    } else {
		error "usage: $w select index"
	    }
	}
    subwidget {
	    set knownWidgets [list button entry listbox popup vsb]
	    if {[llength $args] == 0} then {
		return $knownWidgets
	    }
	    set name [lindex $args 0]
	    if {[lsearch $knownWidgets $name] != -1} then {
		set result $widgets($name)
	    } else {
		error "unknown subwidget $name"
	    }
	}
    curselection {
	    set result [eval $doWidgetCommand listbox curselection]
	}
    list-insert {
	    eval $doWidgetCommand listbox insert $args
	    set result [HandleScrollbar $w "grow"]
	}
    list-delete {
	    eval $doWidgetCommand listbox delete $args
	    set result [HandleScrollbar $w "shrink"]
	}
    toggle {
	    if {$options(-state) == "disabled"} then return
	    if {[winfo ismapped $widgets(popup)]} then {
		set result [$widgets(this) close]
	    } else {
		set result [$widgets(this) open]
	    }
	}
    open {
	    if {$options(-editable)} then {
		focus $widgets(entry)
		$widgets(entry) select range 0 end
		$widgets(entry) icur end
	    }
	    if {$options(-state) == "disabled"} then {
		return 0
	    }
	    set geometry [::combobox::ComputeGeometry $widgets(this)]
	    wm geometry $widgets(popup) $geometry
	    update idletasks
	    if {[winfo ismapped $widgets(popup)]} then {
		return 0
	    }
	    set oldFocus [focus]
	    $widgets(button) configure -relief sunken
	    raise $widgets(popup) [winfo parent $widgets(this)]
	    wm deiconify $widgets(popup)
	    focus -force $widgets(entry)
	    ::combobox::Find $widgets(this) 1
	    set status "none"
	    set grab [grab current $widgets(this)]
	    if {$grab != ""} then {
		set status [grab status $grab]
	    }
	    set oldGrab [list $grab $status]
	    unset grab status
	    grab -global $widgets(this)
	    event generate $widgets(listbox) <B1-Enter>
	    return 1
	}
    close {
	    if {![winfo ismapped $widgets(popup)]} then {
		return 0
	    }
	    catch {focus $oldFocus} result
	    catch {grab release $widgets(this)}
	    catch {
		set status [lindex $oldGrab 1]
		if {$status == "global"} then {
		    grab -global [lindex $oldGrab 0]
		} elseif {$status == "local"} {
		    grab [lindex $oldGrab 0]
		}
		unset status
	    }
	    $widgets(button) configure -relief raised
	    wm withdraw $widgets(popup)
	    set editable [::combobox::GetBoolean $options(-editable)]
	    if {$editable} then {
		$widgets(entry) selection range 0 end
		$widgets(button) configure -relief raised
	    }
	    tkCancelRepeat
	    return 1
	}
    cget {
	    if {[llength $args] != 1} then {
		error "wrong # args: should be $w cget option"
	    }
	    set opt [::combobox::Canonize $w option [lindex $args 0]]
	    if {$opt == "-value"} then {
		set result [$widget(entry) get]
	    } else {
		set result $options($opt)
	    }
	}
    configure {
	    set result [eval ::combobox::Configure {$w} $args]
	}
    default {
	    error "bad option \"$command\""
	}
    }
    return $result
}
proc ::combobox::Configure {w args} {
    variable widgetOptions
    variable defaultEntryCursor
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    if {[llength $args] == 0} then {
	set results {}
	foreach opt [lsort [array names widgetOptions]] {
	    if {[llength $widgetOptions($opt)] == 1} then {
		set alias $widgetOptions($opt)
		set optName $widgetOptions($alias)
		lappend results [list $opt $optName]
	    } else {
		set optName [lindex $widgetOptions($opt) 0]
		set optClass [lindex $widgetOptions($opt) 1]
		set default [option get $w $optName $optClass]
		lappend results [list $opt $optName $optClass $default $options($opt)]
	    }
	}
	return $results
    }
    if {[llength $args] == 1} then {
	set opt [::combobox::Canonize $w option [lindex $args 0]]
	set optName [lindex $widgetOptions($opt) 0]
	set optClass [lindex $widgetOptions($opt) 1]
	set default [option get $w $optName $optClass]
	set results [list $opt $optName $optClass $default $options($opt)]
	return $results
    }
    if {[expr {[llength $args]%2}] == 1} then {
	error "value for \"[lindex $args end]\" missing"
    }
    foreach {name value} $args {
	set name [::combobox::Canonize $w option $name]
	set opts($name) $value
    }
    foreach option [array names opts] {
	set newValue $opts($option)
	if {[info exists options($option)]} then {
	    set oldValue $options($option)
	}
	switch -- $option {
	-background {
		$widgets(frame) configure -background $newValue
		$widgets(entry) configure -background $newValue
		$widgets(listbox) configure -background $newValue
		$widgets(vsb) configure -background $newValue
		$widgets(vsb) configure -troughcolor $newValue
		set options($option) $newValue
	    }
	-borderwidth {
		$widgets(frame) configure -borderwidth $newValue
		set options($option) $newValue
	    }
	-command {
		set options($option) $newValue
	    }
	-commandstate {
		if {$newValue != "normal" && $newValue != "disabled"} then {
		    set options($option) $oldValue
		    set message "bad state value \"$newValue\";"
		    append message " must be normal or disabled"
		    error $message
		}
		set options($option) $newValue
	    }
	-cursor {
		$widgets(frame) configure -cursor $newValue
		$widgets(entry) configure -cursor $newValue
		$widgets(listbox) configure -cursor $newValue
		set options($option) $newValue
	    }
	-editable {
		if {$newValue} then {
		    $widgets(entry) configure -state normal -cursor $defaultEntryCursor
		} else {
		    $widgets(entry) configure -state disabled -cursor $options(-cursor)
		}
		set options($option) $newValue
	    }
	-font {
		$widgets(entry) configure -font $newValue
		$widgets(listbox) configure -font $newValue
		set options($option) $newValue
	    }
	-foreground {
		$widgets(entry) configure -foreground $newValue
		$widgets(button) configure -foreground $newValue
		$widgets(listbox) configure -foreground $newValue
		set options($option) $newValue
	    }
	-height {
		$widgets(listbox) configure -height $newValue
		HandleScrollbar $w
		set options($option) $newValue
	    }
	-highlightbackground {
		$widgets(frame) configure -highlightbackground $newValue
		set options($option) $newValue
	    }
	-highlightcolor {
		$widgets(frame) configure -highlightcolor $newValue
		set options($option) $newValue
	    }
	-highlightthickness {
		$widgets(frame) configure -highlightthickness $newValue
		set options($option) $newValue
	    }
	-image {
		if {[string length $newValue] > 0} then {
		    $widgets(button) configure -image $newValue
		} else {
		    $widgets(button) configure -image ::combobox::bimage
		}
		set options($option) $newValue
	    }
	-maxheight {
		$widgets(listbox) configure -height $options(-height)
		HandleScrollbar $w
		set options($option) $newValue
	    }
	-relief {
		$widgets(frame) configure -relief $newValue
		set options($option) $newValue
	    }
	-selectbackground {
		$widgets(entry) configure -selectbackground $newValue
		$widgets(listbox) configure -selectbackground $newValue
		set options($option) $newValue
	    }
	-selectborderwidth {
		$widgets(entry) configure -selectborderwidth $newValue
		$widgets(listbox) configure -selectborderwidth $newValue
		set options($option) $newValue
	    }
	-selectforeground {
		$widgets(entry) configure -selectforeground $newValue
		$widgets(listbox) configure -selectforeground $newValue
		set options($option) $newValue
	    }
	-state {
		if {$newValue == "normal"} then {
		    set editable [::combobox::GetBoolean $options(-editable)]
		    if {$editable} then {
			$widgets(entry) configure -state normal
			$widgets(entry) configure -takefocus 1
		    }
		} elseif {$newValue == "disabled"} {
		    $widgets(entry) configure -state disabled
		    $widgets(entry) configure -takefocus 0
		} else {
		    set options($option) $oldValue
		    set message "bad state value \"$newValue\";"
		    append message " must be normal or disabled"
		    error $message
		}
		set options($option) $newValue
	    }
	-takefocus {
		$widgets(entry) configure -takefocus $newValue
		set options($option) $newValue
	    }
	-textvariable {
		$widgets(entry) configure -textvariable $newValue
		set options($option) $newValue
	    }
	-value {
		::combobox::SetValue $widgets(this) $newValue
		set options($option) $newValue
	    }
	-width {
		$widgets(entry) configure -width $newValue
		$widgets(listbox) configure -width $newValue
		set options($option) $newValue
	    }
	-xscrollcommand {
		$widgets(entry) configure -xscrollcommand $newValue
		set options($option) $newValue
	    }
	}
    }
}
proc ::combobox::VTrace {w args} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    upvar ::combobox::${w}::ignoreTrace ignoreTrace
    if {[info exists ignoreTrace]} then return
    ::combobox::SetValue $widgets(this) [set ::$options(-textvariable)]
    return ""
}
proc ::combobox::SetValue {w newValue} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    upvar ::combobox::${w}::ignoreTrace ignoreTrace
    upvar ::combobox::${w}::oldValue oldValue
    if {[info exists options(-textvariable)] && [string length $options(-textvariable)] > 0} then {
	set variable ::$options(-textvariable)
	set $variable $newValue
    } else {
	set oldstate [$widgets(entry) cget -state]
	$widgets(entry) configure -state normal
	$widgets(entry) delete 0 end
	$widgets(entry) insert 0 $newValue
	$widgets(entry) configure -state $oldstate
    }
    set oldValue $newValue
    CallCommand $w $newValue
    return ""
}
proc ::combobox::CallCommand {w newValue} {
    upvar ::combobox::${w}::widgets widgets
    upvar ::combobox::${w}::options options
    if {$options(-commandstate) == "normal" && [string length $options(-command)] > 0} then {
	set args [list $widgets(this) $newValue]
	uplevel \#0 $options(-command) $args
    }
}
proc ::combobox::GetBoolean {value {errorValue 1}} {
    if {[catch {expr {([string trim $value]) ?1:0}} res]} then {
	return $errorValue
    } else {
	return $res
    }
}
proc ::combobox::convert {w args} {
    set result {}
    if {![winfo exists $w]} then {
	error "window \"$w\" doesn't exist"
    }
    while {[llength $args] > 0} {
	set option [lindex $args 0]
	set args [lrange $args 1 end]
	switch -exact -- $option {
	-x {
		set value [lindex $args 0]
		set args [lrange $args 1 end]
		set win $w
		while {[winfo class $win] != "Combobox"} {
		    incr value [winfo x $win]
		    set win [winfo parent $win]
		    if {$win == "."} then break
		}
		lappend result $value
	    }
	-y {
		set value [lindex $args 0]
		set args [lrange $args 1 end]
		set win $w
		while {[winfo class $win] != "Combobox"} {
		    incr value [winfo y $win]
		    set win [winfo parent $win]
		    if {$win == "."} then break
		}
		lappend result $value
	    }
	-w -
	-W {
		set win $w
		while {[winfo class $win] != "Combobox"} {
		    set win [winfo parent $win]
		    if {$win == "."} then break

		}
		lappend result $win
	    }
	}
    }
    return $result
}
proc ::combobox::Canonize {w object opt} {
    variable widgetOptions
    variable columnOptions
    variable widgetCommands
    variable listCommands
    variable scanCommands
    switch $object {
    command {
	    if {[lsearch -exact $widgetCommands $opt] >= 0} then {
		return $opt
	    }
	    set list $widgetCommands
	    foreach element $list {
		set tmp($element) ""
	    }
	    set matches [array names tmp ${opt}*]
	}
    {list command} {
	    if {[lsearch -exact $listCommands $opt] >= 0} then {
		return $opt
	    }
	    set list $listCommands
	    foreach element $list {
		set tmp($element) ""
	    }
	    set matches [array names tmp ${opt}*]
	}
    {scan command} {
	    if {[lsearch -exact $scanCommands $opt] >= 0} then {
		return $opt
	    }
	    set list $scanCommands
	    foreach element $list {
		set tmp($element) ""
	    }
	    set matches [array names tmp ${opt}*]
	}
    option {
	    if {[info exists widgetOptions($opt)] && [llength $widgetOptions($opt)] == 2} then {
		return $opt
	    }
	    set list [array names widgetOptions]
	    set matches [array names widgetOptions ${opt}*]
	}
    }
    if {[llength $matches] == 0} then {
	set choices [HumanizeList $list]
	error "unknown $object \"$opt\"; must be one of $choices"
    } elseif {[llength $matches] == 1} {
	set opt [lindex $matches 0]
	switch $object {
	option {
		set opt [lindex $matches 0]
		if {[llength $widgetOptions($opt)] == 1} then {
		    set opt $widgetOptions($opt)
		}
	    }
	}
	return $opt
    } else {
	set choices [HumanizeList $list]
	error "ambiguous $object \"$opt\"; must be one of $choices"
    }
}
proc ::combobox::HumanizeList {list} {
    if {[llength $list] == 1} then {
	return [lindex $list 0]
    } else {
	set list [lsort $list]
	set secondToLast [expr {[llength $list] -2}]
	set most [lrange $list 0 $secondToLast]
	set last [lindex $list end]
	return "[join $most {, }] or $last"
    }
}
package provide #dbglog
namespace eval ::#dbglog {
    namespace export #dbgCtrl
    namespace export #dbgBeginSrc
    namespace export #dbgEndSrc
    namespace export #dbgBeginProc
    namespace export #dbgEndProc
    namespace export #dbgShowVar
    namespace export #dbgShowInfo
    namespace export #dbgShowWarning
    namespace export #dbgShowError
    namespace export debug_log
}
global ::#dbglog::widget
set ::#dbglog::widget(top) ""
global ::#dbglog::state
set ::#dbglog::state(debugging) off
set ::#dbglog::state(tagCnt) 0
set ::#dbglog::state(indentSpc) ""
set ::#dbglog::state(lineCnt) 1
proc ::#dbglog::#dbgBeginSrc {name} {
    DbgLogColor "\[Source in\] $name" black i+
}
proc ::#dbglog::#dbgEndSrc {name} {
    DbgLogColor "\[Source out\] $name" black i-
}
proc ::#dbglog::#dbgBeginProc {name} {
    DbgLogColor "\[Proc in\] $name" brown i+
}
proc ::#dbglog::#dbgEndProc {name} {
    DbgLogColor "\[Proc out\] $name" brown i-
}
proc ::#dbglog::#dbgShowVar {name} {
    DbgLogColor "\[Variable\] $name" blue i
}
proc ::#dbglog::#dbgShowInfo {name} {
    DbgLogColor "\[Info\] $name" "dark green" i
}
proc ::#dbglog::#dbgShowWarning {name} {
    DbgLogColor "\[Warning!\] $name" orange i
}
proc ::#dbglog::#dbgShowError {name} {
    DbgLogColor "\[Error!\] $name" red i
}
proc ::#dbglog::debug_log {message} {
    global ::#dbglog::widget
    global ::#dbglog::state
    if {$state(debugging) == "on"} then {
	$widget(teDbgLog) configure -state normal
	$widget(teDbgLog) insert end "$message\n"
	$widget(teDbgLog) see end
	$widget(teDbgLog) configure -state disable
    }
}
proc ::#dbglog::DbgLogColor {message color indent} {
    global ::#dbglog::widget
    global ::#dbglog::state
    if {$state(debugging) == "on"} then {
	$widget(teDbgLog) configure -state normal
	if {$indent == "i+"} then {
	    set state(indentSpc) [append state(indentSpc) "  "]
	}
	set msg $state(indentSpc)
	set msg [append msg $message]
	$widget(teDbgLog) insert end $msg\n t$state(tagCnt)
	$widget(teDbgLog) tag configure t$state(tagCnt) -foreground $color -background wheat
	$widget(teDbgLog) see end
	incr state(tagCnt) 1
	incr state(lineCnt) 1
	if {$indent == "i-"} then {
	    set state(indentSpc) [string range $state(indentSpc) 2 [string length $state(indentSpc)]]
	}
	$widget(teDbgLog) configure -state disable
    }
}
proc ::#dbglog::#dbgCtrl {on_or_off {message ""}} {
    global ::#dbglog::widget
    global ::#dbglog::state
    if {$state(debugging) != $on_or_off} then {
	if {$on_or_off == "on"} then {
	    if {[winfo exists $widget(top)] == 0} then {
		WindowCreate
	    } else {
		wm deiconify $widget(top)
	    }
	} else {
	    wm withdraw $widget(top)
	}
	set state(debugging) $on_or_off
    }
    if {$message != ""} then {
	set date [clock format [clock seconds] -format %c -gmt true]
	debug_log "$message $date"
	debug_log " "
	set state(lineCnt) [expr $state(lineCnt) + 2]
    }
}
proc ::#dbglog::WindowCreate {} {
    global ::#dbglog::widget
    set widget(top) [toplevel .debug]
    wm title $widget(top) "Debug log"
    wm protocol $widget(top) WM_DELETE_WINDOW "wm withdraw $widget(top)"
    set mnTop [menu .debug_top_menu -tearoff 0]
    set mnFile [menu $mnTop.file -tearoff 0]
    $mnTop add cascade -label "File" -menu $mnFile -underline 0
    $mnFile add command -label "Save" -underline 0 -command ::#dbglog::SaveLog
    set mnEdit [menu $mnTop.edit -tearoff 0]
    $mnTop add cascade -label Edit -menu $mnEdit -underline 0
    $mnEdit add command -label Clear -underline 0 -command ::#dbglog::ClearLog
    $mnEdit add command -label Search -underline 0 -command ::#dbglog::SearchLog
    $widget(top) configure -menu $mnTop
    set widget(frDbgLog) [frame $widget(top).fr_#dbglog]
    set widget(teDbgLog) [text $widget(frDbgLog).te_log -setgrid true -wrap word -state disable -xscrollcommand [list $widget(frDbgLog).xscroll set] -yscrollcommand [list $widget(frDbgLog).yscroll set]]
    scrollbar $widget(frDbgLog).xscroll -orient horizontal -command [list $widget(teDbgLog) xview]
    scrollbar $widget(frDbgLog).yscroll -orient vertical -command [list $widget(teDbgLog) yview]
    pack $widget(frDbgLog).yscroll -side right -fill y
    pack $widget(frDbgLog).xscroll -side bottom -fill x
    pack $widget(teDbgLog) -expand true -fill both
    pack $widget(frDbgLog) -side top -fill both -expand true
    set chDbgOnOff [checkbutton $widget(top).ch_#dbg_onoff -text "Debug On" -variable ::#dbglog::state(debugging) -onvalue "on" -offvalue "off"]
    pack $chDbgOnOff -anchor w
    return
}
proc ::#dbglog::SaveLog {} {
    global ::#dbglog::widget
    set filename [tk_getSaveFile -title "Save debug events" -defaultextension ".txt" -filetypes {{{Log files} {.txt}}}]
    if {$filename != ""} then {
	if [catch {open $filename w} fileId] then {
	    tk_messageBox -message "Cannot open $filename" -icon error -type ok
	} else {
	    puts $fileId [$widget(teDbgLog) get 1.0 end]
	    close $fileId
	}
    }
}
proc ::#dbglog::ClearLog {} {
    global ::#dbglog::widget
    $widget(teDbgLog) configure -state normal
    $widget(teDbgLog) delete 3.0 end
    $widget(teDbgLog) insert end "\n"
    $widget(teDbgLog) configure -state disable
    return
}
proc ::#dbglog::SearchLog {} {
    global ::#dbglog::widget
    global ::#dbglog::pattern
    global ::#dbglog::searchDir
    global ::#dbglog::hilitOn
    set tpSearch [toplevel .#dbglog_search]
    wm title $tpSearch "Search"
    wm protocol $tpSearch WM_DELETE_WINDOW "destroy $tpSearch"
    wm resizable $tpSearch 0 0
    set frSearch [frame $tpSearch.fr_seach]
    set laString [label $frSearch.la_string -text "Search:"]
    set enString [entry $frSearch.en_string -width 32 -textvariable ::#dbglog::pattern]
    pack $laString $enString -padx 5 -pady 10 -side left
    pack $frSearch
    set widget(EnString) $enString
    bind $widget(EnString) <Return> {FindLog}
    set frDir [frame $tpSearch.fr_dir -relief groove -borderwidth 2]
    set laDir [label $frDir.la -text "Direction"]
    set frRaDir [frame $frDir.fr_radir]
    radiobutton $frRaDir.f -text "Up" -variable ::#dbglog::searchDir -value backwards
    radiobutton $frRaDir.b -text "Down" -variable ::#dbglog::searchDir -value forward
    set searchDir forward
    pack $frRaDir.f $frRaDir.b -side left
    pack $laDir $frRaDir -anchor w
    set frBu [frame $tpSearch.bu]
    set buFind [button $frBu.bu_find -text "Next" -command {FindLog}]
    set buCancel [button $frBu.bu_cancel -text "Cancel" -command {set Cancel 1}]
    pack $buFind $buCancel -padx 5 -pady 10 -fill x
    pack $frDir -anchor w -padx 5 -side left -fill x -expand true
    pack $frBu -anchor e -padx 5 -side left -fill x -expand true
    focus $enString
    set hilitOn 0
    tkwait variable Cancel
    destroy $tpSearch
    return
}
proc FindLog {} {
    global ::#dbglog::widget
    global ::#dbglog::pattern
    global ::#dbglog::searchDir
    global ::#dbglog::hilitOn
    global ::#dbglog::searchLine
    if {$hilitOn == 1} then {
	set FgColor [$widget(teDbgLog) tag cget $widget(tagHilit) -foreground]
	set BgColor [$widget(teDbgLog) tag cget $widget(tagHilit) -background]
	$widget(teDbgLog) tag configure $widget(tagHilit) -foreground $BgColor -background $FgColor
	set hilitOn 0
	if {$searchDir == "forward"} then {
	    incr searchLine
	}
    } else {
	set searchLine 1
    }
    set OccurenceIdx [$widget(teDbgLog) search -$searchDir $pattern ${searchLine}.0]
    if {$OccurenceIdx == ""} then {
	tk_messageBox -title "Debug Log" -icon info -type ok -message "Cannot find $pattern"
	focus $widget(EnString)
    } else {
	set searchLine [string range $OccurenceIdx 0 [expr [string last "." $OccurenceIdx] -1]]
	set widget(tagHilit) [$widget(teDbgLog) tag names ${searchLine}.0]
	set FgColor [$widget(teDbgLog) tag cget $widget(tagHilit) -foreground]
	set BgColor [$widget(teDbgLog) tag cget $widget(tagHilit) -background]
	$widget(teDbgLog) tag configure $widget(tagHilit) -foreground $BgColor -background $FgColor
	$widget(teDbgLog) see $OccurenceIdx
	set hilitOn 1
	focus $widget(teDbgLog)
    }
    return
}
catch {namespace import combobox::*}
proc fontchoose {} {
    global ::but_stat
    destroy .top_fc
    set ::size 12
    set ::family [lindex [lsort [font families]] 0]
    set ::slant roman
    set ::weight normal
    set ::overstrike 0
    set ::underline 0
    toplevel .top_fc
    wm title .top_fc "Font Chooser"
    if {[lsearch [font names] "defaultFont"] == -1} then {
	setSystemFonts
    }
    set fp [frame .top_fc.fontpicker]
    set msg [label .top_fc.msg -borderwidth 2 -relief groove -width 30 -height 4]
    pack $fp -side top -fill x
    pack $msg -side top -fill both -expand y -ipady 20
    $msg configure -text [join [list "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz" "0123456789~`!@#$%^&*()_-+=" "{}[]:;\"'<>,.?/"] "\n"]
    changeFont $msg
    label $fp.famLabel -text "Font Family:" -font defaultFont
    combobox $fp.famCombo -textvariable family -editable false -highlightthickness 1 -command [list changeFont $msg] -font defaultFont
    pack $fp.famLabel -side left
    pack $fp.famCombo -side left -fill x -expand y
    set widest 0
    foreach family [lsort [font families]] {
	if {[set length [string length $family]] > $widest} then {
	    set widest $length
	}
	$fp.famCombo list insert end $family
    }
    $fp.famCombo configure -width $widest
    label $fp.sizeLabel -text "Font Size:" -font defaultFont
    combobox $fp.sizeCombo -highlightthickness 1 -maxheight 0 -width 3 -textvariable size -editable true -command [list changeFont $msg] -font defaultFont
    pack $fp.sizeLabel -side left
    pack $fp.sizeCombo -side left
    eval $fp.sizeCombo list insert end [list 8 9 10 12 14 16 18 20 24 28 32 36]
    frame $fp.dummy -width 5
    pack $fp.dummy -side left
    set bold "bold"
    checkbutton $fp.bold -variable weight -indicatoron false -onvalue bold -offvalue normal -text "B" -width 2 -height 1 -font defaultFontb -command [list changeFont $msg]
    pack $fp.bold -side left
    checkbutton $fp.underline -variable underline -indicatoron false -onvalue 1 -offvalue 0 -text "U" -width 2 -height 1 -font defaultFontu -highlightthickness 1 -padx 0 -pady 0 -borderwidth 1 -command [list changeFont $msg]
    pack $fp.underline -side left
    checkbutton $fp.italic -variable slant -indicatoron false -onvalue italic -offvalue roman -text "I" -width 2 -height 1 -font defaultFonti -highlightthickness 1 -padx 0 -pady 0 -borderwidth 1 -command [list changeFont $msg]
    pack $fp.italic -side left
    checkbutton $fp.overstrike -variable overstrike -indicatoron false -onvalue 1 -offvalue 0 -text "O" -width 2 -height 1 -font defaultFonto -highlightthickness 1 -padx 0 -pady 0 -borderwidth 1 -command [list changeFont $msg]
    pack $fp.overstrike -side left
    set but_cancel [button .top_fc.but_cancel -text "Cancel" -command {set ::but_stat "cancel"}]
    set but_ok [button .top_fc.but_ok -text "OK" -command {set ::but_stat "ok"}]
    pack $but_cancel $but_ok -side right -padx 10
    catch {focus $fp.famCombo}
    tkwait variable ::but_stat
    if {$::but_stat == "ok"} then {
	set ::fontspec [list -family $::family -size $::size -weight $::weight -underline $::underline -slant $::slant -overstrike $::overstrike]
    } else {
	set ::fontspec {}
    }
    destroy .top_fc
    return $::fontspec
}
proc ::changeFont {w args} {
    foreach foo [list family size weight underline slant overstrike] {
	if {[set ::$foo] == ""} then {
	    return
	}
    }
    set ::fontspec [list -family $::family -size $::size -weight $::weight -underline $::underline -slant $::slant -overstrike $::overstrike]
    $w configure -font $::fontspec
}
package provide htmlview
namespace eval ::htmlview {
    namespace export htmlView
}
global exeDir
if {[info command html]==""} then {
    foreach f {./tkhtml.so /usr/lib/tkhtml.so /usr/local/lib/tkhtml.so ./tkhtml.dll} {
	if {[file exists $f]} then {
	    if {[catch {load $f Tkhtml}]==0} then break
	}
    }
}
image create photo ::htmlview::biggray -data {
R0lGODdhPAA+APAAALi4uAAAACwAAAAAPAA+AAACQISPqcvtD6OctNqLs968+w+G4kiW5omm
6sq27gvH8kzX9o3n+s73/g8MCofEovGITCqXzKbzCY1Kp9Sq9YrNFgsAO///
}
image create photo ::htmlview::smgray -data {
R0lGODdhOAAYAPAAALi4uAAAACwAAAAAOAAYAAACI4SPqcvtD6OctNqLs968+w+G4kiW5omm
6sq27gvH8kzX9m0VADv/
}
image create photo ::htmlview::nogifbig -data {
R0lGODdhJAAkAPEAAACQkADQ0PgAAAAAACwAAAAAJAAkAAACmISPqcsQD6OcdJqKM71PeK15
AsSJH0iZY1CqqKSurfsGsex08XuTuU7L9HywHWZILAaVJssvgoREk5PolFo1XrHZ29IZ8oo0
HKEYVDYbyc/jFhz2otvdcyZdF68qeKh2DZd3AtS0QWcDSDgWKJXY+MXS9qY4+JA2+Vho+YPp
FzSjiTIEWslDQ1rDhPOY2sXVOgeb2kBbu1AAADv/
}
image create photo ::htmlview::nogifsm -data {
R0lGODdhEAAQAPEAAACQkADQ0PgAAAAAACwAAAAAEAAQAAACNISPacHtD4IQz80QJ60as25d
3idKZdR0IIOm2ta0Lhw/Lz2S1JqvK8ozbTKlEIVYceWSjwIAO///
}
proc ::htmlview::htmlView {Title htmlFile} {
    global topHtml wHtml frHtml frHtmlHsb
    if {[winfo exists .top_html]} then {
	wm deiconify .top_html
	return
    }
    set topHtml [toplevel .top_html]
    wm title $topHtml $Title
    wm protocol $topHtml WM_DELETE_WINDOW {destroy .top_html}
    focus $topHtml
    set frHtml [frame $topHtml.fr_html]
    set wHtml $frHtml.h
    html $frHtml.h -yscrollcommand {$frHtml.vsb set} -xscrollcommand {$frHtmlHsb.hsb set} -padx 5 -pady 9 -formcommand FormCmd -imagecommand ImageCmd -scriptcommand ScriptCmd -appletcommand AppletCmd -underlinehyperlinks 1 -bg white -tablerelief raised
    pack $frHtml.h -side left -fill both -expand 1
    scrollbar $frHtml.vsb -orient vertical -command {$wHtml yview}
    pack $frHtml.vsb -side left -fill y
    set frHtmlHsb [frame $topHtml.fr_html_hsb]
    frame $frHtmlHsb.sp -width [winfo reqwidth $frHtml.vsb] -bd 2 -relief raised
    scrollbar $frHtmlHsb.hsb -orient horizontal -command {$wHtml xview}
    pack $frHtml -side top -fill both -expand 1
    pack $frHtmlHsb -side top -fill x
    pack $frHtmlHsb.sp -side right -fill y
    pack $frHtmlHsb.hsb -side top -fill x
    bind $wHtml.x <1> {HrefBinding %x %y}
    bind HtmlClip <Motion> {
	set parent [winfo parent %W]
	set url [$parent href %x %y]
	if {[string length $url] > 0} then {
	    $parent configure -cursor hand2
	} else {
	    $parent configure -cursor {}
	}
    }
    LoadFile $htmlFile
}
proc pickFont {size attrs} {
    puts "FontCmd: $size $attrs"
    set a [expr {-1<[lsearch $attrs fixed]?{courier}:{charter}}]
    set b [expr {-1<[lsearch $attrs italic]?{italic}:{roman}}]
    set c [expr {-1<[lsearch $attrs bold]?{bold}:{normal}}]
    set d [expr {int(12*pow(1.2,$size-4))}]
    list $a $d $b $c
}
proc FormCmd {n cmd args} {
    #dbgShowInfo "FormCmd: $n $cmd $args"
    switch $cmd {
    select -
    textarea -
    input {
	    set w [lindex $args 0]
	    label $w -image nogifsm
	}
    }
}
proc ImageCmd {args} {
    global OldImages Images
    set fn [lindex $args 0]
    if {[info exists OldImages($fn)]} then {
	set Images($fn) $OldImages($fn)
	unset OldImages($fn)
	return $Images($fn)
    }
    if {[catch {image create photo -file $fn} img]} then {
	return smgray
    }
    if {[image width $img]*[image height $img]>20000} then {
	global BigImages
	set b [image create photo -width [image width $img] -height [image height $img]]
	set BigImages($b) $img
	set img $b
	after idle "MoveBigImage $b"
    }
    set Images($fn) $img
    return $img
}
proc MoveBigImage {b} {
    global BigImages
    if {![info exists BigImages($b)]} then {
	return
    }
    $b copy $BigImages($b)
    image delete $BigImages($b)
    unset BigImages($b)
    update
}
proc ScriptCmd {args} {
    #dbgShowInfo "ScriptCmd: $args"
}
proc AppletCmd {w arglist} {
    #dbgShowInfo "AppletCmd: w=$w arglist=$arglist"
    label $w -text "The Applet $w" -bd 2 -relief raised
}
proc HrefBinding {x y} {
    global wHtml
    global LastFile
    set NewHref [$wHtml href $x $y]
    #dbgShowInfo "New HRef: $NewHref"
    if {$NewHref != ""} then {
	set pattern ${LastFile}#
	#dbgShowVar "File pattern: $pattern"
	set len [string length $pattern]
	incr len -1
	#dbgShowVar [string range $NewHref 0 $len]
	if {[string range $NewHref 0 $len]==$pattern} then {
	    incr len
	    $wHtml yview [string range $NewHref $len end]
	} else {
	    LoadFile $NewHref
	}
    }
}
proc ReadFile {filename} {
    global topHtml
    if {[catch {open $filename r} fp]} then {
	tk_messageBox -icon error -message $fp -type ok
	focus $topHtml
	return {}
    } else {
	fconfigure $fp -translation binary
	set r [read $fp [file size $filename]]
	close $fp
	return $r
    }
}
proc LoadFile {filename} {
    global wHtml
    global LastFile
    set html [ReadFile $filename]
    if {$html==""} then return
    set LastFile $filename
    Clear
    $wHtml config -base $filename
    $wHtml parse $html
    ClearOldImages
}
proc Refresh {args} {
    global LastFile
    if {![info exists LastFile]} then return
    LoadFile $LastFile
}
proc Clear {} {
    global wHtml
    global Images OldImages hotkey
    if {[winfo exists .fs.h]} then {
	set w .fs.h
    } else {
	set w $wHtml
    }
    $w clear
    catch {unset hotkey}
    ClearBigImages
    ClearOldImages
    foreach fn [array names Images] {
	set OldImages($fn) $Images($fn)
    }
    catch {unset Images}
}
proc ClearOldImages {} {
    global OldImages
    foreach fn [array names OldImages] {
	image delete $OldImages($fn)
    }
    catch {unset OldImages}
}
proc ClearBigImages {} {
    global BigImages
    foreach b [array names BigImages] {
	image delete $BigImages($b)
    }
    catch {unset BigImages}
}
package provide libtcl
namespace eval ::libtcl {
    namespace export parseOptions
    namespace export randomInit randomRange
}
proc ::libtcl::parseOptions {w specs argList} {
    upvar #0 $w data
    foreach spec $specs {
	if {[llength $spec] != 2} then {
	    error "\"spec\" should contain 2 elements"
	}
	set cmdsw [lindex $spec 0]
	set cmd($cmdsw) ""
	set def($cmdsw) [lindex $spec 1]
    }
    if {[llength $argList] & 1} then {
	set cmdsw [lindex $argList end]
	if {![info exists cmd($cmdsw)]} then {
	    error "bad option \"$cmdsw\": must be [listValidOptions cmd]"
	}
	error "value for \"$cmdsw\" missing"
    }
    foreach cmdsw [array names cmd] {
	set data($cmdsw) $def($cmdsw)
    }
    foreach {cmdsw value} $argList {
	if {![info exists cmd($cmdsw)]} then {
	    error "bad option \"$cmdsw\": must be [listValidOptions cmd]"
	}
	set data($cmdsw) $value
    }
}
proc ::libtcl::listValidOptions {v} {
    upvar $v cmd
    set len [llength [array names cmd]]
    set i 1
    set separator ""
    set errormsg ""
    foreach cmdsw [lsort [array names cmd]] {
	append errormsg "$separator$cmdsw"
	incr i
	if {$i == $len} then {
	    set separator ", or "
	} else {
	    set separator ", "
	}
    }
    return $errormsg
}
proc ::libtcl::randomInit {seed} {
    global rand
    set rand(ia) 9301
    set rand(ic) 49297
    set rand(im) 233280
    set rand(seed) $seed
    return
}
proc ::libtcl::randomCompute {} {
    global rand
    set rand(seed) [expr ($rand(seed)*$rand(ia) + $rand(ic)) % $rand(im)]
    return [expr $rand(seed)/double($rand(im))]
}
proc ::libtcl::randomRange {range} {
    expr int([random]*$range)
}
package provide libtk
namespace eval ::libtk {
    namespace export setDefaultFonts
    namespace export setSystemFonts
    namespace export labelEntry
    namespace export labelRadio
    namespace export labelVal
    namespace export labelReg
    namespace export labelBitReg
    namespace export textScroll
    namespace export wwwBrowser
    namespace export atmelBlue
    namespace export iPadx
    namespace export iPady
}
set ::libtk::atmelBlue #0075BA
set ::libtk::Padx 10
set ::libtk::Pady 2
global ::libtk::atmelBlue
proc ::libtk::setSystemFonts {} {
    set FontSize {6 7 8 9 10 12 14 16 18 20 24 28 32 36}
    set DefaultSize 10
    if {[lsearch [font names] "defaultFont"] == -1} then {
	font create defaultFont -family courier -size $DefaultSize
	font create defaultFontb -family courier -size $DefaultSize -weight bold
	font create defaultFonti -family courier -size $DefaultSize -slant italic
	font create defaultFontu -family courier -size $DefaultSize -underline true
	font create defaultFonto -family courier -size $DefaultSize -overstrike true
	foreach Size $FontSize {
	    font create defaultFont$Size -family courier -size $Size
	    font create defaultFont${Size}b -family courier -size $Size -weight bold
	    font create defaultFont${Size}i -family courier -size $Size -slant italic
	    font create defaultFont${Size}u -family courier -size $Size -underline true
	    font create defaultFont${Size}o -family courier -size $Size -overstrike true
	}
    }
    if {$::tcl_platform(platform) == "unix"} then {
	if {[lsearch -exact [font families] helvetica] != -1} then {
	    setDefaultFonts helvetica
	} else {
	    if {[lsearch -exact [font families] lucidatypewriter] != -1} then {
		setDefaultFonts lucidatypewriter
	    }
	}
    }
    if {$::tcl_platform(platform) == "windows"} then {
	if {[lsearch -exact [font families] Arial] != -1} then {
	    setDefaultFonts Arial
	}
    }
    option add *Font defaultFont
    return
}
proc ::libtk::setDefaultFonts {Font} {
    if {[lsearch [font names] "defaultFont"] == -1} then {
	setSystemFonts
    }
    set FontList [font names]
    foreach Fontname $FontList {
	if {[string match "defaultFont*" $Fontname] == 1} then {
	    font configure $Fontname -family $Font
	}
    }
    option add *Font defaultFont
    return
}
proc ::libtk::labelEntry {Fr Label Width Command args} {
    frame $Fr
    label $Fr.label -text $Label -width $Width -anchor w
    eval {entry $Fr.entry -relief sunken} $args
    pack $Fr.label -side left
    pack $Fr.entry -side right -fill x -expand true
    bind $Fr.entry <Return> $Command
    return $Fr.entry
}
proc ::libtk::labelRadio {Fr List Var args} {
    frame $Fr
    set i 0
    foreach SubList $List {
	set Label [lindex $SubList 0]
	set Value [lindex $SubList 1]
	eval {radiobutton $Fr.b$i -text $Label \
            -variable $Var -value $Value} $args
	pack $Fr.b$i -side top -anchor w -fill y -expand true
	incr i
    }
    return $Fr
}
proc ::libtk::labelVal {Fr Name Width Value Fmt} {
    if {[winfo exists $Fr] == 0} then {
	frame $Fr
	set LaName [label $Fr.name -text $Name -width $Width -anchor w]
	set LaValue [label $Fr.value -text [format $Fmt $Value] -anchor w -relief sunken]
	pack $LaName -side left
	pack $LaValue -side left -fill x -expand true
    } else {
	$Fr.name configure -text $Name -width $Width
	$Fr.value configure -text [format $Fmt $Value]
    }
    return $Fr
}
proc ::libtk::labelReg {Fr Name Width Val NbDigit} {
    if {[winfo exists $Fr] == 0} then {
	frame $Fr
	set LaName [label $Fr.name -text $Name -width $Width -anchor w]
	set LaValue [label $Fr.value -text [format %#0${NbDigit}x $Val] -anchor w -relief sunken]
	pack $LaName -side left
	pack $LaValue -side left -fill x -expand true
    } else {
	$Fr.name configure -text $Name -width $Width
	$Fr.value configure -text [format %#0${NbDigit}X $Val]
    }
    return $Fr
}
proc ::libtk::labelBitReg {Fr Name Width BitList} {
    set BitNameFontSize [expr [font actual defaultFont -size] - 2]
    if {[llength $BitList] > 8} then {
	error "More than 8 bits in the bit list argument of labelBitReg"
    }
    if {[winfo exists $Fr] == 0} then {
	set FrTop [frame $Fr]
	set LaReg [label $FrTop.la_name -text $Name -anchor w]
	set FrBits [frame $FrTop.bits]
	set i 0
	foreach Bit $BitList {
	    frame $FrBits.bit$i
	    label $FrBits.bit$i.name -text [lindex $Bit 0] -width $Width -font defaultFont$BitNameFontSize
	    label $FrBits.bit$i.val -text [lindex $Bit 1] -relief sunken -font defaultFont$BitNameFontSize
	    pack $FrBits.bit$i.name $FrBits.bit$i.val -fill x
	    pack $FrBits.bit$i -side left -fill x
	    incr i
	}
	pack $LaReg $FrBits -ipadx 5 -side left
	pack $FrTop
    } else {
	set i 0
	foreach Bit $BitList {
	    $Fr.bits.bit$i.name configure -text [lindex $Bit 0] -width $Width -font defaultFont$BitNameFontSize
	    $Fr.bits.bit$i.val configure -text [lindex $Bit 1] -font defaultFont$BitNameFontSize
	    incr i
	}
    }
    return $Fr
}
proc ::libtk::textScroll {Fr args} {
    frame $Fr
    eval {text $Fr.text \
        -setgrid true -wrap word \
        -xscrollcommand [list $Fr.xscroll set] \
        -yscrollcommand [list $Fr.yscroll set]} $args
    scrollbar $Fr.xscroll -orient horizontal -command [list $Fr.text xview]
    scrollbar $Fr.yscroll -orient vertical -command [list $Fr.text yview]
    pack $Fr.xscroll -side bottom -fill x
    pack $Fr.yscroll -side right -fill y
    pack $Fr.text -side left -fill both -expand true
    pack $Fr -side top -fill both -expand true
    return $Fr.text
}
proc ::libtk::wwwBrowser {url} {
    global env
    set BrowserFound 0
    if {$::tcl_platform(platform) == "windows"} then {
	if {[file exists $env(COMSPEC)]} then {
	    if {! [catch {exec $env(COMSPEC) /c start netscape http://$url &} result]} then {
		set BrowserFound 1
	    } elseif {! [catch {exec $env(COMSPEC) /c start iexplore http://$url &} result]} {
		set BrowserFound 1
	    }
	}
    } elseif {$::tcl_platform(platform) == "unix"} {
	if {! [catch {exec netscape http://$url &} result]} then {
	    set BrowserFound 1
	}
    }
    if {! $BrowserFound} then {
	if {$::tcl_platform(platform) == "unix"} then {
	    tk_messageBox -title "Error" -message "Cannot find Netscape." -icon error
	} else {
	    tk_messageBox -title "Error" -message "Cannot find Netscape nor iExplorer." -icon error
	}
    }
    return
}
package ifneeded sio 1.0 [list source [file join $dir SIO.TCL]]
package ifneeded splash 1.0 [list source [file join $dir SPLASH.TCL]]
package require Tk 8.0
package provide progressbar 1.2
namespace eval ::progressbar {
    namespace export progressbar
    variable widgetOptions
    variable widgetCommands
    variable widgetShapes
    variable widgetGlobals
    set widgetGlobals(debug) 0
}
proc ::progressbar::Init {} {
    variable widgetOptions
    variable widgetCommands
    variable widgetGlobals
    variable widgetShapes
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_Init"
    }
    array set widgetOptions [list -background {background          Background} -bd -borderwidth -bg -background -borderwidth {borderWidth         BorderWidth} -color {color               Color} -pc -percent -percent {percent             Percent} -relief {relief              Relief} -shape {shape               Shape} -variable {variable            Variable} -width {width               Width}]
    set widgetCommands [list cget configure]
    set widgetShapes [list 3D 3d flat]
    set widgetGlobals(toDraw) {
rect #bdbdbd es0 {[expr $mark +3] 2 [expr $width -2] 11} {-outline ""}
line #525252 es1 {[expr $mark +1] 2 [expr $mark +1] 11} {}
line #8c8c8c es2 {[expr $mark +2] 11 [expr $mark +2] 2 \
      [expr $width -4] 2} {}
line #8c8c8c es3 {[expr $mark +3] 11 [expr $width -3] 11 \
      [expr $width -3] 3} {}
line $rgb(0) pb0 {4 11 [expr $mark -1] 11 [expr $mark -1] 3} {}
line $rgb(1) pb1 {3 11 3 10 [expr $mark -2] 10 [expr $mark -2] 2 \
      [expr $mark -1] 2 4 2} {}
line $rgb(2) pb2 {3 2 2 2 2 11 2 10 3 10 3 9 [expr $mark -3] 9 \
      [expr $mark -3] 3 [expr $mark -2] 3 4 3} {}
line $rgb(3) pb3 {3 3 3 9 3 8 [expr $mark -3] 8 [expr $mark -3] 4 4 4} {}
line $rgb(4) pb4 {3 4 3 8 3 7 [expr $mark -3] 7 [expr $mark -3] 5 4 5} {}
line $rgb(5) pb5 {3 5 3 7 3 6 [expr $mark -3] 6} {}
line #000000 mrk {$mark 1 $mark 12} {}
line #adadad fr0 {0 12 0 0 [expr $width -1] 0} {}
line #ffffff fr1 {1 13 [expr $width -1] 13 [expr $width -1] 1} {}
line #000000 fr2 {1 1 [expr $width -2] 1 [expr $width -2] 12 1 12 1 1} {}
}
    set widgetGlobals(@blue0) {#000052 #0031ce #3163ff #639cff #9cceff #efefef}
    set widgetGlobals(@blue1) {#000021 #00639c #009cce #00ceff #63ffff #ceffff}
    set widgetGlobals(@blue2) {#000052 #31319c #6363ce #9c9cff #ceceff #efefef}
    set widgetGlobals(@blue3) {#21214a #52527b #63639c #8484bd #b5b5ef #ceceff}
    set widgetGlobals(@blue4) {#29396b #4a6b9c #6384b5 #739cd6 #94b5ef #adceff}
    set widgetGlobals(@green0) {#003131 #08736b #318c94 #5abdad #63dece #ceffef}
    set widgetGlobals(@green1) {#001000 #003100 #316331 #639c63 #9cce9c #ceffce}
    set widgetGlobals(@green2) {#002100 #006331 #319c63 #31ce63 #63ff9c #ceffce}
    set widgetGlobals(@green3) {#003131 #316363 #427b7b #639c9c #9ccece #bdefef}
    set widgetGlobals(@yellow0) {#101010 #636300 #9c9c00 #cece00 #ffff00 #ffff9c}
    set widgetGlobals(@yellow1) {#8c7321 #cead39 #e7c642 #f7de63 #f7de63 #ffffe7}
    set widgetGlobals(@red0) {#420000 #9c0000 #ce3131 #ff6363 #ff9c9c #ffcece}
    set widgetGlobals(@red1) {#210000 #9c3100 #ce6331 #ff9c63 #ffce9c #ffffce}
    set widgetGlobals(@magenta0) {#210000 #630063 #9c319c #ce63ce #ff9cff #ffceff}
    set widgetGlobals(@brown0) {#210000 #633100 #9c6331 #ce9c63 #efb573 #ffdeb5}
    set widgetGlobals(@brown1) {#310000 #7b4242 #9c6363 #ce9c9c #efcece #ffdede}
    set widgetGlobals(@gray0) {#212121 #525252 #737373 #adadad #cecece #efefef}
    set tmpWidget ".__tmp__"
    label $tmpWidget
    foreach option [list Background Relief] {
	set values [$tmpWidget configure -[string tolower $option]]
	option add *Progressbar.$option [lindex $values 3]
    }
    destroy $tmpWidget
    option add *Progressbar.borderWidth 5 widgetDefault
    option add *Progressbar.color @blue0 widgetDefault
    option add *Progressbar.percent 0 widgetDefault
    option add *Progressbar.shape 3D widgetDefault
    option add *Progressbar.variable {} widgetDefault
    option add *Progressbar.width 180 widgetDefault
    bind Progressbar <Destroy> [list ::progressbar::DestroyHandler %W]
}
proc ::progressbar::progressbar {args} {
    variable widgetOptions
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_progressbar '$args'"
    }
    if {![info exists widgetOptions]} then {
	Init
    }
    if {[llength $args] == 0} then {
	error "wrong # args: should be \"progressbar pathName ?options?\""
    }
    if {[winfo exists [lindex $args 0]]} then {
	error "window name \"[lindex $args 0]\" already exists"
    }
    foreach {name value} [lrange $args 1 end] {
	Canonize [lindex $args 0] option $name
    }
    set w [eval Build $args]
    return $w
}
proc ::progressbar::Build {w args} {
    variable widgetOptions
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_Build '$w' '$args'"
    }
    namespace eval ::progressbar::$w {
	variable options
	variable widgets
    }
    upvar ::progressbar::${w}::widgets widgets
    upvar ::progressbar::${w}::options options
    set widgets(this) [frame $w -class Progressbar]
    foreach name [array names widgetOptions] {
	if {[llength $widgetOptions($name)] == 1} then continue
	set optName [lindex $widgetOptions($name) 0]
	set optClass [lindex $widgetOptions($name) 1]
	set options($name) [option get $w $optName $optClass]
	if {$widgetGlobals(debug) > 1} then {
	    puts stderr "pb_Build:Opt '$w' '$optName' '$optClass' '$options($name)'"
	}
    }
    if {[llength $args] > 0} then {
	array set options $args
    }
    set widgets(canvas) $w.pb
    set widgets(frame) ::progressbar::${w}::$w
    rename ::$w $widgets(frame)
    proc ::$w {command args} "eval ::progressbar::WidgetProc {$w} \$command \$args"
    if {[catch "Configure $widgets(this) [array get options]" error]} then {
	catch {destroy $w}
    }
    return $w
}
proc ::progressbar::WidgetProc {w command args} {
    variable widgetOptions
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_WidgetProc '$w' '$command' '$args'"
    }
    upvar ::progressbar::${w}::widgets widgets
    upvar ::progressbar::${w}::options options
    set command [Canonize $w command $command]
    set result ""
    catch {unset priorSelection}
    switch $command {
    cget {
	    if {[llength $args] != 1} then {
		error "wrong # args: should be $w cget option"
	    }
	    set opt [Canonize $w option [lindex $args 0]]
	    set result $options($opt)
	}
    configure {
	    set result [eval Configure {$w} $args]
	}
    }
    return $result
}
proc ::progressbar::HumanizeList {list} {
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_HumanizeList $list"
    }
    if {[llength $list] == 1} then {
	return [lindex $list 0]
    } else {
	set list [lsort $list]
	set secondToLast [expr {[llength $list] -2}]
	set most [lrange $list 0 $secondToLast]
	set last [lindex $list end]
	return "[join $most {, }] or $last"
    }
}
proc ::progressbar::Canonize {w object opt} {
    variable widgetOptions
    variable widgetCommands
    variable widgetGlobals
    variable widgetShapes
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_Canonize '$w' '$object' '$opt'"
    }
    switch $object {
    command {
	    if {[lsearch -exact $widgetCommands $opt] >= 0} then {
		return $opt
	    }
	    set list $widgetCommands
	    foreach element $list {
		set tmp($element) ""
	    }
	    set matches [array names tmp ${opt}*]
	}
    option {
	    if {[info exists widgetOptions($opt)] && [llength $widgetOptions($opt)] == 3} then {
		return $opt
	    }
	    set list [array names widgetOptions]
	    set matches [array names widgetOptions ${opt}*]
	}
    shape {
	    if {[lsearch -exact $widgetShapes $opt] >= 0} then {
		return $opt
	    }
	    set list $widgetShapes
	    foreach element $list {
		set tmp($element) ""
	    }
	    set matches [array names tmp ${opt}*]
	}
    }
    if {[llength $matches] == 0} then {
	set choices [HumanizeList $list]
	error "unknown $object \"$opt\"; must be one of $choices"
    } elseif {[llength $matches] == 1} {
	set opt [lindex $matches 0]
	switch $object {
	option {
		if {[llength $widgetOptions($opt)] == 1} then {
		    set opt $widgetOptions($opt)
		}
	    }
	}
	return $opt
    } else {
	set choices [HumanizeList $list]
	error "ambiguous $object \"$opt\"; must be one of $choices"
    }
}
proc ::progressbar::RGBs {color} {
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_RGB '$color'"
    }
    set color [winfo rgb . $color]
    set R [expr int([lindex $color 0] / 256)]
    set G [expr int([lindex $color 1] / 256)]
    set B [expr int([lindex $color 2] / 256)]
    set rgb {}
    foreach factor {0.13 0.32 0.45 0.68 0.8 0.93} {
	set r [expr int($R * $factor)]
	set g [expr int($G * $factor)]
	set b [expr int($B * $factor)]
	lappend rgb [format "#%02x%02x%02x" $r $g $b]
    }
    lappend rgb [format "#%02x%02x%02x" $R $G $B]
    return $rgb
}
proc ::progressbar::Configure {w args} {
    variable widgetOptions
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_Configure '$w' '$args'"
    }
    upvar ${w}::widgets widgets
    upvar ${w}::options options
    if {[llength $args] == 0} then {
	set results {}
	foreach opt [lsort [array names widgetOptions]] {
	    if {[llength $widgetOptions($opt)] == 1} then {
		set alias $widgetOptions($opt)
		set optName $widgetOptions($alias)
		lappend results [list $opt $optName]
	    } else {
		set optName [lindex $widgetOptions($opt) 0]
		set optClass [lindex $widgetOptions($opt) 1]
		set default [option get $w $optName $optClass]
		lappend results [list $opt $optName $optClass $default $options($opt)]
	    }
	}
	return $results
    }
    if {[llength $args] == 1} then {
	set opt [Canonize $w option [lindex $args 0]]
	set optName [lindex $widgetOptions($opt) 0]
	set optClass [lindex $widgetOptions($opt) 1]
	set default [option get $w $optName $optClass]
	set results [list $opt $optName $optClass $default $options($opt)]
	return $results
    }
    if {[expr {[llength $args]%2}] == 1} then {
	error "value for \"[lindex $args end]\" missing"
    }
    foreach {name value} $args {
	set name [Canonize $w option $name]
	set opts($name) $value
    }
    foreach option [array names opts] {
	set newValue $opts($option)
	if {[info exists options($option)]} then {
	    set oldValue $options($option)
	}
	if {$widgetGlobals(debug) > 2} then {
	    puts stderr "pb_Configure:Opt '$option' n='$newValue' o='$oldValue'"
	}
	switch -- $option {
	-background -
	-borderwidth -
	-relief {
		if {[winfo exists $widgets(this)]} then {
		    $widgets(frame) configure $option $newValue
		    set options($option) [$widgets(frame) cget $option]
		}
	    }
	-color {
		switch -- $newValue {
		@blue0 -
		@blue1 -
		@blue2 -
		@blue3 -
		@blue4 -
		@green0 -
		@green1 -
		@green2 -
		@green3 -
		@yellow0 -
		@yellow1 -
		@red0 -
		@red1 -
		@magenta0 -
		@brown0 -
		@brown1 -
		@gray0 {
			set options(rgb) $widgetGlobals($newValue)
		    }
		@* {
			set options(rgb) $widgetGlobals(@saphir)
		    }
		default {
			set options(rgb) [RGBs $newValue]
		    }
		}
		set options(rgbHasChanged) 1
	    }
	-percent {
		set options($option) $newValue
	    }
	-shape {
		set options($option) [Canonize $w shape $newValue]
		set options(rgbHasChanged) 1
	    }
	-variable {
		if {[info procs Trace($w)] != ""} then {
		    uplevel 3 trace vdelete $oldValue wu ::progressbar::Trace($w)
		    unset widgetGlobals($w)
		    after idle "catch {rename Trace($w) {}}"
		}
		if {$newValue != ""} then {
		    proc ::progressbar::Trace($w) {name1 name2 op} "
variable widgetGlobals
if {\$widgetGlobals(debug)} {
puts stderr \"pb_Trace($w) '\$name1' '\$name2' '\$op'\"
}
switch -- \$op {
w {
if {\$name2 != \"\"} {
upvar 1 \${name1}(\$name2) var
catch {$w configure -percent \$var}
} else {
upvar 1 \$name1 var
catch {$w configure -percent \$var}
}
}
u {
unset widgetGlobals($w)
after idle \"catch {rename Trace($w) {}}\"
}
}
"
		    uplevel 3 trace variable $newValue wu ::progressbar::Trace($w)
		}
		set options($option) $newValue
		set widgetGlobals($w) $newValue
	    }
	-width {
		if {$newValue < 20} then {
		    error "a -width of less than 20 is not supported."
		}
		if {[winfo exists $widgets(canvas)]} then {
		    $widgets(canvas) configure $option $newValue
		    set options($option) [$widgets(canvas) cget $option]
		} else {
		    set options($option) $newValue
		}
	    }
	}
    }
    Draw $w
}
proc ::progressbar::DestroyHandler {w} {
    variable widgetGlobals
    if {$widgetGlobals(debug)} then {
	puts stderr "pb_DestroyHandler '$w'"
    }
    if {[info procs Trace($w)] != ""} then {
	uplevel 1 trace vdelete $widgetGlobals($w) wu ::progressbar::Trace($w)
	unset widgetGlobals($w)
	after idle "catch {rename Trace($w) {}}"
    }
    if {[string compare [winfo class $w] "Progressbar"] == 0} then {
	namespace delete ::progressbar::$w
	rename $w {}
    }
}
proc ::progressbar::Draw {w} {
    variable widgetGlobals
    if {$widgetGlobals(debug) > 2} then {
	puts stderr "pb_Draw '$w'"
    }
    upvar ${w}::widgets widgets
    upvar ${w}::options options
    set width $options(-width)
    set percent $options(-percent)
    if {$options(-shape) == "flat"} then {
	set minDisplay 0
	if {[llength $options(rgb)] == 7} then {
	    set rgb(0) [lindex $options(rgb) 6]
	} else {
	    set rgb(0) [lindex $options(rgb) 2]
	}
	set rgb(1) $rgb(0)
	set rgb(2) $rgb(0)
	set rgb(3) $rgb(0)
	set rgb(4) $rgb(0)
	set rgb(5) $rgb(0)
    } else {
	set minDisplay 7
	set rgb(0) [lindex $options(rgb) 0]
	set rgb(1) [lindex $options(rgb) 1]
	set rgb(2) [lindex $options(rgb) 2]
	set rgb(3) [lindex $options(rgb) 3]
	set rgb(4) [lindex $options(rgb) 4]
	set rgb(5) [lindex $options(rgb) 5]
    }
    if {$percent < 0} then {
	set percent 0
    } elseif {$percent > 100} {
	set percent 100
    }
    if {$percent == 0} then {
	set mark $minDisplay
    } else {
	set mark [expr (($width - $minDisplay) / 100.0 * $percent) + $minDisplay]
    }
    if {![winfo exists $widgets(canvas)]} then {
	canvas $widgets(canvas) -width $width -height 14 -bd 0 -highlightthickness 0
	pack $widgets(canvas) -side left -anchor nw -fill both
	foreach {type color tag coords opts} $widgetGlobals(toDraw) {
	    eval $widgets(canvas) create $type $coords -fill $color -tag t$tag $opts
	}
	set options(rgbHasChanged) 0
	return
    }
    foreach {type color tag coords opts} $widgetGlobals(toDraw) {
	eval $widgets(canvas) coords t$tag $coords
	if {$options(rgbHasChanged)} then {
	    eval $widgets(canvas) itemconfigure t$tag -fill $color
	}
    }
    set options(rgbHasChanged) 0
}
proc Rnotebook:create {w args} {
    global Rnotebook tcl_platform
    frame $w -borderwidth 0 -relief flat
    set Rnotebook($w,nbtab) 1
    set Rnotebook($w,tabs) {1}
    set Rnotebook($w,current) 0
    set Rnotebook($w,theight) 30
    set Rnotebook($w,padx) 0
    set Rnotebook($w,bwidth) 2
    set Rnotebook($w,background) [$w cget -background]
    set Rnotebook($w,foreground) black
    foreach {tag value} $args {
	switch -- $tag {
	-borderwidth {
		set Rnotebook($w,bwidth) $value
	    }
	-height {
		set Rnotebook($w,theight) $value
	    }
	-tabs {
		set Rnotebook($w,tabs) $value
		set Rnotebook($w,nbtab) [llength $value]
	    }
	-nbtab {
		set Rnotebook($w,nbtab) $value
	    }
	-padx {
		set Rnotebook($w,padx) $value
	    }
	-background {
		set Rnotebook($w,background) $value
	    }
	-foreground {
		set Rnotebook($w,foreground) $value
	    }
	}
    }
    frame $w.tabs -borderwidth 0 -relief flat
    frame $w.body -borderwidth $Rnotebook($w,bwidth) -relief raised -background $Rnotebook($w,background)
    frame $w.mask -borderwidth 0 -relief flat -background $Rnotebook($w,background)
    frame $w.mskl -borderwidth 0 -relief flat -background $Rnotebook($w,background)
    if [string compare $tcl_platform(platform) windows] then {
	frame $w.mskl.ml -borderwidth $Rnotebook($w,bwidth) -relief sunken
	place $w.mskl.ml -x -$Rnotebook($w,bwidth) -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 3 * $Rnotebook($w,bwidth)]
    } else {
	frame $w.mskl.ml -borderwidth $Rnotebook($w,bwidth) -relief raised
	place $w.mskl.ml -x 0 -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 4 * $Rnotebook($w,bwidth)]
    }
    frame $w.mskr -borderwidth 0 -relief flat -background $Rnotebook($w,background)
    if [string compare $tcl_platform(platform) windows] then {
	frame $w.mskr.mr -borderwidth $Rnotebook($w,bwidth) -relief sunken
	place $w.mskr.mr -x 0 -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 3 * $Rnotebook($w,bwidth)]
    } else {
	frame $w.mskr.mr -borderwidth $Rnotebook($w,bwidth) -relief raised
	place $w.mskr.mr -x -$Rnotebook($w,bwidth) -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 4 * $Rnotebook($w,bwidth)]
    }
    place $w.tabs -x 0 -y 0 -relwidth 1.0 -height $Rnotebook($w,theight)
    place $w.body -x 0 -y $Rnotebook($w,theight) -relwidth 1.0 -relheight 1.0 -height -$Rnotebook($w,theight)
    for {set ind 1} {$ind <= $Rnotebook($w,nbtab)} {incr ind} {
	Rnotebook:addtab $w $ind
    }
    eval Rnotebook:raise $w 1
}
proc Rnotebook:addtab {w ind} {
    global Rnotebook
    set i2 [expr $ind - 1]
    set txt [lindex $Rnotebook($w,tabs) $i2]
    if {! [string length $txt]} then {
	set txt $ind
    }
    button $w.tabs.b$ind -text $txt -borderwidth $Rnotebook($w,bwidth) -background $Rnotebook($w,background) -foreground $Rnotebook($w,foreground) -command "Rnotebook:raise $w $ind"
    pack $w.tabs.b$ind -side left -pady 0 -padx $Rnotebook($w,padx) -fill y
    bind $w.tabs.b$ind <Configure> "Rnotebook:raise $w current"
    frame $w.body.f$ind -borderwidth 0 -background $Rnotebook($w,background)
}
proc Rnotebook:config {w args} {
    global Rnotebook tcl_platform
    set nbt $Rnotebook($w,nbtab)
    foreach {tag value} $args {
	switch -- $tag {
	-borderwidth {
		set Rnotebook($w,bwidth) $value
		$w.body configure -borderwidth $Rnotebook($w,bwidth)
		$w.mskl.ml configure -borderwidth $Rnotebook($w,bwidth)
		$w.mskr.mr configure -borderwidth $Rnotebook($w,bwidth)
		set lst [winfo children $w.tabs]
		foreach wid $lst {
		    $wid configure -borderwidth $Rnotebook($w,bwidth)
		}
		if [string compare $tcl_platform(platform) windows] then {
		    place $w.mskl.ml -x -$Rnotebook($w,bwidth) -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 3 * $Rnotebook($w,bwidth)]
		} else {
		    place $w.mskl.ml -x 0 -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 4 * $Rnotebook($w,bwidth)]
		}
		if [string compare $tcl_platform(platform) windows] then {
		    place $w.mskr.mr -x 0 -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 3 * $Rnotebook($w,bwidth)]
		} else {
		    place $w.mskr.mr -x -$Rnotebook($w,bwidth) -y -$Rnotebook($w,bwidth) -width [expr 2 * $Rnotebook($w,bwidth)] -height [expr 4 * $Rnotebook($w,bwidth)]
		}
	    }
	-background {
		set Rnotebook($w,background) $value
		$w.body configure -background $Rnotebook($w,background)
		$w.mskl.ml configure -background $Rnotebook($w,background)
		$w.mskr.mr configure -background $Rnotebook($w,background)
		set lst [winfo children $w.tabs]
		foreach wid $lst {
		    $wid configure -background $Rnotebook($w,background)
		}
		$w.mask configure -background $Rnotebook($w,background)
	    }
	-foreground {
		set Rnotebook($w,foreground) $value
		set lst [winfo children $w.tabs]
		foreach wid $lst {
		    $wid configure -foreground $Rnotebook($w,foreground)
		}
	    }
	-height {
		set Rnotebook($w,theight) $value
		place $w.tabs -x 0 -y 0 -relwidth 1.0 -height $Rnotebook($w,theight)
		place $w.body -x 0 -y $Rnotebook($w,theight) -relwidth 1.0 -relheight 1.0 -height -$Rnotebook($w,theight)
	    }
	-padx {
		set Rnotebook($w,padx) $value
		set lst [winfo children $w.tabs]
		foreach wid $lst {
		    pack $wid -padx $Rnotebook($w,padx)
		}
	    }
	-tabs {
		set Rnotebook($w,tabs) $value
		set Rnotebook($w,nbtab) [llength $value]
	    }
	-nbtab {
		set Rnotebook($w,nbtab) $value
	    }
	}
    }
    if {$nbt < $Rnotebook($w,nbtab)} then {
	for {set ind [expr $nbt+1]} {$ind <= $Rnotebook($w,nbtab)} {incr ind} {
	    Rnotebook:addtab $w $ind
	}
    }
}
proc Rnotebook:raise {w num} {
    global Rnotebook
    if {![string compare $num "current"]} then {
	set num $Rnotebook($w,current)
    }
    if {$num == 0} then {
	set num 1
    }
    if {$num != $Rnotebook($w,current)} then {
	pack forget $w.body.f$Rnotebook($w,current)
	pack $w.body.f$num -fill both -expand 1
    }
    set Rnotebook($w,current) $num
    set bw $Rnotebook($w,bwidth)
    set x0 [expr [winfo x $w.tabs.b$num] + [winfo x $w.tabs] + $bw]
    set y0 [expr [winfo y $w.tabs.b$num] + [winfo y $w.tabs] + [winfo height $w.tabs.b$num] - $bw]
    set w0 [expr [winfo width $w.tabs.b$num] - ($bw * 2)]
    set h0 [expr $bw * 2]
    place $w.mask -x $x0 -y $y0 -width $w0 -height $h0
    set x1 [expr $x0 - $bw]
    set y1 $y0
    set w1 $bw
    set h1 $h0
    place $w.mskl -x $x1 -y $y1 -width $w1 -height $h1
    set x2 [expr $x0 + $w0]
    set y2 $y0
    set w2 $bw
    set h2 $h0
    place $w.mskr -x $x2 -y $y2 -width $w2 -height $h2
}
proc Rnotebook:frame {w num} {
    global Rnotebook
    set i "$w.body.f$num"
    if [winfo exists $i] then {
	return $i
    } else {
	return {}
    }
}
proc Rnotebook:button {w num} {
    global Rnotebook
    set i "$w.tabs.b$num"
    if [winfo exists $i] then {
	return $i
    } else {
	return {}
    }
}
package provide sio 1.2
namespace eval ::sio:: {
    namespace export openDevice clearRxBuffer autoBaudSync startTimeOutCounter readLine closeDevice sendChar sendAscii waitForXon setBaud sioVars devId
    variable sioVars
    variable devId
    set sioVars(SerialEventOccured) 0
    set sioVars(bootloaderId) 0
    set sioVars(AfterTimeOutId) 0
    set sioVars(RxBuffer) ""
    set sioVars(TxOff) 0
    set sioVars(TxOn) 0
    set sioVars(XOFF) [format %c 0x13]
    set sioVars(XON) [format %c 0x11]
    set sioVars(AbortTx) 0
    set sioVars(TempString) ""
}
proc ::sio::InterruptHandlerXonXoff {} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    variable devId
    StopTimeOutCounter
    set ::sio::sioVars(AbortTx) 0
    if {[catch {set ::sio::sioVars(TempString) [read $devId]} err_id]} then {
	set ::sio::sioVars(AbortTx) 1
	#dbgShowError "  reading error"
    } else {
	set xoffPos [string first $::sio::sioVars(XOFF) $::sio::sioVars(TempString)]
	set xonPos [string first $::sio::sioVars(XON) $::sio::sioVars(TempString)]
	if {$xoffPos != -1} then {
	    set ::sio::sioVars(TxOff) 1
	    set ::sio::sioVars(TxOn) 0
	    #dbgShowInfo "  XOFF received"
	    set ::sio::sioVars(TempString) [string replace $::sio::sioVars(TempString) $xoffPos $xoffPos]
	} elseif {$xonPos != -1} {
	    set ::sio::sioVars(TxOn) 1
	    set ::sio::sioVars(TxOff) 0
	    #dbgShowInfo "  XON received"
	    set ::sio::sioVars(TempString) [string replace $::sio::sioVars(TempString) $xonPos $xonPos]
	}
	append ::sio::sioVars(RxBuffer) $::sio::sioVars(TempString)
    }
    set ::sio::sioVars(SerialEventOccured) 1
    #dbgShowVar " RxBuffer = $::sio::sioVars(RxBuffer)"
    #dbgEndProc [info level [info level]]
    return
}
proc ::sio::InterruptHandlerNoXonXoff {} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    variable devId
    global tcl_platform
    StopTimeOutCounter
    set ::sio::sioVars(SerialEventOccured) 1
    if {[catch {set ::sio::sioVars(TempString) [read $devId]} err_id]} then {
	set ::sio::sioVars(AbortTx) 1
    } else {
	append ::sio::sioVars(RxBuffer) $::sio::sioVars(TempString)
    }
    #dbgShowVar " RxBuffer = $::sio::sioVars(RxBuffer)"
    #dbgEndProc [info level [info level]]
    return
}
proc ::sio::openDevice {Device Baud SyncMode Parity Data Stop XonCtrl} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    variable devId
    if {[catch {set devId [open $Device RDWR]} err_id]} then {
	set devId 0
    } else {
	if {$SyncMode == "sync"} then {
	    fconfigure $devId -mode $Baud,$Parity,$Data,$Stop -blocking 1 -buffering none
	} else {
	    fconfigure $devId -mode $Baud,$Parity,$Data,$Stop -blocking 0 -buffering none
	    if {$XonCtrl} then {
		fileevent $devId readable ::sio::InterruptHandlerXonXoff
	    } else {
		fileevent $devId readable ::sio::InterruptHandlerNoXonXoff
	    }
	}
    }
    #dbgEndProc [info level [info level]]
    return $devId
}
proc ::sio::setBaud {Baud} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    variable devId
    set currentConfig [fconfigure $devId]
    set commaIndex [string first "," $currentConfig]
    set config [string range $currentConfig $commaIndex [expr $commaIndex + 5]]
    fconfigure $devId -mode $Baud$config
    #dbgEndProc [info level [info level]]
    return
}
proc ::sio::clearRxBuffer {} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    set ::sio::sioVars(RxBuffer) ""
    update
    #dbgEndProc [info level [info level]]
    return 1
}
proc ::sio::autoBaudSync {responseChar timeOutDelay} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    global ExtraTimeOut
    clearRxBuffer
    startTimeOutCounter $timeOutDelay
    set ExtraTimeOut 1
    set ExtraTimeOutId [after 5000 "set ExtraTimeOut -1"]
    set sync 1
    sendChar "U"
    while {[string index $::sio::sioVars(RxBuffer) end] != $responseChar} {
	if {$::sio::sioVars(SerialEventOccured) == -1} then {
	    set sync -2
	    #dbgShowError "Autobaud sync Time out"
	    break
	}
	if {$ExtraTimeOut == -1} then {
	    set sync -2
	    #dbgShowError "Autobaud sync Extra Time out"
	    break
	}
	update
    }
    if {$ExtraTimeOut == 1} then {
	catch [after cancel $ExtraTimeOutId]
    }
    if {$sync == 1} then {
	if {[string length $::sio::sioVars(RxBuffer)] == 1} then {
	    set ::sio::sioVars(bootloaderId) 0
	    #dbgShowVar "bootloaderId = $::sio::sioVars(bootloaderId)"
	} elseif {[string length $::sio::sioVars(RxBuffer)] == 5} {
	    set ::sio::sioVars(bootloaderId) [string range $::sio::sioVars(RxBuffer) 0 end-1]
	    #dbgShowVar "bootloaderId = $::sio::sioVars(bootloaderId)"
	} else {
	    set ::sio::sioVars(bootloaderId) X
	    #dbgShowVar "bootloaderId = $::sio::sioVars(bootloaderId)"
	    set sync -1
	}
    }
    clearRxBuffer
    #dbgShowVar "sync = $sync"
    #dbgEndProc [info level [info level]]
    return $sync
}
proc ::sio::startTimeOutCounter {TimeOut} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    set ::sio::sioVars(SerialEventOccured) 0
    set ::sio::sioVars(AfterTimeOutId) [after $TimeOut "set ::sio::sioVars(SerialEventOccured) -1"]
    update
    #dbgEndProc [info level [info level]]
    return 1
}
proc ::sio::StopTimeOutCounter {} {
    #dbgBeginProc [info level [info level]]
    variable sioVars
    catch [after cancel $::sio::sioVars(AfterTimeOutId)]
    #dbgEndProc [info level [info level]]
    return 1
}
proc ::sio::readLine {} {
    #dbgBeginProc [info level [info level]]
    variable devId
    #dbgEndProc [info level [info level]]
    return [gets $devId]
}
proc ::sio::closeDevice {} {
    #dbgBeginProc [info level [info level]]
    variable devId
    if {([info exists devId]) &&($devId != 0)} then {
	catch [close $devId]
	catch [unset devId]
    }
    #dbgEndProc [info level [info level]]
    return 1
}
proc ::sio::sendChar {Cput} {
    #dbgBeginProc [info level [info level]]
    variable devId
    if {[catch {puts -nonewline $devId $Cput}]} then {
	set status 0
    } else {
	set status 1
    }
    #dbgEndProc [info level [info level]]
    return $status
}
proc ::sio::sendAscii {byte} {
    #dbgBeginProc [info level [info level]]
    variable devId
    sendChar [string index $byte end-1]
    sendChar [string index $byte end]
    #dbgEndProc [info level [info level]]
    return 1
}
proc ::sio::waitForXon {} {
    #dbgBeginProc [info level [info level]]
    while {$::sio::sioVars(TxOff)} {
	update
    }
    #dbgEndProc [info level [info level]]
    return
}
package provide splash 1.0
namespace eval ::splash {
    namespace export createSplash updateSplash removeSplash
}
proc ::splash::createSplash {image product copyright msg} {
    global tcl_version tk_version tcl_platform
    global tcl_patchLevel
    removeSplash
    toplevel .splash
    wm overrideredirect .splash 1
    wm withdraw .splash
    dialogPosition .splash
    set frm .splash.top
    frame $frm -bd 2 -relief groove
    label $frm.logo -image $image
    label $frm.product -text "$product"
    message $frm.copyright -text "$copyright" -width 3i
    label $frm.tclversion -text "Tcl $tcl_version/Tk $tk_version, $tcl_patchLevel"
    label $frm.osversion -text "$tcl_platform(os) $tcl_platform(osVersion)"
    pack $frm.logo -side top -fill x -pady 4 -ipadx 4 -ipady 4
    pack $frm.product $frm.copyright $frm.tclversion $frm.osversion -side top -fill x
    pack $frm -side top -fill x -padx 8 -pady 8
    set frm .splash.bottom
    frame $frm -bd 2 -relief groove
    label $frm.msg -text "$msg" -anchor w
    pack $frm.msg -side left -ipadx 6 -ipady 4
    pack $frm -side bottom -fill x -padx 8 -pady 8
    wm deiconify .splash
    update
}
proc ::splash::updateSplash {msg} {
    set name .splash.bottom.msg
    if {[winfo exists $name]} then {
	$name config -text "$msg"
	update
    }
}
proc ::splash::removeSplash {} {
    if {[winfo exists .splash]} then {
	destroy .splash
    }
}
proc ::splash::dialogPosition {dlg} {
    set width [winfo screenwidth .]
    set height [winfo screenheight .]
    set x [expr ($width/2) - 260]
    set y [expr ($height/2) - 260]
    wm geometry $dlg +$x+$y
}
lappend auto_path "."
auto_mkindex . libtcl.tcl libtk.tcl about.tcl progressbar.tcl combobox.tcl fontchoose.tcl
proc main {} {
    wm title . "Tcl/Tk Applab Lib Test"
    wm protocol . WM_DELETE_WINDOW exit
    set font {Helvetica 14}
    set text_f [frame .textFrame]
    scrollbar .s -orient vertical -command {.t yview} -highlightthickness 0 -takefocus 1
    pack .s -in .textFrame -side right -fill y
    text .t -yscrollcommand {.s set} -wrap word -width 60 -height 30 -font $font -setgrid 1 -highlightthickness 0 -padx 4 -pady 2 -takefocus 0
    pack .t -in .textFrame -expand y -fill both -padx 1
    pack .textFrame -expand yes -fill both
    .t tag configure demospace -lmargin1 1c -lmargin2 1c
    .t tag configure title -font {Helvetica 18 bold}
    .t tag configure demo -lmargin1 1c -lmargin2 1c -foreground blue -underline 1
    .t tag configure visited -lmargin1 1c -lmargin2 1c -foreground #303080 -underline 1
    .t tag bind demo <ButtonRelease-1> {
invoke [.t index {@%x,%y}]
}
    set lastLine ""
    .t insert end "Tk Widget Test Using AppLab Tcl/Tk Lib\n" title
    .t insert end {Select an item to run the test.}
    .t insert end " \n " {demospace}
    .t insert end " \n " {} "About window" title
    .t insert end " \n " {demospace}
    .t insert end "All fields are used (default font)" {demo demo_about_full}
    .t insert end " \n " {demospace}
    .t insert end "About no title" {demo demo_about_no_title}
    .t insert end " \n " {demospace}
    .t insert end "About no authors" {demo demo_about_no_authors}
    .t insert end " \n " {demospace}
    .t insert end "About no copyright" {demo demo_about_no_copyright}
    .t insert end " \n " {demospace}
    .t insert end "About no comment" {demo demo_about_no_comment}
    .t insert end " \n " {demospace}
    .t insert end "About no logo" {demo demo_about_no_logo}
    .t insert end " \n " {demospace}
    .t insert end "About no url" {demo demo_about_no_url}
    .t insert end " \n " {demospace}
    .t insert end "About no info" {demo demo_about_no_info}
    .t insert end " \n " {demospace}
    .t insert end "All fields are used (courier font)" {demo demo_about_full_courier}
    .t insert end " \n " {demospace}
    .t insert end " \n " {} "Progress Bar" title
    .t insert end " \n " {demospace}
    .t insert end "Flat Progress Bar" {demo demo_progressbar_flat}
    .t insert end " \n " {demospace}
    .t insert end "3D Progress Bar" {demo demo_progressbar_3d}
    .t insert end " \n " {demospace}
    .t insert end " \n " {} "Fonts" title
    .t insert end " \n " {demospace}
    .t insert end "Font Choose" {demo demo_font_choose}
    .t insert end " \n " {demospace}
    .t configure -state disabled
    focus .s
    button .ok -text OK -command {set lib_test_ok 1}
    pack .ok
    tkwait variable lib_test_ok
    exit
}
proc invoke index {
    global tk_library
    set tags [.t tag names $index]
    set i [lsearch -glob $tags demo_*]
    if {$i < 0} then {
	return
    }
    set cursor [.t cget -cursor]
    .t configure -cursor watch
    update
    set demo [string range [lindex $tags $i] 5 end]
    $demo
    update
    .t configure -cursor $cursor
    .t tag add visited "$index linestart +1 chars" "$index lineend -1 chars"
}
namespace import about::*
proc about_full {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -authors "James Brown\nBob Marley\nJimmy Hendix" -copyright "(C) 2000 Application Lab" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -logo "atmel_wm.gif" -url "www.atmel-wm.com"
}
proc about_no_title {} {
    setSystemFonts
    showAbout -authors "James Brown\nBob Marley\nJimmy Hendix" -copyright "(C) 2000 Application Lab" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -logo "atmel_wm.gif" -url "www.atmel-wm.com"
}
proc about_no_authors {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -copyright "(C) 2000 Application Lab" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -logo "atmel_wm.gif" -url "www.atmel-wm.com"
}
proc about_no_copyright {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -authors "James Brown\nBob Marley\nJimmy Hendix" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -logo "atmel_wm.gif" -url "www.atmel-wm.com"
}
proc about_no_comment {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -authors "James Brown\nBob Marley\nJimmy Hendix" -copyright "(C) 2000 Application Lab" -logo "atmel_wm.gif" -url "www.atmel-wm.com"
}
proc about_no_logo {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -authors "James Brown\nBob Marley\nJimmy Hendix" -copyright "(C) 2000 Application Lab" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -url "www.atmel-wm.com"
}
proc about_no_url {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -authors "James Brown\nBob Marley\nJimmy Hendix" -copyright "(C) 2000 Application Lab" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -logo "atmel_wm.gif"
}
proc about_no_info {} {
    setSystemFonts
    showAbout -title "Test" -version "0.0.0" -logo "atmel_wm.gif" -url "www.atmel-wm.com"
}
proc about_full_courier {} {
    setSystemFonts
    setDefaultFonts courier
    showAbout -title "Test" -version "0.0.0" -authors "James Brown\nBob Marley\nJimmy Hendix" -copyright "(C) 2000 Application Lab" -comment "This window demonstates the About widget called with all options used (title, version, authors, copyright, comment, logo and url)." -logo "atmel_wm.gif" -url "www.atmel_wm.com"
}
proc progressbar_flat {} {
    setSystemFonts
    toplevel .top
    pack [set w [::progressbar::progressbar .top.pb -shape flat]]
    for {set percent 0} {$percent <= 100} {incr percent} {
	$w configure -percent $percent
	update
    }
    destroy .top
}
proc progressbar_3d {} {
    setSystemFonts
    toplevel .top
    pack [set w [::progressbar::progressbar .top.pb -shape 3D]]
    for {set percent 0} {$percent <= 100} {incr percent} {
	$w configure -percent $percent
	update
    }
    destroy .top
}
proc font_choose {} {
    setSystemFonts
    puts [fontchoose]
}
main
